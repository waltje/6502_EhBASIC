ca65 V2.19 - Git ffa83c3
Main file   : ehbasic.asm
Current file: ehbasic.asm

000000r 1               .include  "ehbasic-ca65.inc"
000000r 2               APPLE2 = 1                      ; enable Apple II mods
000000r 2               NO_INT = 1                      ; disable interrupt handling
000000r 2               LOW_TOKENS = 1                  ; enable tokens 1-31
000000r 2               MIXED_CASE = 1                  ; allow mixed-case keywords
000000r 2               ; APPLE2_128K = 1               ; enable 128K Apple II
000000r 2               
000000r 2               ; Version of Apple ][ Port
000000r 2               VERSION = $01
000000r 2               
000000r 2               .feature labels_without_colons
000000r 2               
000000r 2               ; ProDOS equates
000000r 2               P8_GLOBAL     = $BF00
000000r 2               P8_MLI        = P8_GLOBAL       ; MLI entry point
000000r 2               P8_DEVNUM     = P8_GLOBAL+$30   ; Last used device
000000r 2               P8_MEMTAB     = P8_GLOBAL+$58   ; Memory protection table
000000r 2               P8_DATE       = P8_GLOBAL+$90
000000r 2               P8_TIME       = P8_GLOBAL+$92
000000r 2               P8_FILE_LEVEL = P8_GLOBAL+$94   ; File level, see techref
000000r 2               P8_MACHID     = P8_GLOBAL+$98   ; Machine ID
000000r 2               P8_SLTBYT     = P8_GLOBAL+$99   ; 1 bits indicate slots with firmware
000000r 2               P8_PFIXPTR    = P8_GLOBAL+$9A   ; $00 = no prefix set
000000r 2               P8_IVERSION   = P8_GLOBAL+$FD   ; running interpreter version
000000r 2               P8_KVERSION   = P8_GLOBAL+$FF   ; ProDOS version
000000r 2               
000000r 2               ; Firmware equates
000000r 2               
000000r 2               ; Hi-res Graphics
000000r 2               F0_HGR2       = $F3D8   ; set hgr2 mode and clear hires
000000r 2               F0_HGR        = $F3E2   ; set hgr mode and clear hires
000000r 2               F0_HCLR       = $F3F2   ; clear hires screen
000000r 2               F0_BKGND      = $F3F6   ; clear to color
000000r 2               F0_HPOSN      = $F411   ; I:YX=H,A=V  position hgr cursor
000000r 2               F0_HPLOT0     = $F457   ; I:YX=H,A=V  plot point
000000r 2               F0_HLINRL     = $F530   ; I:AX=dX,Y=dY  plot +/i current position
000000r 2               F0_HGLIN      = $F53A   ; I:AX=X,Y=Y  draw line to
000000r 2               F0_HFIND      = $F5CB   ; Calc X and Y coord from GBASL/H & horizontal and mask
000000r 2               
000000r 2               ; Lo-res Graphics
000000r 2               ; U=undefined, V=a defined value, see docs
000000r 2               F0_GR         = $F390
000000r 2               F0_TEXT       = $F399
000000r 2               F8_PLOT       = $F800   ; O:A=U,XY=XY     I:Y,A = XY coordinates
000000r 2               F8_PLOT1      = $F80E   ; O:A=U,XY=XY     I:Y=X coord, (ZP_GBASL) = row pointer
000000r 2               F8_HLINE      = $F819   ; O:AY=U,X=X      I:Y,A = XY start, ZP_H2 = end col
000000r 2               F8_VLINE      = $F828   ; O:AY=U,X=X      I:Y,A = XY start, ZP_V2 = end row
000000r 2               F8_CLRSCR     = $F832   ; O:AY=U,X=X      clear GR screen
000000r 2               F8_CLRTOP     = $F836   ; O:AY=U,X=X      clr GR screen, mixed mode
000000r 2               F8_GBASCALC   = $F847   ; O:A=V,XY=XY     A=rownum.  calculate (ZP_GBASL)
000000r 2               F8_SCRN       = $F871   ;
000000r 2               
000000r 2               ; text, keyboard, game
000000r 2               F8_PREAD      = $FB1E   ; O:A=U,X=X,Y=V   I:X=0-3
000000r 2               F8_INIT       = $FB2F   ; O:A=V,XY=U
000000r 2               F8_TABV       = $FB5B   ;
000000r 2               F8_ADVANCE    = $FBF4   ;
000000r 2               F8_BELL1      = $FBDD   ; O:A=U,X=X,Y=0
000000r 2               F8_CLREOP     = $FC42
000000r 2               F8_HOME       = $FC58   ; O:AY=U,X=X
000000r 2               F8_LF         = $FC66   ;
000000r 2               F8_SCROLL     = $FC70   ;
000000r 2               F8_CLREOL     = $FC9C   ; O:AY=U,X=X
000000r 2               F8_UP         = $FC1A
000000r 2               F8_WAIT       = $FCA8   ; O:A=$00,XY=XY
000000r 2               F8_KEYIN      = $FD1B   ; O:A=V,X=X,Y=U
000000r 2               F8_COUT1      = $FDF0   ; O:AXY=AXY
000000r 2               F8_MOVE       = $FE2C   ; O:AXY=U
000000r 2               F8_SETINV     = $FE80   ; O:AX=AX,Y=U
000000r 2               F8_SETNORM    = $FE84   ; O:AX=AX,Y=U
000000r 2               F8_SETKBD     = $FE89   ; O:AXY=U
000000r 2               F8_SETVID     = $FE93   ; O:AXY=U
000000r 2               F8_MONITOR    = $FF69   ; doesn't return
000000r 2               
000000r 2               ; Page 0 equates (not EhBASIC)
000000r 2               ; NOTE EhBASIC uses $00-$13, $5B-$DB, $EF-$FF
000000r 2               ; and with interrupt support, $DC-$E1
000000r 2               
000000r 2               ; Text & monitor stuff
000000r 2               ZP_WNDLFT     = $20     ; window left
000000r 2               ZP_WNDWDTH    = $21     ; window width
000000r 2               ZP_WNDTOP     = $22     ; window top
000000r 2               ZP_WNDBTM     = $23     ; window bottom
000000r 2               ZP_CH         = $24     ; cursor horizontal
000000r 2               ZP_CV         = $25     ; cursor vertical
000000r 2               ZP_TXTMASK    = $32     ; $FF = Normal, $7F = Inverse, $3F = Flashing
000000r 2               ZP_PROMPT     = $33
000000r 2               ZP_A1         = $3C     ; monitor addresses
000000r 2               ZP_A2         = $3E
000000r 2               ZP_A4         = $42
000000r 2               ZP_BASL       = $28     ; screen row base address
000000r 2               ZP_BASH       = $29
000000r 2               ZP_CSWL       = $36     ; Monitor display vector
000000r 2               ZP_CSWH       = $37
000000r 2               ZP_KSWL       = $38     ; Monitor keyboard vector
000000r 2               ZP_KSWH       = $39
000000r 2               ZP_RNDL       = $4E     ; updated by KEYIN
000000r 2               ZP_RNDH       = $4F     ; updated by KEYIN
000000r 2               
000000r 2               ; Graphics stuff
000000r 2               ZP_SHAPE1     = $1A     ; shape & fill pointer
000000r 2               ZP_SHAPE1L    = ZP_SHAPE1
000000r 2               ZP_SHAPE1H    = $1B
000000r 2               ZP_HGR_BITS   = $1C     ; hi res color
000000r 2               ZP_GBASL      = $26
000000r 2               ZP_GBASH      = $27
000000r 2               ZP_H2         = $2C     ; Lo-Res HLIN Endpoint
000000r 2               ZP_V2         = $2D     ; Lo-Res VLIN Endpoint
000000r 2               ZP_MASK       = $2E
000000r 2               ZP_COLOR      = $30     ; Lo-res COLOR Value * 17
000000r 2               ZP_HCURSOR_X  = $E0
000000r 2               ZP_HCURSOR_XL = ZP_HCURSOR_X
000000r 2               ZP_HCURSOR_XH = $E1     ; Horizontal Coordinate of HPLOT
000000r 2               ZP_HCURSOR_V  = $E2     ; Vertical Coordinate of HPLOT
000000r 2               ;$E3     - unused
000000r 2               ZP_SCREEN     = $E3     ; it's used now, sucker!
000000r 2               ZP_HCOLOR     = $E4     ; HCOLOR Value (0=0, 1=42, 2=85, 3=127, 4=128, 5=170, 6=213, 7=255)
000000r 2               ZP_HGRPAGE    = $E6     ; $20 or $40
000000r 2               ZP_SCALE      = $E7     ; SCALE Value (0 = 256)
000000r 2               ZP_SHAPEL     = $E8
000000r 2               ZP_SHAPEH     = $E9     ; Address of Shape Table
000000r 2               ZP_DRAWCOL    = $EA     ; DRAW/XDRAW Collision Count
000000r 2               
000000r 2               ; Page 3 equates
000000r 2               SOFTEV        = $3F2
000000r 2               POWERUP       = $3F4
000000r 2               CTRL_Y        = $3F8
000000r 2               
000000r 2               ; Hardware equates
000000r 2               KBD           = $C000   ; R
000000r 2               STORE80OFF    = $C000   ; W
000000r 2               STORE80ON     = $C001   ; W
000000r 2               RDMAINRAM     = $C002   ; W
000000r 2               RDCARDRAM     = $C003   ; W
000000r 2               WRMAINRAM     = $C004   ; W
000000r 2               WRCARDRAM     = $C005   ; W
000000r 2               SETSLOTCXROM  = $C006   ; W
000000r 2               SETINTCXROM   = $C007   ; W
000000r 2               SETSTDZP      = $C008   ; W
000000r 2               SETALTZP      = $C009   ; W
000000r 2               SETINTC3ROM   = $C00A   ; W
000000r 2               SETSLOTC3ROM  = $C00B   ; W
000000r 2               CLR80VID      = $C00C   ; W
000000r 2               SET80VID      = $C00D   ; W
000000r 2               CLRALTCHAR    = $C00E   ; W
000000r 2               SETALTCHAR    = $C00F   ; W
000000r 2               KBD_STROBE    = $C010   ; R or risk losing keystrokes
000000r 2               RDLCBANK2     = $C011
000000r 2               RDLCRAM       = $C012
000000r 2               RDRAMRD       = $C013
000000r 2               RDRAMWRT      = $C014
000000r 2               RDCXROM       = $C015
000000r 2               RDALTZP       = $C016
000000r 2               RDC3ROM       = $C017
000000r 2               RD80STORE     = $C018
000000r 2               RDVBL         = $C019
000000r 2               RDTEXT        = $C01A
000000r 2               RDMIXED       = $C01B
000000r 2               RDPAGE2       = $C01C
000000r 2               RDHIRES       = $C01D
000000r 2               RDALTCHAR     = $C01E
000000r 2               RD80VID       = $C01F
000000r 2               SPKR          = $C030
000000r 2               TXTCLR        = $C050   ; Graphics on
000000r 2               TXTSET        = $C051
000000r 2               MIXCLR        = $C052
000000r 2               MIXSET        = $C053
000000r 2               TXTPAGE1      = $C054
000000r 2               TXTPAGE2      = $C055
000000r 2               LORES         = $C056
000000r 2               HIRES         = $C057
000000r 2               DHIRESON      = $C05E
000000r 2               DHIRESOFF     = $C05F
000000r 2               TAPEIN        = $C060   ; //e
000000r 2               BUTN3         = $C060   ; //c (40/80), IIgs
000000r 2               BUTN0         = $C061
000000r 2               BUTN1         = $C062
000000r 2               BUTN2         = $C063
000000r 2               
000000r 2               ; value equates
000000r 2               MAGIC_A5      = $A5
000000r 2               
000000r 1               .ifdef APPLE2
000000r 1               .pc02
000000r 1               .import __interp_LOAD__, __interp_RUN__, __interp_SIZE__
000000r 1               .import __global_LOAD__, __global_RUN__, __global_SIZE__
000000r 1               .segment "code"
000000r 1               .endif
000000r 1               
000000r 1               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p2
000000r 1               
000000r 1               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 1               
000000r 1               ; 2.00      new revision numbers start here
000000r 1               ; 2.01      fixed LCASE$() and UCASE$()
000000r 1               ; 2.02      new get value routine done
000000r 1               ; 2.03      changed RND() to galoise method
000000r 1               ; 2.04      fixed SPC()
000000r 1               ; 2.05      new get value routine fixed
000000r 1               ; 2.06      changed USR() code
000000r 1               ; 2.07      fixed STR$()
000000r 1               ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
000000r 1               ; 2.09      fixed RND()
000000r 1               ; 2.10      integrated missed changes from an earlier version
000000r 1               ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 1               ; 2.21      fixed IF .. THEN RETURN to not cause error
000000r 1               ; 2.22      fixed RND() breaking the get byte routine
000000r 1               ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
000000r 1               ;              (bugsnquirks.txt notes 2, 4 and 5)
000000r 1               ;              tabs converted to spaces, tabwidth=6
000000r 1               ; 2.22p2    fixed can't continue error on 1st statement after direct mode
000000r 1               ;              changed INPUT to throw "break in line ##" on empty line input
000000r 1               ;
000000r 1               ; MG Apple II Port Changes
000000r 1               ; 0.1.0     Modifications to support ca65/ld65 and segmenting
000000r 1               ;           Conditional assembly for interrupt support, so it can be removed
000000r 1               ;           "PAGE2" data converted to a global page containing I/O vectors
000000r 1               ;           Enhanced I/O supporting "Pascal 1.1" firmware
000000r 1               ;           Beginnings of a _very_ enhanced I/O subsystem
000000r 1               ;           Loader code at standard ProDOS SYS file load address
000000r 1               ;             - Moves interpreter to final destination RAM
000000r 1               ;             - Moves global page to final destination RAM
000000r 1               ;             - Prints sign-on message
000000r 1               ;             - Sets system vectors for RESET and monitor Ctrl-Y
000000r 1               ;           ProDOS support.
000000r 1               ;           Apple II delete key and right-arrow retyping
000000r 1               ;           Requires 65C02 for now.
000000r 1               ;
000000r 1               ; Plans:    128K version that uses Aux RAM
000000r 1               ;             - Aux RAM would have:
000000r 1               ;               * Main interpreter code not requiring OS/Firmware
000000r 1               ;               * Program, Variables
000000r 1               ;             - Main RAM would have:
000000r 1               ;               * Interpreter data tables for tokenizing/detokenizing/errors
000000r 1               ;               * I/O buffers
000000r 1               ;             - Would require separating parts that require OS or firmware
000000r 1               ;               so they could be called from the main bank.  Strategy might be
000000r 1               ;               to ifdef K128 and pushseg/segment/popseg the original code
000000r 1               ;               and a way to get to it from there.
000000r 1               ;             - Basic strategy for 128K version:
000000r 1               ;               * All program and data in Aux mem from $0C00-$BFFF (46080 bytes)
000000r 1               ;               * Main interpreter code in Aux LC from $D000-$FEFF
000000r 1               ;               * Stub interrupt handlers in $FF00 page, switch to standard
000000r 1               ;                 config and call standard handlers.
000000r 1               ;               * Use extra space in main RAM to support text/gr/dbl-lo-res
000000r 1               ;                 page 2 and non-DHGR graphics with no conflicts.  Support DHGR
000000r 1               ;                 graphics with caveats that applied to 64K version.
000000r 1               ;               * Provide faster graphics routines using look-up tables and
000000r 1               ;                 other optimizations.
000000r 1               
000000r 1               
000000r 1               ; zero page use ..
000000r 1               LAB_WARM          = $00       ; BASIC warm start entry point
000000r 1               Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
000000r 1               Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
000000r 1               
000000r 1               Usrjmp            = $0A       ; USR function JMP address
000000r 1               Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
000000r 1               Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
000000r 1               Nullct            = $0D       ; nulls output after each line
000000r 1               TPos              = $0E       ; BASIC terminal position byte
000000r 1               TWidth            = $0F       ; BASIC terminal width byte
000000r 1               Iclim             = $10       ; input column limit
000000r 1               Itempl            = $11       ; temporary integer low byte
000000r 1               Itemph            = Itempl+1  ; temporary integer high byte
000000r 1               
000000r 1               nums_1            = Itempl    ; number to bin/hex string convert MSB
000000r 1               nums_2            = nums_1+1  ; number to bin/hex string convert
000000r 1               nums_3            = nums_1+2  ; number to bin/hex string convert LSB
000000r 1               
000000r 1               Srchc             = $5B       ; search character
000000r 1               Temp3             = Srchc     ; temp byte used in number routines
000000r 1               Scnquo            = $5C       ; scan-between-quotes flag
000000r 1               Asrch             = Scnquo    ; alt search character
000000r 1               
000000r 1               XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
000000r 1               XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
000000r 1               
000000r 1               Ibptr             = $5D       ; input buffer pointer
000000r 1               Dimcnt            = Ibptr     ; # of dimensions
000000r 1               Tindx             = Ibptr     ; token index
000000r 1               
000000r 1               Defdim            = $5E       ; default DIM flag
000000r 1               Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
000000r 1               Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 1               Gclctd            = $60       ; garbage collected flag
000000r 1               Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 1               Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
000000r 1               
000000r 1               Cflag             = $63       ; comparison evaluation flag
000000r 1               
000000r 1               TabSiz            = $64       ; TAB step size (was input flag)
000000r 1               
000000r 1               next_s            = $65       ; next descriptor stack address
000000r 1               
000000r 1                                             ; these two bytes form a word pointer to the item
000000r 1                                             ; currently on top of the descriptor stack
000000r 1               last_sl           = $66       ; last descriptor stack address low byte
000000r 1               last_sh           = $67       ; last descriptor stack address high byte (always $00)
000000r 1               
000000r 1               des_sk            = $68       ; descriptor stack start address (temp strings)
000000r 1               
000000r 1               ;                 = $70       ; End of descriptor stack
000000r 1               
000000r 1               ut1_pl            = $71       ; utility pointer 1 low byte
000000r 1               ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
000000r 1               ut2_pl            = $73       ; utility pointer 2 low byte
000000r 1               ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
000000r 1               
000000r 1               Temp_2            = ut1_pl    ; temp byte for block move
000000r 1               
000000r 1               FACt_1            = $75       ; FAC temp mantissa1
000000r 1               FACt_2            = FACt_1+1  ; FAC temp mantissa2
000000r 1               FACt_3            = FACt_2+1  ; FAC temp mantissa3
000000r 1               
000000r 1               dims_l            = FACt_2    ; array dimension size low byte
000000r 1               dims_h            = FACt_3    ; array dimension size high byte
000000r 1               
000000r 1               TempB             = $78       ; temp page 0 byte
000000r 1               
000000r 1               Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
000000r 1               Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
000000r 1               Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
000000r 1               Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
000000r 1               Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
000000r 1               Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
000000r 1               Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
000000r 1               Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
000000r 1               Sstorl            = $81       ; string storage low byte     (String storage (moving down))
000000r 1               Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
000000r 1               Sutill            = $83       ; string utility ptr low byte
000000r 1               Sutilh            = Sutill+1  ; string utility ptr high byte
000000r 1               Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
000000r 1               Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
000000r 1               Clinel            = $87       ; current line low byte       (Basic line number)
000000r 1               Clineh            = Clinel+1  ; current line high byte      (Basic line number)
000000r 1               Blinel            = $89       ; break line low byte         (Previous Basic line number)
000000r 1               Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
000000r 1               
000000r 1               Cpntrl            = $8B       ; continue pointer low byte
000000r 1               Cpntrh            = Cpntrl+1  ; continue pointer high byte
000000r 1               
000000r 1               Dlinel            = $8D       ; current DATA line low byte
000000r 1               Dlineh            = Dlinel+1  ; current DATA line high byte
000000r 1               
000000r 1               Dptrl             = $8F       ; DATA pointer low byte
000000r 1               Dptrh             = Dptrl+1   ; DATA pointer high byte
000000r 1               
000000r 1               Rdptrl            = $91       ; read pointer low byte
000000r 1               Rdptrh            = Rdptrl+1  ; read pointer high byte
000000r 1               
000000r 1               Varnm1            = $93       ; current var name 1st byte
000000r 1               Varnm2            = Varnm1+1  ; current var name 2nd byte
000000r 1               
000000r 1               Cvaral            = $95       ; current var address low byte
000000r 1               Cvarah            = Cvaral+1  ; current var address high byte
000000r 1               
000000r 1               Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
000000r 1               Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
000000r 1               
000000r 1               Tidx1             = Frnxtl    ; temp line index
000000r 1               
000000r 1               Lvarpl            = Frnxtl    ; let var pointer low byte
000000r 1               Lvarph            = Frnxth    ; let var pointer high byte
000000r 1               
000000r 1               prstk             = $99       ; precedence stacked flag
000000r 1               
000000r 1               comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
000000r 1                                             ; bit 2 set if >
000000r 1                                             ; bit 1 set if =
000000r 1                                             ; bit 0 set if <
000000r 1               
000000r 1               func_l            = $9C       ; function pointer low byte
000000r 1               func_h            = func_l+1  ; function pointer high byte
000000r 1               
000000r 1               garb_l            = func_l    ; garbage collection working pointer low byte
000000r 1               garb_h            = func_h    ; garbage collection working pointer high byte
000000r 1               
000000r 1               des_2l            = $9E       ; string descriptor_2 pointer low byte
000000r 1               des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
000000r 1               
000000r 1               g_step            = $A0       ; garbage collect step size
000000r 1               
000000r 1               Fnxjmp            = $A1       ; jump vector for functions
000000r 1               Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
000000r 1               Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
000000r 1               
000000r 1               g_indx            = Fnxjpl    ; garbage collect temp index
000000r 1               
000000r 1               FAC2_r            = $A3       ; FAC2 rounding byte
000000r 1               
000000r 1               Adatal            = $A4       ; array data pointer low byte
000000r 1               Adatah            = Adatal+1  ; array data pointer high  byte
000000r 1               
000000r 1               Nbendl            = Adatal    ; new block end pointer low byte
000000r 1               Nbendh            = Adatah    ; new block end pointer high  byte
000000r 1               
000000r 1               Obendl            = $A6       ; old block end pointer low byte
000000r 1               Obendh            = Obendl+1  ; old block end pointer high  byte
000000r 1               
000000r 1               numexp            = $A8       ; string to float number exponent count
000000r 1               expcnt            = $A9       ; string to float exponent count
000000r 1               
000000r 1               numbit            = numexp    ; bit count for array element calculations
000000r 1               
000000r 1               numdpf            = $AA       ; string to float decimal point flag
000000r 1               expneg            = $AB       ; string to float eval exponent -ve flag
000000r 1               
000000r 1               Astrtl            = numdpf    ; array start pointer low byte
000000r 1               Astrth            = expneg    ; array start pointer high  byte
000000r 1               
000000r 1               Histrl            = numdpf    ; highest string low byte
000000r 1               Histrh            = expneg    ; highest string high  byte
000000r 1               
000000r 1               Baslnl            = numdpf    ; BASIC search line pointer low byte
000000r 1               Baslnh            = expneg    ; BASIC search line pointer high  byte
000000r 1               
000000r 1               Fvar_l            = numdpf    ; find/found variable pointer low byte
000000r 1               Fvar_h            = expneg    ; find/found variable pointer high  byte
000000r 1               
000000r 1               Ostrtl            = numdpf    ; old block start pointer low byte
000000r 1               Ostrth            = expneg    ; old block start pointer high  byte
000000r 1               
000000r 1               Vrschl            = numdpf    ; variable search pointer low byte
000000r 1               Vrschh            = expneg    ; variable search pointer high  byte
000000r 1               
000000r 1               FAC1_e            = $AC       ; FAC1 exponent
000000r 1               FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
000000r 1               FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
000000r 1               FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
000000r 1               FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
000000r 1               
000000r 1               str_ln            = FAC1_e    ; string length
000000r 1               str_pl            = FAC1_1    ; string pointer low byte
000000r 1               str_ph            = FAC1_2    ; string pointer high byte
000000r 1               
000000r 1               des_pl            = FAC1_2    ; string descriptor pointer low byte
000000r 1               des_ph            = FAC1_3    ; string descriptor pointer high byte
000000r 1               
000000r 1               mids_l            = FAC1_3    ; MID$ string temp length byte
000000r 1               
000000r 1               negnum            = $B1       ; string to float eval -ve flag
000000r 1               numcon            = $B1       ; series evaluation constant count
000000r 1               
000000r 1               FAC1_o            = $B2       ; FAC1 overflow byte
000000r 1               
000000r 1               FAC2_e            = $B3       ; FAC2 exponent
000000r 1               FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
000000r 1               FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
000000r 1               FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
000000r 1               FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
000000r 1               .ifdef APPLE2
000000r 1               OSptr             = FAC2_1    ; temp pointer for OS routines
000000r 1               OSptr2            = FAC2_3    ; temp pointer for OS routines
000000r 1               MoveDir           = FAC2_e    ; movement direction. negative = down
000000r 1               .endif
000000r 1               
000000r 1               FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
000000r 1               FAC1_r            = $B9       ; FAC1 rounding byte
000000r 1               
000000r 1               ssptr_l           = FAC_sc    ; string start pointer low byte
000000r 1               ssptr_h           = FAC1_r    ; string start pointer high byte
000000r 1               
000000r 1               sdescr            = FAC_sc    ; string descriptor pointer
000000r 1               
000000r 1               csidx             = $BA       ; line crunch save index
000000r 1               Asptl             = csidx     ; array size/pointer low byte
000000r 1               Aspth             = $BB       ; array size/pointer high byte
000000r 1               
000000r 1               Btmpl             = Asptl     ; BASIC pointer temp low byte
000000r 1               Btmph             = Aspth     ; BASIC pointer temp low byte
000000r 1               
000000r 1               Cptrl             = Asptl     ; BASIC pointer temp low byte
000000r 1               Cptrh             = Aspth     ; BASIC pointer temp low byte
000000r 1               
000000r 1               Sendl             = Asptl     ; BASIC pointer temp low byte
000000r 1               Sendh             = Aspth     ; BASIC pointer temp low byte
000000r 1               
000000r 1               LAB_IGBY          = $BC       ; get next BASIC byte subroutine
000000r 1               
000000r 1               LAB_GBYT          = $C2       ; get current BASIC byte subroutine
000000r 1               Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
000000r 1               Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
000000r 1               
000000r 1               ;                 = $D7       ; end of get BASIC char subroutine
000000r 1               
000000r 1               Rbyte4            = $D8       ; extra PRNG byte
000000r 1               Rbyte1            = Rbyte4+1  ; most significant PRNG byte
000000r 1               Rbyte2            = Rbyte4+2  ; middle PRNG byte
000000r 1               Rbyte3            = Rbyte4+3  ; least significant PRNG byte
000000r 1               
000000r 1               .ifndef NO_INT
000000r 1               NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
000000r 1                                             ; bit function
000000r 1                                             ; === ========
000000r 1                                             ; 7   interrupt enabled
000000r 1                                             ; 6   interrupt setup
000000r 1                                             ; 5   interrupt happened
000000r 1               ;                 = $DD       ; NMI handler addr low byte
000000r 1               ;                 = $DE       ; NMI handler addr high byte
000000r 1               IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
000000r 1               ;                 = $E0       ; IRQ handler addr low byte
000000r 1               ;                 = $E1       ; IRQ handler addr high byte
000000r 1               .endif
000000r 1               
000000r 1               ;                 = $DE       ; unused
000000r 1               ;                 = $DF       ; unused
000000r 1               ;                 = $E0       ; unused
000000r 1               ;                 = $E1       ; unused
000000r 1               ;                 = $E2       ; unused
000000r 1               ;                 = $E3       ; unused
000000r 1               ;                 = $E4       ; unused
000000r 1               ;                 = $E5       ; unused
000000r 1               ;                 = $E6       ; unused
000000r 1               ;                 = $E7       ; unused
000000r 1               ;                 = $E8       ; unused
000000r 1               ;                 = $E9       ; unused
000000r 1               ;                 = $EA       ; unused
000000r 1               ;                 = $EB       ; unused
000000r 1               ;                 = $EC       ; unused
000000r 1               ;                 = $ED       ; unused
000000r 1               ;                 = $EE       ; unused
000000r 1               
000000r 1               Decss             = $EF       ; number to decimal string start
000000r 1               Decssp1           = Decss+1   ; number to decimal string start
000000r 1               
000000r 1               ;                 = $FF       ; decimal string end
000000r 1               
000000r 1               ; token values needed for BASIC
000000r 1               
000000r 1               ; Potential here...
000000r 1               
000000r 1               .ifdef LOW_TOKENS
000000r 1               ; low primary command tokens (can start a statement)
000000r 1               TK_RES00          = $00             ; reserved - DO NOT USE
000000r 1               
000000r 1               .ifdef APPLE2
000000r 1               TK_SCREEN         = TK_RES00+1      ; SCREEN token
000000r 1               TK_CLS            = TK_SCREEN+1     ; CLS token
000000r 1               TK_TEXT           = TK_CLS+1        ; TEXT
000000r 1               TK_GR             = TK_TEXT+1       ; GR
000000r 1               TK_HGR            = TK_GR  +1       ; HGR & HGR 2
000000r 1               TK_COLOR          = TK_HGR+1        ; COLOR=
000000r 1               TK_PLOT           = TK_COLOR+1      ; PLOT
000000r 1               TK_HLIN           = TK_PLOT+1       ; HLIN
000000r 1               TK_VLIN           = TK_HLIN+1       ; VLIN
000000r 1               TK_HCOLOR         = TK_VLIN+1       ; HCOLOR=
000000r 1               TK_HPLOT          = TK_HCOLOR+1     ; HPLOT
000000r 1               TK_BEEP           = TK_HPLOT+1      ; BEEP
000000r 1               TK_ONLINE         = TK_BEEP+1       ; ONLINE
000000r 1               TK_RENAME         = TK_ONLINE+1     ; RENAME
000000r 1               TK_P8CALL         = TK_RENAME+1     ; P8CALL
000000r 1               TK_MTEXT          = TK_P8CALL+1     ; MTEXT
000000r 1               TK_TRY            = TK_MTEXT+1      ; TRY
000000r 1               TK_ERROR          = TK_TRY+1        ; ERROR
000000r 1               TK_POP            = TK_ERROR+1      ; POP
000000r 1               TK_CHTYPE         = TK_POP+1        ; CHTYPE
000000r 1               TK_LOCK           = TK_CHTYPE+1     ; LOCK
000000r 1               TK_UNLOCK         = TK_LOCK+1       ; UNLOCK
000000r 1               TK_SYS            = TK_UNLOCK+1     ; SYS (call with register load/save)
000000r 1               .endif
000000r 1               
000000r 1               .out .sprintf("Low tokens enabled, highest #: %x",TK_SYS)
000000r 1               .endif
000000r 1               
000000r 1               ; primary command tokens (can start a statement)
000000r 1               
000000r 1               TK_END            = $80             ; END token
000000r 1               TK_FOR            = TK_END+1        ; FOR token
000000r 1               TK_NEXT           = TK_FOR+1        ; NEXT token
000000r 1               TK_DATA           = TK_NEXT+1       ; DATA token
000000r 1               TK_INPUT          = TK_DATA+1       ; INPUT token
000000r 1               TK_DIM            = TK_INPUT+1      ; DIM token
000000r 1               TK_READ           = TK_DIM+1        ; READ token
000000r 1               TK_LET            = TK_READ+1       ; LET token
000000r 1               TK_DEC            = TK_LET+1        ; DEC token
000000r 1               TK_GOTO           = TK_DEC+1        ; GOTO token
000000r 1               TK_RUN            = TK_GOTO+1       ; RUN token
000000r 1               TK_IF             = TK_RUN+1        ; IF token
000000r 1               TK_RESTORE        = TK_IF+1         ; RESTORE token
000000r 1               TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
000000r 1               .ifndef NO_INT
000000r 1               TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
000000r 1               TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
000000r 1               .else
000000r 1               TK_RETNMI = TK_GOSUB ; fixup
000000r 1               .endif
000000r 1               TK_RETURN         = TK_RETNMI+1     ; RETURN token
000000r 1               TK_REM            = TK_RETURN+1     ; REM token
000000r 1               TK_STOP           = TK_REM+1        ; STOP token
000000r 1               TK_ON             = TK_STOP+1       ; ON token
000000r 1               TK_NULL           = TK_ON+1         ; NULL token
000000r 1               TK_INC            = TK_NULL+1       ; INC token
000000r 1               TK_WAIT           = TK_INC+1        ; WAIT token
000000r 1               TK_LOAD           = TK_WAIT+1       ; LOAD token
000000r 1               TK_SAVE           = TK_LOAD+1       ; SAVE token
000000r 1               TK_DEF            = TK_SAVE+1       ; DEF token
000000r 1               TK_POKE           = TK_DEF+1        ; POKE token
000000r 1               TK_DOKE           = TK_POKE+1       ; DOKE token
000000r 1               TK_CALL           = TK_DOKE+1       ; CALL token
000000r 1               TK_DO             = TK_CALL+1       ; DO token
000000r 1               TK_LOOP           = TK_DO+1         ; LOOP token
000000r 1               TK_PRINT          = TK_LOOP+1       ; PRINT token
000000r 1               TK_CONT           = TK_PRINT+1      ; CONT token
000000r 1               TK_LIST           = TK_CONT+1       ; LIST token
000000r 1               TK_CLEAR          = TK_LIST+1       ; CLEAR token
000000r 1               TK_NEW            = TK_CLEAR+1      ; NEW token
000000r 1               TK_WIDTH          = TK_NEW+1        ; WIDTH token
000000r 1               TK_GET            = TK_WIDTH+1      ; GET token
000000r 1               TK_SWAP           = TK_GET+1        ; SWAP token
000000r 1               TK_BITSET         = TK_SWAP+1       ; BITSET token
000000r 1               TK_BITCLR         = TK_BITSET+1     ; BITCLR token
000000r 1               .ifndef NO_INT
000000r 1               TK_IRQ            = TK_BITCLR+1     ; IRQ token
000000r 1               TK_NMI            = TK_IRQ+1        ; NMI token
000000r 1               .else
000000r 1               TK_NMI = TK_BITCLR ; fixup
000000r 1               .endif
000000r 1               .ifdef APPLE2
000000r 1               TK_HOME           = TK_NMI+1        ; HOME token
000000r 1               TK_BYE            = TK_HOME+1       ; BYE token
000000r 1               TK_INVERSE        = TK_BYE+1        ; INVERSE token
000000r 1               TK_NORMAL         = TK_INVERSE+1    ; NORMAL token
000000r 1               TK_PR             = TK_NORMAL+1     ; PR# token
000000r 1               TK_IN             = TK_PR+1         ; IN# token
000000r 1               TK_PREFIX         = TK_IN+1         ; PREFIX token
000000r 1               TK_CAT            = TK_PREFIX+1     ; CAT token
000000r 1               TK_OPEN           = TK_CAT+1        ; OPEN token
000000r 1               TK_CLOSE          = TK_OPEN+1       ; CLOSE token
000000r 1               TK_WRITE          = TK_CLOSE+1      ; WRITE token
000000r 1               TK_SEEK           = TK_WRITE+1      ; SEEK token
000000r 1               TK_CREATE         = TK_SEEK+1       ; CREATE token
000000r 1               TK_DELETE         = TK_CREATE+1      ; DELETE token
000000r 1               TK_FLUSH          = TK_DELETE+1     ; FLUSH token
000000r 1               
000000r 1               ; secondary command tokens, can't start a statement
000000r 1               
000000r 1               TK_TAB            = TK_FLUSH+1      ; TAB token
000000r 1               .else
000000r 1               ; secondary command tokens, can't start a statement
000000r 1               
000000r 1               TK_TAB            = TK_NMI+1        ; TAB token
000000r 1               .endif
000000r 1               TK_ELSE           = TK_TAB+1        ; ELSE token
000000r 1               TK_TO             = TK_ELSE+1       ; TO token
000000r 1               TK_FN             = TK_TO+1         ; FN token
000000r 1               TK_SPC            = TK_FN+1         ; SPC token
000000r 1               TK_THEN           = TK_SPC+1        ; THEN token
000000r 1               TK_NOT            = TK_THEN+1       ; NOT token
000000r 1               TK_STEP           = TK_NOT+1        ; STEP token
000000r 1               TK_UNTIL          = TK_STEP+1       ; UNTIL token
000000r 1               TK_WHILE          = TK_UNTIL+1      ; WHILE token
000000r 1               TK_OFF            = TK_WHILE+1      ; OFF token
000000r 1               .ifdef APPLE2
000000r 1               TK_AT             = TK_OFF+1        ; AT token
000000r 1               ; operator tokens
000000r 1               
000000r 1               TK_PLUS           = TK_AT+1         ; + token
000000r 1               .else
000000r 1               
000000r 1               ; opperator tokens
000000r 1               
000000r 1               TK_PLUS           = TK_OFF+1        ; + token
000000r 1               .endif
000000r 1               TK_MINUS          = TK_PLUS+1       ; - token
000000r 1               TK_MUL            = TK_MINUS+1      ; * token
000000r 1               TK_DIV            = TK_MUL+1        ; / token
000000r 1               TK_POWER          = TK_DIV+1        ; ^ token
000000r 1               TK_AND            = TK_POWER+1      ; AND token
000000r 1               TK_EOR            = TK_AND+1        ; EOR token
000000r 1               TK_OR             = TK_EOR+1        ; OR token
000000r 1               TK_RSHIFT         = TK_OR+1         ; RSHIFT token
000000r 1               TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
000000r 1               TK_GT             = TK_LSHIFT+1     ; > token
000000r 1               TK_EQUAL          = TK_GT+1         ; = token
000000r 1               TK_LT             = TK_EQUAL+1      ; < token
000000r 1               
000000r 1               ; functions tokens
000000r 1               
000000r 1               TK_SGN            = TK_LT+1         ; SGN token
000000r 1               TK_INT            = TK_SGN+1        ; INT token
000000r 1               TK_ABS            = TK_INT+1        ; ABS token
000000r 1               TK_USR            = TK_ABS+1        ; USR token
000000r 1               TK_FRE            = TK_USR+1        ; FRE token
000000r 1               TK_POS            = TK_FRE+1        ; POS token
000000r 1               TK_SQR            = TK_POS+1        ; SQR token
000000r 1               TK_RND            = TK_SQR+1        ; RND token
000000r 1               TK_LOG            = TK_RND+1        ; LOG token
000000r 1               TK_EXP            = TK_LOG+1        ; EXP token
000000r 1               TK_COS            = TK_EXP+1        ; COS token
000000r 1               TK_SIN            = TK_COS+1        ; SIN token
000000r 1               TK_TAN            = TK_SIN+1        ; TAN token
000000r 1               TK_ATN            = TK_TAN+1        ; ATN token
000000r 1               TK_PEEK           = TK_ATN+1        ; PEEK token
000000r 1               TK_DEEK           = TK_PEEK+1       ; DEEK token
000000r 1               TK_SADD           = TK_DEEK+1       ; SADD token
000000r 1               TK_LEN            = TK_SADD+1       ; LEN token
000000r 1               TK_STRS           = TK_LEN+1        ; STR$ token
000000r 1               TK_VAL            = TK_STRS+1       ; VAL token
000000r 1               TK_ASC            = TK_VAL+1        ; ASC token
000000r 1               TK_UCASES         = TK_ASC+1        ; UCASE$ token
000000r 1               TK_LCASES         = TK_UCASES+1     ; LCASE$ token
000000r 1               TK_CHRS           = TK_LCASES+1     ; CHR$ token
000000r 1               TK_HEXS           = TK_CHRS+1       ; HEX$ token
000000r 1               TK_BINS           = TK_HEXS+1       ; BIN$ token
000000r 1               TK_BITTST         = TK_BINS+1       ; BITTST token
000000r 1               TK_MAX            = TK_BITTST+1     ; MAX token
000000r 1               TK_MIN            = TK_MAX+1        ; MIN token
000000r 1               TK_PI             = TK_MIN+1        ; PI token
000000r 1               TK_TWOPI          = TK_PI+1         ; TWOPI token
000000r 1               TK_VPTR           = TK_TWOPI+1      ; VARPTR token
000000r 1               TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
000000r 1               TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
000000r 1               TK_MIDS           = TK_RIGHTS+1     ; MID$ token
000000r 1               .ifdef APPLE2
000000r 1               TK_USINGS         = TK_MIDS+1       ; USING$ token
000000r 1               TK_GLOBAL         = TK_USINGS+1     ; GLOBAL token
000000r 1               TK_PDL            = TK_GLOBAL+1     ; PDL token
000000r 1               TK_BTN            = TK_PDL+1        ; BTN token
000000r 1               TK_TELL           = TK_BTN+1        ; TELL token
000000r 1               TK_SCRN           = TK_TELL+1       ; SCRN token
000000r 1               TK_ERRNO          = TK_SCRN+1       ; ERRNO token
000000r 1               TK_P2BS           = TK_ERRNO+1      ; P2B$( token Pascal Str to BASIC str
000000r 1               TK_B2PS           = TK_P2BS+1       ; B2P$( token Basic Str to Pascal str
000000r 1               ; TK_PREFIXS      = TK_B2PS+1       ; PREFIX$ token, cf. TK_PREFIX
000000r 1               ; TK_READF        = TK_PREFIXS+1    ; READ( token, cf. TK_READ
000000r 1               TK_HSCRN          = TK_B2PS+1       ; HSCRN token
000000r 1               TK_EXT            = $FF             ; extended tokens
000000r 1               
000000r 1               .out .sprintf("Highest token #: %x",TK_HSCRN) ; better be $FE or less
000000r 1               .endif
000000r 1               
000000r 1               ; offsets from a base of X or Y
000000r 1               
000000r 1               PLUS_0            = $00       ; X or Y plus 0
000000r 1               PLUS_1            = $01       ; X or Y plus 1
000000r 1               PLUS_2            = $02       ; X or Y plus 2
000000r 1               PLUS_3            = $03       ; X or Y plus 3
000000r 1               
000000r 1               LAB_STAK          = $0100     ; stack bottom, no offset
000000r 1               
000000r 1               LAB_SKFE          = LAB_STAK+$FE
000000r 1                                             ; flushed stack address
000000r 1               LAB_SKFF          = LAB_STAK+$FF
000000r 1                                             ; flushed stack address
000000r 1               .ifdef APPLE2
000000r 1               .pushseg
000000r 1               .segment "global"
000000r 1               GLOBAL_PAGE = *
000000r 1  01           INTERP_VER        .byte $01   ; VERSION
000001r 1  00           SYS_A             .byte $00   ; A register for SYS command
000002r 1  00           SYS_X             .byte $00   ; X register for SYS command
000003r 1  00           SYS_Y             .byte $00   ; Y register for SYS command
000004r 1  00           SYS_P             .byte $00   ; P register for sys command
000005r 1  00           SYS_BANK          .byte $00   ; 0 = main bank, 1 = aux bank
000006r 1               ; these will be initialized at cold start of interp, starting at ccflag
000006r 1               ; so make sure these are in order
000006r 1  00           ccflag            .byte $00   ; see below
000007r 1  00           ccbyte            .byte $00   ; see below
000008r 1  00           ccnull            .byte $00   ; see below
000009r 1  00 00        VEC_CC            .word $0000 ; see below
00000Br 1               ; other values follow, may be pre-initialized or initialized by loader
00000Br 1  00 08        RAM_BASE          .word $0800
00000Dr 1               ram_top_v =       __interp_RUN__-$500   ; reserve $500 bytes for our own use
00000Dr 1  rr rr        RAM_TOP           .word ram_top_v  ; initial RAM TOP
00000Fr 1  rr rr        RES_BUF           .word ram_top_v  ; reserved buffer for load, save, catalog, etc
000011r 1  rr rr        INPUT_BUF         .word ram_top_v+$400  ; used for I/O redir, keyboard buffer`
000013r 1  00           INPUT_HEAD        .byte $00   ; head of INPUT_BUF, $00-$7F
000014r 1  00           INPUT_TAIL        .byte $00   ; tail of INPUT_BUF, $00-$7F. TAIL==HEAD=Empty
000015r 1  rr rr        ASM_BUF           .word ram_top_v+$480  ; used for catalog, etc. to assemble data
000017r 1  00           AUTO_RUN          .byte $00   ; auto-run flag, set by run "file"
000018r 1  0A 00        NEXT_LINE         .word 10    ; last non-empty line number entered, default to 10
00001Ar 1  00 00        SYS_VEC           .word $0000 ; address of SYS called routine
00001Cr 1  4C rr rr     WS_VEC            jmp LDR_CALLBACK ; called every warm start
00001Fr 1  4C 31 85     ERR_VEC           jmp LAB_ARTS  ; called on error before most things
000022r 1               ; Error codes & handling
000022r 1  00 00        ERRNO_LINE        .word $0000 ; line of last BASIC error
000024r 1  00           ERRNO_BASIC       .byte $00   ; last BASIC error code
000025r 1  00           ERRNO_PASCAL_IO   .byte $00   ; last PASCAL I/O error code
000026r 1  00           ERRNO_PRODOS      .byte $00   ; last PRODOS error code
000027r 1  00           TRY_STATUS        .byte $00   ; status of TRY, high bit set = active
000028r 1  00           TRY_SP            .byte $00   ; stack pointer of active TRY (or try-like thing)
000029r 1               ; Active Pascal I/O vectors
000029r 1  50 B0        IO_PINIT          .addr A2_STDIO_PINIT    ; only used when initing
00002Br 1  70 B0        IO_IN_PREAD       .addr A2_STDIO_PREAD
00002Dr 1  3C B1        IO_IN_PSTATUS     .addr A2_STDIO_PSTATUS
00002Fr 1  79 B0        IO_OUT_PWRITE     .addr A2_STDIO_PWRITE
000031r 1  3C B1        IO_OUT_PSTATUS    .addr A2_STDIO_PSTATUS
000033r 1  4C 43 AF     IO_A2_INPT        jmp   V_INPT_MON        ; we set firmware KSW vector to this
000036r 1  4C 7F AF     IO_A2_OUTP        jmp   V_OUTP_MON        ; we set firmware CSW vector to this
000039r 1               ; Active default I/O info
000039r 1  00           IO_SLOT_IN        .byte $0    ; slot * $10, high bit set=file
00003Ar 1  00           IO_SLOT_OUT       .byte $0    ; slot * $10, high bit set=file
00003Br 1  00           IO_TEXT_SLOT      .byte $0    ; last text slot number
00003Cr 1               ; table of pascal slot types
00003Cr 1               SLOT_TYPES
00003Cr 1  84                             .byte $84   ; slot 0 special
00003Dr 1  00                             .byte $00
00003Er 1  00                             .byte $00
00003Fr 1  00                             .byte $00
000040r 1  00                             .byte $00
000041r 1  00                             .byte $00
000042r 1  00                             .byte $00
000043r 1  00                             .byte $00
000044r 1               ; bit 7 = inited already
000044r 1               SLOT_STATUS
000044r 1  00                             .byte $00
000045r 1  00                             .byte $00
000046r 1  00                             .byte $00
000047r 1  00                             .byte $00
000048r 1  00                             .byte $00
000049r 1  00                             .byte $00
00004Ar 1  00                             .byte $00
00004Br 1  00                             .byte $00
00004Cr 1               ; table of slot I/O addresses
00004Cr 1               SLOT_TAB
00004Cr 1  50 B0        SL0_PINIT         .addr A2_STDIO_PINIT
00004Er 1  70 B0        SL0_PREAD         .addr A2_STDIO_PREAD
000050r 1  79 B0        SL0_PWRITE        .addr A2_STDIO_PWRITE
000052r 1  3C B1        SL0_PSTATUS       .addr A2_STDIO_PSTATUS
000054r 1  00 00        SL1_PINIT         .addr 0
000056r 1  00 00        SL1_PREAD         .addr 0
000058r 1  00 00        SL1_PWRITE        .addr 0
00005Ar 1  00 00        SL1_PSTATUS       .addr 0
00005Cr 1  00 00        SL2_PINIT         .addr 0
00005Er 1  00 00        SL2_PREAD         .addr 0
000060r 1  00 00        SL2_PWRITE        .addr 0
000062r 1  00 00        SL2_PSTATUS       .addr 0
000064r 1  00 00        SL3_PINIT         .addr 0
000066r 1  00 00        SL3_PREAD         .addr 0
000068r 1  00 00        SL3_PWRITE        .addr 0
00006Ar 1  00 00        SL3_PSTATUS       .addr 0
00006Cr 1  00 00        SL4_PINIT         .addr 0
00006Er 1  00 00        SL4_PREAD         .addr 0
000070r 1  00 00        SL4_PWRITE        .addr 0
000072r 1  00 00        SL4_PSTATUS       .addr 0
000074r 1  00 00        SL5_PINIT         .addr 0
000076r 1  00 00        SL5_PREAD         .addr 0
000078r 1  00 00        SL5_PWRITE        .addr 0
00007Ar 1  00 00        SL5_PSTATUS       .addr 0
00007Cr 1  00 00        SL6_PINIT         .addr 0
00007Er 1  00 00        SL6_PREAD         .addr 0
000080r 1  00 00        SL6_PWRITE        .addr 0
000082r 1  00 00        SL6_PSTATUS       .addr 0
000084r 1  00 00        SL7_PINIT         .addr 0
000086r 1  00 00        SL7_PREAD         .addr 0
000088r 1  00 00        SL7_PWRITE        .addr 0
00008Ar 1  00 00        SL7_PSTATUS       .addr 0
00008Cr 1               ; System buffer mgt, buffer 1 is always at RAM_TOP-$400, 1 at RAM_TOP-$800, ...
00008Cr 1               ; Values: for Buff1+ 1st: neg = Deallocated but $FF=Free, $01-$7F=user ref
00008Cr 1               ;                    2nd: page # of buffer start, $00 if dealloc
00008Cr 1               ; $80 = owned by GETBUF() function
00008Cr 1  00 00        BUFFS             .byte $00,0   ; # of buffers in use, unused
00008Er 1  80 00                          .byte $80,0   ; Buff1
000090r 1  80 00                          .byte $80,0
000092r 1  80 00                          .byte $80,0
000094r 1  80 00                          .byte $80,0
000096r 1  80 00                          .byte $80,0
000098r 1  80 00                          .byte $80,0
00009Ar 1  80 00                          .byte $80,0
00009Cr 1  80 00                          .byte $80,0   ; Buff 8
00009Er 1               ; File mapping table, currently allows 8 BASIC files to be in use.
00009Er 1               ; entry bytes 0: basic file #, 0=unused slot, high bit=slot opened as file
00009Er 1               ;             1: ProDOS file ref # or Slot #
00009Er 1               ;             2: buffer #s      ; low nibble = 1st buf, high nib = 2nd buf (dirs)
00009Er 1               ;             3: ProDOS file type opened, 0 = don't care
00009Er 1  00 00 00 00  FILES             .byte 0,0,0,0
0000A2r 1  00 00 00 00                    .byte 0,0,0,0
0000A6r 1  00 00 00 00                    .byte 0,0,0,0
0000AAr 1  00 00 00 00                    .byte 0,0,0,0
0000AEr 1  00 00 00 00                    .byte 0,0,0,0
0000B2r 1  00 00 00 00                    .byte 0,0,0,0
0000B6r 1  00 00 00 00                    .byte 0,0,0,0
0000BAr 1  00 00 00 00                    .byte 0,0,0,0
0000BEr 1               
0000BEr 1               ;
0000BEr 1  00           START_DEV         .byte 0       ; start device
0000BFr 1  00           START_FILE        .byte 0       ; nonzero if startup file present
0000C0r 1  DF           P8_LCMASK         .byte $DF     ; loader changes to $FF if P8 supports lower case
0000C1r 1               
0000C1r 1               .out .sprintf("Last global: %x",*-GLOBAL_PAGE)
0000C1r 1  xx xx xx xx  .align 256
0000C5r 1  xx xx xx xx  
0000C9r 1  xx xx xx xx  
000100r 1               .popseg
000000r 1               .else
000000r 1               ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 1               ccbyte            = ccflag+1  ; BASIC CTRL-C byte
000000r 1               ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
000000r 1               VEC_CC            = ccnull+1  ; ctrl c check vector
000000r 1               VEC_IN            = VEC_CC+2  ; input vector
000000r 1               VEC_OUT           = VEC_IN+2  ; output vector
000000r 1               VEC_LD            = VEC_OUT+2 ; load vector
000000r 1               VEC_SV            = VEC_LD+2  ; save vector
000000r 1               .endif
000000r 1               
000000r 1               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
000000r 1               ; the input buffer must not cross a page boundary and must not overlap with
000000r 1               ; program RAM pages!
000000r 1               
000000r 1               .ifdef APPLE2
000000r 1               Ibuffs            = $200
000000r 1               Ibuffe            = $27F
000000r 1               PathBuf           = $280
000000r 1               .else
000000r 1               ;Ibuffs            = IRQ_vec+$14
000000r 1               Ibuffs            = VEC_SV+$16
000000r 1                                             ; start of input buffer after IRQ/NMI code
000000r 1               Ibuffe            = Ibuffs+$47; end of input buffer
000000r 1               .endif
000000r 1               
000000r 1               .ifdef APPLE2
000000r 1               ;Ram_base          = $0800     ; start of user RAM (set as needed, should be page aligned)
000000r 1               ; Ram_top           = $2000     ; end of user RAM+1 (set as needed, should be page aligned)
000000r 1               .else
000000r 1               Ram_base          = $0300     ; start of user RAM (set as needed, should be page aligned)
000000r 1               Ram_top           = $C000     ; end of user RAM+1 (set as needed, should be page aligned)
000000r 1               .endif
000000r 1               
000000r 1               ; This start can be changed to suit your system
000000r 1               
000000r 1               .ifdef APPLE2
000000r 1               .pushseg
000000r 1               .segment "loader"
000000r 1               ; loader starts here
000000r 1  4C rr rr           jmp LDR_START
000003r 1  EE EE              .byte $EE,$EE           ; signature of startup file buffer
000005r 1  41                 .byte $41               ; buffer size
000006r 1               LDR_STARTUP_FILE
000006r 1  09 45 48 53        .byte 9,"EHSTARTUP"     ; default pathname
00000Ar 1  54 41 52 54  
00000Er 1  55 50        
000010r 1  00 00 00 00        .res $41-10,0           ; remaining buffer
000014r 1  00 00 00 00  
000018r 1  00 00 00 00  
000047r 1               
000047r 1               ; Quit the loader, used when we can't run due to insufficient hardware
000047r 1               LDR_QUIT:
000047r 1  20 00 BF           JSR   P8_MLI
00004Ar 1  65                 .byte $65               ; QUIT code
00004Br 1  rr rr              .addr :+
00004Dr 1  00                 BRK                     ; should *never* happen.
00004Er 1  04           :     .byte 4
00004Fr 1  00                 .byte 0
000050r 1  00 00              .addr 0
000052r 1  00                 .byte 0
000053r 1  00 00              .addr 0
000055r 1               
000055r 1               LDR_START
000055r 1                     ; check for 65C02
000055r 1  F8                 sed
000056r 1  A9 99              lda   #$99
000058r 1  18                 clc
000059r 1  69 01              adc   #$01
00005Br 1  D8                 cld
00005Cr 1  30 E9              bmi   LDR_QUIT          ; not a 65C02/802/816
00005Er 1               .ifdef APPLE2_128K
00005Er 1                     ; check for 128K
00005Er 1                     lda   #%00010000
00005Er 1                     bit   P8_MACHID
00005Er 1                     beq   LDR_QUIT
00005Er 1               .endif
00005Er 1                     ; check for 64K (also needed if 128K)
00005Er 1  A9 20              lda   #%00100000
000060r 1  2C 98 BF           bit   P8_MACHID
000063r 1  F0 E2              beq   LDR_QUIT
000065r 1               
000065r 1                     ; init reset vector to monitor
000065r 1                     ; later we will change it to warm start
000065r 1  A9 69              lda   #<F8_MONITOR
000067r 1  8D F2 03           sta   SOFTEV            ; RESET vector
00006Ar 1  A9 FF              lda   #>F8_MONITOR
00006Cr 1  8D F3 03           sta   SOFTEV+1
00006Fr 1  49 A5              eor   #MAGIC_A5
000071r 1  8D F4 03           sta   POWERUP
000074r 1  20 rr rr           jsr   LDR_MOVE_BASIC
000077r 1  20 rr rr           jsr   LDR_MOVE_GLOBALS
00007Ar 1  20 rr rr           jsr   LDR_IO_SETUP
00007Dr 1  AD FF BF           lda   P8_KVERSION
000080r 1  C9 25              cmp   #$25              ; supports lower case?
000082r 1  90 05              bcc   :+                ; leave default if not
000084r 1  A9 FF              lda   #$FF              ; don't mask any bits
000086r 1  8D rr rr           sta   P8_LCMASK
000089r 1               :
000089r 1               ; set up ProDOS global page memory map
000089r 1  A2 17              ldx   #$17
00008Br 1  BD rr rr     :     lda   LDR_MEMTAB,x
00008Er 1  9D 58 BF           sta   P8_MEMTAB,x
000091r 1  CA                 dex
000092r 1  10 F7              bpl   :-
000094r 1               ; Prefixing and startup
000094r 1  A9 00              lda   #<Ibuffs
000096r 1  8D rr rr           sta   LDR_PARM_PREFIX+1
000099r 1  A9 02              lda   #>Ibuffs
00009Br 1  8D rr rr           sta   LDR_PARM_PREFIX+2
00009Er 1  20 00 BF           jsr   P8_MLI
0000A1r 1  C7                 .byte $C7               ; GET_PREFIX
0000A2r 1  rr rr              .addr LDR_PARM_PREFIX
0000A4r 1  B0 0C              bcs   :+
0000A6r 1  AD 00 02           lda   Ibuffs
0000A9r 1  C9 02              cmp   #$02
0000ABr 1  B0 61              bcs   LDR_STARTUP       ; Prefix is already set, move on
0000ADr 1               ; Try to set prefix to our given path in $280
0000ADr 1  AE 80 02           ldx   PathBuf
0000B0r 1  F0 21              beq   LDR_TRY_DEV
0000B2r 1  BD 80 02     :     lda   PathBuf,x
0000B5r 1  C9 2F              cmp   #'/'
0000B7r 1  F0 05              beq   LDR_PFX_PATH
0000B9r 1  CA                 dex
0000BAr 1  D0 F6              bne   :-
0000BCr 1  F0 15              beq   LDR_TRY_DEV       ; no path ending in / found
0000BEr 1               LDR_PFX_PATH
0000BEr 1  8E 80 02           stx   PathBuf           ; update string len in pathbuf
0000C1r 1  A9 80              lda   #<PathBuf
0000C3r 1  8D rr rr           sta   LDR_PARM_PREFIX+1
0000C6r 1  A9 02              lda   #>PathBuf
0000C8r 1  8D rr rr           sta   LDR_PARM_PREFIX+2
0000CBr 1  20 00 BF           jsr   P8_MLI
0000CEr 1  C6                 .byte $C6               ; SET_PREFIX
0000CFr 1  rr rr              .addr LDR_PARM_PREFIX
0000D1r 1  90 3B              bcc   LDR_STARTUP
0000D3r 1               ; Finally, try to set prefix to our startup volume
0000D3r 1               LDR_TRY_DEV
0000D3r 1  AD rr rr           lda   START_DEV
0000D6r 1  8D rr rr           sta   LDR_PARM_ONLINE+1
0000D9r 1  20 00 BF           jsr   P8_MLI
0000DCr 1  C5                 .byte $C5               ; ON_LINE
0000DDr 1  rr rr              .addr LDR_PARM_ONLINE
0000DFr 1  B0 42              bcs   LDR_GOBASIC       ; failde, no prefix to set, carry on
0000E1r 1  AD 00 10           lda   $1000
0000E4r 1  29 0F              and   #$0F
0000E6r 1  F0 3B              beq   LDR_GOBASIC       ; failed to get a volume name
0000E8r 1  AA                 tax
0000E9r 1  E8                 inx                     ; account for prepending /
0000EAr 1  8E 00 02           stx   Ibuffs            ; write length
0000EDr 1  A9 2F              lda   #'/'
0000EFr 1  8D 01 02           sta   Ibuffs+1
0000F2r 1  CA                 dex
0000F3r 1  BD 00 10     :     lda   $1000,x
0000F6r 1  9D 01 02           sta   Ibuffs+1,x        ; copy volume name
0000F9r 1  CA                 dex
0000FAr 1  D0 F7              bne   :-
0000FCr 1  A9 00              lda   #<Ibuffs
0000FEr 1  8D rr rr           sta   LDR_PARM_PREFIX+1
000101r 1  A9 02              lda   #>Ibuffs
000103r 1  8D rr rr           sta   LDR_PARM_PREFIX+2
000106r 1  20 00 BF           jsr   P8_MLI
000109r 1  C6                 .byte $C6               ; SET_PREFIX
00010Ar 1  rr rr              .addr LDR_PARM_PREFIX
00010Cr 1  B0 15              bcs   LDR_GOBASIC       ; all attempts to set prefix failed
00010Er 1               ; Look for startup file
00010Er 1               LDR_STARTUP
00010Er 1  AD rr rr           lda   LDR_STARTUP_FILE
000111r 1  F0 10              beq   LDR_GOBASIC       ; if no startup file given
000113r 1  20 00 BF           jsr   P8_MLI
000116r 1  C4                 .byte $C4               ; GET_FILE_INFO
000117r 1  rr rr              .addr LDR_PARM_INFO
000119r 1  B0 08              bcs   LDR_GOBASIC       ; failed
00011Br 1  AD rr rr           lda   LDR_PARM_INFO+3
00011Er 1  29 01              and   #$01              ; check read bit
000120r 1  8D rr rr           sta   START_FILE        ; and flag for later
000123r 1               ; launch interpreter
000123r 1               LDR_GOBASIC
000123r 1  4C rr rr           jmp   __interp_RUN__
000126r 1               
000126r 1               LDR_IO_INIT:
000126r 1  A9 00              lda   #$00
000128r 1  20 BA AF           jsr   DO_VEC_SETOSLOT
00012Br 1  A9 00              lda   #$00
00012Dr 1  4C 83 AF           jmp   DO_VEC_SETISLOT
000130r 1               
000130r 1               ; move interpreter
000130r 1               LDR_MOVE_BASIC
000130r 1  A9 rr              lda   #<__interp_LOAD__
000132r 1  A0 rr              ldy   #>__interp_LOAD__
000134r 1  85 3C              sta   ZP_A1
000136r 1  84 3D              sty   ZP_A1+1
000138r 1  A9 rr              lda   #<(__interp_LOAD__+__interp_SIZE__)
00013Ar 1  A0 rr              ldy   #>(__interp_LOAD__+__interp_SIZE__)
00013Cr 1  85 3E              sta   ZP_A2
00013Er 1  84 3F              sty   ZP_A2+1
000140r 1  A9 rr              lda   #<__interp_RUN__
000142r 1  A0 rr              ldy   #>__interp_RUN__
000144r 1  85 42              sta   ZP_A4
000146r 1  84 43              sty   ZP_A4+1
000148r 1  A0 00              ldy   #$00              ; required to move properly
00014Ar 1  20 2C FE           jsr   F8_MOVE           ; firmware move routine
00014Dr 1  60                 rts
00014Er 1               ; move globals, one page
00014Er 1               LDR_MOVE_GLOBALS
00014Er 1  A2 00              ldx   #$00
000150r 1  BD rr rr     :     lda   __global_LOAD__,x
000153r 1  9D rr rr           sta   __global_RUN__,x
000156r 1  E8                 inx
000157r 1  D0 F7              bne   :-
000159r 1  60                 rts
00015Ar 1               
00015Ar 1               ; I/O initialization
00015Ar 1               LDR_IO_SETUP
00015Ar 1  A9 20              lda   #$20
00015Cr 1  85 E6              sta   ZP_HGRPAGE        ; make sure hgr and friends don't do bad stuff
00015Er 1  AD 30 BF           lda   P8_DEVNUM
000161r 1  8D rr rr           sta   START_DEV
000164r 1  20 rr rr           jsr   LDR_SCANSLOTS
000167r 1  20 rr rr           jsr   LDR_IO_INIT       ; init basic I/O
00016Ar 1               
00016Ar 1  60                 rts
00016Br 1               
00016Br 1               ; now scan slots for Pascal 1.1 firmware cards
00016Br 1               LDR_SCANSLOTS
00016Br 1  64 00              stz   $00
00016Dr 1  A9 C8              lda   #$C8              ; slot 7+1
00016Fr 1  85 01              sta   $01
000171r 1  C6 01        :     dec   $01
000173r 1  A5 01              lda   $01
000175r 1  C9 C0              cmp   #$C0              ; hit slot 0?
000177r 1  F0 56              beq   scandone
000179r 1  A0 05              ldy   #$05              ; offset 5
00017Br 1  B1 00              lda   ($00),y           ; get signature byte
00017Dr 1  C9 38              cmp   #$38              ; firmware card sig #1
00017Fr 1  D0 4F              bne   trydisk
000181r 1  A0 07              ldy   #$07
000183r 1  B1 00              lda   ($00),y
000185r 1  C9 18              cmp   #$18              ; firmware card sig #2
000187r 1  D0 47              bne   trydisk
000189r 1  A0 0B              ldy   #$0B
00018Br 1  B1 00              lda   ($00),y
00018Dr 1  C9 01              cmp   #$01              ; sig for pascal 1.1 cards
00018Fr 1  D0 3F              bne   trydisk
000191r 1                     ; all bytes matched now generate I/O pointers and such
000191r 1  A5 01              lda   $01
000193r 1  29 0F              and   #$0F
000195r 1  AA                 tax                     ; slot num now in X
000196r 1  A0 0C              ldy   #$0C
000198r 1  B1 00              lda   ($00),y           ; get signature byte $mn
00019Ar 1  9D rr rr           sta   SLOT_TYPES,x      ; save to slot types table
00019Dr 1  A9 rr              lda   #>GLOBAL_PAGE     ; global page high byte
00019Fr 1  8D rr rr           sta   gpage+1           ; into sta instruction
0001A2r 1  A5 01              lda   $01               ; slot #
0001A4r 1  AA                 tax                     ; save it
0001A5r 1  29 0F              and   #$0F              ; $0n
0001A7r 1  0A                 asl                     ; n*2
0001A8r 1  0A                 asl                     ; n*4
0001A9r 1  0A                 asl                     ; n*8 bytes per slot entry
0001AAr 1  18                 clc
0001ABr 1  69 4C              adc   #<(SLOT_TAB-GLOBAL_PAGE)  ; add the offset to table
0001ADr 1  8D rr rr           sta   gpage             ; bottom byte of sta pointer
0001B0r 1  A9 05              lda   #$05              ; copy 4 bytes from fw total
0001B2r 1  A0 0D              ldy   #$0D              ; start at FW byte $0D
0001B4r 1  85 02              sta   $02               ; temp loc
0001B6r 1  C6 02        cplp: dec   $02               ; next ID byte offset
0001B8r 1  F0 B7              beq   :-                ; done if hit 0
0001BAr 1  20 rr rr           jsr   copyfwbyte        ; copy it to global page vector low byte
0001BDr 1  EE rr rr           inc   gpage             ; move to high byte in vector
0001C0r 1  8A                 txa                     ; get the slot address back into A
0001C1r 1  20 rr rr           jsr   copyfwbyte2       ; and put it in the vector
0001C4r 1  EE rr rr           inc   gpage             ; next vector
0001C7r 1  C8                 iny                     ; next slot byte
0001C8r 1  D0 EC              bne   cplp              ; always
0001CAr 1               copyfwbyte
0001CAr 1  B1 00              lda   ($00),y
0001CCr 1               copyfwbyte2
0001CCr 1  8D rr rr           sta   GLOBAL_PAGE       ; self-modifying
0001CFr 1               gpage = *-2
0001CFr 1               scandone                      ; the RTS is dual-purpose!
0001CFr 1  60                 rts
0001D0r 1               trydisk:
0001D0r 1  A0 01              ldy   #$01
0001D2r 1  B1 00              lda   ($00),y
0001D4r 1  C9 20              cmp   #$20
0001D6r 1  D0 99              bne   :-
0001D8r 1  A0 03              ldy   #$03
0001DAr 1  B1 00              lda   ($00),y
0001DCr 1  D0 93              bne   :-
0001DEr 1  A0 05              ldy   #$05
0001E0r 1  B1 00              lda   ($00),y
0001E2r 1  C9 03              cmp   #$03
0001E4r 1  D0 8B              bne   :-
0001E6r 1  A5 01              lda   $01
0001E8r 1  29 0F              and   #$0F
0001EAr 1  AA                 tax
0001EBr 1  A9 07              lda   #$07              ; pascal "mass-storage"
0001EDr 1  9D rr rr           sta   SLOT_TYPES,x      ; into slot type
0001F0r 1  8A                 txa
0001F1r 1  0A                 asl
0001F2r 1  0A                 asl
0001F3r 1  0A                 asl
0001F4r 1  AA                 tax
0001F5r 1  A0 04              ldy   #$04
0001F7r 1  A9 00        :     lda   #$00
0001F9r 1  9D rr rr           sta   SLOT_TAB,x
0001FCr 1  E8                 inx
0001FDr 1  A5 01              lda   $01
0001FFr 1  9D rr rr           sta   SLOT_TAB,x
000202r 1  E8                 inx
000203r 1  88                 dey
000204r 1  D0 F1              bne   :-
000206r 1  4C rr rr           jmp   :--               ; back to loop
000209r 1               
000209r 1               ; BASIC calls us after we warm start
000209r 1               ; this is so we can do some finalizations such as:
000209r 1               ; print the sign-on message, adjust monitor I/O vectors to our
000209r 1               ; routines and then we turn the JMP to an RTS
000209r 1               LDR_CALLBACK:
000209r 1  A9 60              lda   #$60              ; RTS opcode
00020Br 1  8D rr rr           sta   WS_VEC            ; so we don't ge called again
00020Er 1                     ; greeting
00020Er 1  A9 rr              lda   #<LDR_SMSG        ; point to sign-on message (low addr)
000210r 1  A0 rr              ldy   #>LDR_SMSG        ; point to sign-on message (high addr)
000212r 1  20 18 8E           jsr   LAB_18C3          ; print null terminated string from memory
000215r 1                     ; set up permanent vectors
000215r 1  A9 4C              lda   #$4C              ; JMP opcode
000217r 1  8D F8 03           sta   CTRL_Y
00021Ar 1  A4 01              ldy   $01               ; get warm start vector
00021Cr 1  A5 02              lda   $02               ; that BASIC set up already
00021Er 1  8C F9 03           sty   CTRL_Y+1
000221r 1  8D FA 03           sta   CTRL_Y+2
000224r 1  A0 FD              ldy   #<LAB_RESET
000226r 1  A9 AE              lda   #>LAB_RESET
000228r 1  8C F2 03           sty   SOFTEV
00022Br 1  8D F3 03           sta   SOFTEV+1
00022Er 1  49 A5              eor   #MAGIC_A5
000230r 1  8D F4 03           sta   POWERUP
000233r 1  AD rr rr           lda   START_FILE
000236r 1  D0 01              bne   :+                ; do startup file
000238r 1  60                 rts
000239r 1  AD rr rr     :     lda   LDR_STARTUP_FILE  ; length of startup file path
00023Cr 1  A2 rr              ldx   #<(LDR_STARTUP_FILE+1)
00023Er 1  A0 rr              ldy   #>(LDR_STARTUP_FILE+1)
000240r 1  20 B9 B1           jsr   V_LOAD_S1         ; load the file
000243r 1  A9 80              lda   #$80
000245r 1  8D rr rr           sta   AUTO_RUN          ; flag interpreter to auto run loaded file
000248r 1  4C AA B1           jmp   V_LOAD_S2         ; and do it
00024Br 1               LDR_SMSG:
00024Br 1  45 6E 68 61        .byte "Enhanced BASIC 2.22p2 / 0.10",$0D,$0A
00024Fr 1  6E 63 65 64  
000253r 1  20 42 41 53  
000269r 1  41 70 70 6C        .byte "Apple ",$5d,$5b," port by M.G.",$0D,$0A
00026Dr 1  65 20 5D 5B  
000271r 1  20 70 6F 72  
000280r 1  00                 .byte $00
000281r 1               
000281r 1               LDR_PARM_INFO
000281r 1  0A                 .byte $0a               ; Parm count
000282r 1  rr rr              .addr LDR_STARTUP_FILE  ; pathname
000284r 1  00                 .byte $00               ; access
000285r 1  00                 .byte $00               ; file type
000286r 1  00 00              .word $0000             ; aux type
000288r 1  00                 .byte $00               ; storage type
000289r 1  00 00              .word $0000             ; blocks used
00028Br 1  00 00              .word $0000             ; mod date
00028Dr 1  00 00              .word $0000             ; mod time
00028Fr 1  00 00              .word $0000             ; create date
000291r 1  00 00              .word $0000             ; create time
000293r 1               
000293r 1               LDR_PARM_PREFIX
000293r 1  01                 .byte $01               ; parm count
000294r 1  00 02              .addr $0200             ; buffer addr
000296r 1               
000296r 1               LDR_PARM_ONLINE
000296r 1  02                 .byte $02
000297r 1  00                 .byte $00               ; unit_num
000298r 1  00 10              .addr $1000             ; data_buffer
00029Ar 1               
00029Ar 1               ; P8 Memory map bytes, adjust to match interpreter run
00029Ar 1               ; location
00029Ar 1               LDR_MEMTAB  ; 24 bytes
00029Ar 1  CF                 .byte %11001111         ; 00 0000-07FF, protect 0,1,4-7
00029Br 1  00                 .byte %00000000         ; 01 0800-0FFF
00029Cr 1  00                 .byte %00000000         ; 02 1000-17FF
00029Dr 1  00                 .byte %00000000         ; 03 1800-1FFF
00029Er 1  00                 .byte %00000000         ; 04 2000-27FF
00029Fr 1  00                 .byte %00000000         ; 05 2800-2FFF
0002A0r 1  00                 .byte %00000000         ; 06 3000-37FF
0002A1r 1  00                 .byte %00000000         ; 07 3800-3FFF
0002A2r 1  00                 .byte %00000000         ; 08 4000-47FF
0002A3r 1  00                 .byte %00000000         ; 09 4800-4FFF
0002A4r 1  00                 .byte %00000000         ; 0A 5000-57FF
0002A5r 1  00                 .byte %00000000         ; 0B 5800-5FFF
0002A6r 1  00                 .byte %00000000         ; 0C 6000-67FF
0002A7r 1  00                 .byte %00000000         ; 0D 6800-6FFF
0002A8r 1  00                 .byte %00000000         ; 0E 7000-77FF
0002A9r 1  00                 .byte %00000000         ; 0F 7800-7FFF
0002AAr 1  0F                 .byte %00001111         ; 10 8000-87FF
0002ABr 1  FF                 .byte %11111111         ; 11 8800-8FFF
0002ACr 1  FF                 .byte %11111111         ; 12 9000-97FF
0002ADr 1  FF                 .byte %11111111         ; 13 9800-9FFF
0002AEr 1  FF                 .byte %11111111         ; 14 A000-A7FF
0002AFr 1  FF                 .byte %11111111         ; 15 A800-AFFF
0002B0r 1  FF                 .byte %11111111         ; 16 B000-B7FF
0002B1r 1  FF                 .byte %11111111         ; 17 B800-BFFF
0002B2r 1               
0002B2r 1               
0002B2r 1  xx xx xx xx  .align  256
0002B6r 1  xx xx xx xx  
0002BAr 1  xx xx xx xx  
000300r 1               .popseg
000000r 1               
000000r 1               .segment "interp"
000000r 1                     .org  $8400            ; change and uncomment for easier debugging
008400  1               .else
008400  1                     *=    $C000
008400  1               .endif
008400  1               
008400  1               .assert (<*)=0, error, "interpreter not aligned on a page"
008400  1               
008400  1               ; BASIC cold start entry point
008400  1               
008400  1               ; new page 2 initialisation, copy block to ccflag on
008400  1               
008400  1               LAB_COLD
008400  1  A0 04              LDY   #PG2_TABE-PG2_TABS-1
008402  1                                             ; byte count-1
008402  1               LAB_2D13
008402  1  B9 5E B3           LDA   PG2_TABS,Y        ; get byte
008405  1  99 rr rr           STA   ccflag,Y          ; store in page 2
008408  1  88                 DEY                     ; decrement count
008409  1  10 F7              BPL   LAB_2D13          ; loop if not done
00840B  1               
00840B  1  A2 FF              LDX   #$FF              ; set byte
00840D  1  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00840F  1  9A                 TXS                     ; reset stack pointer
008410  1               
008410  1  A9 4C              LDA   #$4C              ; code for JMP
008412  1  85 A1              STA   Fnxjmp            ; save for jump vector for functions
008414  1               
008414  1               ; copy block from LAB_2CEE to $00BC - $00D3
008414  1               
008414  1  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
008416  1               LAB_2D4E
008416  1  BD 62 B3           LDA   LAB_2CEE-1,X      ; get byte from table
008419  1  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00841B  1  CA                 DEX                     ; decrement count
00841C  1  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00841E  1               
00841E  1               ; copy block from StrTab to $0000 - $0012
00841E  1               
00841E  1               LAB_GMEM
00841E  1  A2 10              LDX   #EndTab-StrTab-1  ; set byte count-1
008420  1               TabLoop
008420  1  BD 7F B3           LDA   StrTab,X          ; get byte from table
008423  1  95 00              STA   PLUS_0,X          ; save byte in page zero
008425  1  CA                 DEX                     ; decrement count
008426  1  10 F8              BPL   TabLoop           ; loop if not all done
008428  1               
008428  1               ; set-up start values
008428  1               .ifdef APPLE2
008428  1  AD rr rr           LDA   RAM_BASE
00842B  1  85 11              STA   Itempl
00842D  1  AD rr rr           LDA   RAM_BASE+1
008430  1  85 12              STA   Itemph
008432  1               .endif
008432  1               
008432  1  A9 00              LDA   #$00              ; clear A
008434  1               .ifndef NO_INT
008434  1                     STA   NmiBase           ; clear NMI handler enabled flag
008434  1                     STA   IrqBase           ; clear IRQ handler enabled flag
008434  1               .endif
008434  1  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
008436  1  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
008438  1               .ifdef APPLE2
008438  1  A9 08              LDA   #8                ; set default tab size
00843A  1               .else
00843A  1                     LDA   #$0E              ; set default tab size
00843A  1               .endif
00843A  1  85 64              STA   TabSiz            ; save it
00843C  1  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00843E  1  85 A0              STA   g_step            ; save it
008440  1  A2 68              LDX   #des_sk           ; descriptor stack start
008442  1  86 65              STX   next_s            ; set descriptor stack pointer
008444  1               .ifdef APPLE2
008444  1  20 BC A5           JSR   LAB_HOME          ; clear screen, home cursor
008447  1               .else
008447  1                     JSR   LAB_CRLF          ; print CR/LF
008447  1               .endif
008447  1               
008447  1               .ifdef APPLE2
008447  1  AD rr rr           LDA   RAM_TOP
00844A  1  AC rr rr           LDY   RAM_TOP+1
00844D  1               .else
00844D  1                     LDA   #<LAB_MSZM        ; point to memory size message (low addr)
00844D  1                     LDY   #>LAB_MSZM        ; point to memory size message (high addr)
00844D  1                     JSR   LAB_18C3          ; print null terminated string from memory
00844D  1                     JSR   LAB_INLN          ; print "? " and get BASIC input
00844D  1                     STX   Bpntrl            ; set BASIC execute pointer low byte
00844D  1                     STY   Bpntrh            ; set BASIC execute pointer high byte
00844D  1                     JSR   LAB_GBYT          ; get last byte back
00844D  1               
00844D  1                     BNE   LAB_2DAA          ; branch if not null (user typed something)
00844D  1               
00844D  1                     LDY   #$00              ; else clear Y
00844D  1                                             ; character was null so get memory size the hard way
00844D  1                                             ; we get here with Y=0 and Itempl/h = Ram_base
00844D  1               LAB_2D93
00844D  1                     INC   Itempl            ; increment temporary integer low byte
00844D  1                     BNE   LAB_2D99          ; branch if no overflow
00844D  1               
00844D  1                     INC   Itemph            ; increment temporary integer high byte
00844D  1                     LDA   Itemph            ; get high byte
00844D  1                     CMP   #>Ram_top         ; compare with top of RAM+1
00844D  1                     BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00844D  1               
00844D  1               LAB_2D99
00844D  1                     LDA   #$55              ; set test byte
00844D  1                     STA   (Itempl),Y        ; save via temporary integer
00844D  1                     CMP   (Itempl),Y        ; compare via temporary integer
00844D  1                     BNE   LAB_2DB6          ; branch if fail
00844D  1               
00844D  1                     ASL                     ; shift test byte left (now $AA)
00844D  1                     STA   (Itempl),Y        ; save via temporary integer
00844D  1                     CMP   (Itempl),Y        ; compare via temporary integer
00844D  1                     BEQ   LAB_2D93          ; if ok go do next byte
00844D  1               
00844D  1                     BNE   LAB_2DB6          ; branch if fail
00844D  1               
00844D  1               LAB_2DAA
00844D  1                     JSR   LAB_2887          ; get FAC1 from string
00844D  1                     LDA   FAC1_e            ; get FAC1 exponent
00844D  1                     CMP   #$98              ; compare with exponent = 2^24
00844D  1                     BCS   LAB_GMEM          ; if too large go try again
00844D  1               
00844D  1                     JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00844D  1                                             ; (no range check)
00844D  1               
00844D  1               LAB_2DB6
00844D  1                     LDA   Itempl            ; get temporary integer low byte
00844D  1                     LDY   Itemph            ; get temporary integer high byte
00844D  1                     CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
00844D  1                     BCC   LAB_GMEM          ; if too small go try again
00844D  1               
00844D  1               
00844D  1               ; uncomment these lines if you want to check on the high limit of memory. Note if
00844D  1               ; Ram_top is set too low then this will fail. default is ignore it and assume the
00844D  1               ; users know what they're doing!
00844D  1               
00844D  1                     CPY   #>Ram_top         ; compare with top of RAM high byte
00844D  1                     BCC   MEM_OK            ; branch if < RAM top
00844D  1               
00844D  1                     BNE   LAB_GMEM          ; if too large go try again
00844D  1                                             ; else was = so compare low bytes
00844D  1                     CMP   #<Ram_top         ; compare with top of RAM low byte
00844D  1                     BEQ   MEM_OK            ; branch if = RAM top
00844D  1               
00844D  1                     BCS   LAB_GMEM          ; if too large go try again
00844D  1               .endif
00844D  1               
00844D  1               MEM_OK
00844D  1  85 85              STA   Ememl             ; set end of mem low byte
00844F  1  84 86              STY   Ememh             ; set end of mem high byte
008451  1  85 81              STA   Sstorl            ; set bottom of string space low byte
008453  1  84 82              STY   Sstorh            ; set bottom of string space high byte
008455  1               .ifdef APPLE2
008455  1  AC rr rr           LDY   RAM_BASE          ; from global page
008458  1  AE rr rr           LDX   RAM_BASE+1        ; from global page
00845B  1               .else
00845B  1                     LDY   #<Ram_base        ; set start addr low byte
00845B  1                     LDX   #>Ram_base        ; set start addr high byte
00845B  1               .endif
00845B  1  84 79              STY   Smeml             ; save start of mem low byte
00845D  1  86 7A              STX   Smemh             ; save start of mem high byte
00845F  1               
00845F  1               ; this line is only needed if Ram_base is not $xx00
00845F  1               .ifdef APPLE2
00845F  1  A0 00              LDY   #$00              ; always do on Apple II
008461  1               .else
008461  1                     .IF   Ram_base&$FF>0
008461  1                     LDY   #$00              ; clear Y
008461  1                     .ENDIF
008461  1               .endif
008461  1  98                 TYA                     ; clear A
008462  1  91 79              STA   (Smeml),Y         ; clear first byte
008464  1  E6 79              INC   Smeml             ; increment start of mem low byte
008466  1               .ifdef APPLE2
008466  1  D0 02              BNE   LAB_2E05          ; always do on Apple II
008468  1  E6 7A              INC   Smemh
00846A  1               LAB_2E05
00846A  1               .else
00846A  1               ; these two lines are only needed if Ram_base is $xxFF
00846A  1               .IF   Ram_base&$FF=$FF
00846A  1                     BNE   LAB_2E05          ; branch if no rollover
00846A  1                     INC   Smemh             ; increment start of mem high byte
00846A  1               LAB_2E05
00846A  1               .ENDIF
00846A  1               .endif
00846A  1               
00846A  1  20 D4 8D           JSR   LAB_CRLF          ; print CR/LF
00846D  1  20 4B 88           JSR   LAB_1463          ; do "NEW" and "CLEAR"
008470  1  A5 85              LDA   Ememl             ; get end of mem low byte
008472  1  38                 SEC                     ; set carry for subtract
008473  1  E5 79              SBC   Smeml             ; subtract start of mem low byte
008475  1  AA                 TAX                     ; copy to X
008476  1  A5 86              LDA   Ememh             ; get end of mem high byte
008478  1  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00847A  1  20 DD 9F           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00847D  1  A9 9F              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00847F  1  A0 B3              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
008481  1  20 18 8E           JSR   LAB_18C3          ; print null terminated string from memory
008484  1  A9 95              LDA   #<LAB_1274        ; warm start vector low byte
008486  1  A0 85              LDY   #>LAB_1274        ; warm start vector high byte
008488  1  85 01              STA   Wrmjpl            ; save warm start vector low byte
00848A  1  84 02              STY   Wrmjph            ; save warm start vector high byte
00848C  1  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00848F  1               
00848F  1               ; open up space in memory
00848F  1               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00848F  1               
00848F  1               ; Nbendl,Nbendh - new block end address (A/Y)
00848F  1               ; Obendl,Obendh - old block end address
00848F  1               ; Ostrtl,Ostrth - old block start address
00848F  1               
00848F  1               ; returns with ..
00848F  1               
00848F  1               ; Nbendl,Nbendh - new block start address (high byte - $100)
00848F  1               ; Obendl,Obendh - old block start address (high byte - $100)
00848F  1               ; Ostrtl,Ostrth - old block start address (unchanged)
00848F  1               
00848F  1               LAB_11CF
00848F  1  20 D9 84           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
008492  1                                             ; addr to check is in AY (low/high)
008492  1  85 7F              STA   Earryl            ; save new array mem end low byte
008494  1  84 80              STY   Earryh            ; save new array mem end high byte
008496  1               
008496  1               ; open up space in memory
008496  1               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
008496  1               ; don't set array end
008496  1               
008496  1               LAB_11D6
008496  1  38                 SEC                     ; set carry for subtract
008497  1  A5 A6              LDA   Obendl            ; get block end low byte
008499  1  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00849B  1  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00849C  1  A5 A7              LDA   Obendh            ; get block end high byte
00849E  1  E5 AB              SBC   Ostrth            ; subtract block start high byte
0084A0  1  AA                 TAX                     ; copy block length high byte to X
0084A1  1  E8                 INX                     ; +1 to allow for count=0 exit
0084A2  1  98                 TYA                     ; copy block length low byte to A
0084A3  1  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
0084A5  1               
0084A5  1                                             ; block is (X-1)*256+Y bytes, do the Y bytes first
0084A5  1               
0084A5  1  38                 SEC                     ; set carry for add + 1, two's complement
0084A6  1  49 FF              EOR   #$FF              ; invert low byte for subtract
0084A8  1  65 A6              ADC   Obendl            ; add block end low byte
0084AA  1               
0084AA  1  85 A6              STA   Obendl            ; save corrected old block end low byte
0084AC  1  B0 03              BCS   LAB_11F3          ; branch if no underflow
0084AE  1               
0084AE  1  C6 A7              DEC   Obendh            ; else decrement block end high byte
0084B0  1  38                 SEC                     ; set carry for add + 1, two's complement
0084B1  1               LAB_11F3
0084B1  1  98                 TYA                     ; get MOD(block length/$100) byte
0084B2  1  49 FF              EOR   #$FF              ; invert low byte for subtract
0084B4  1  65 A4              ADC   Nbendl            ; add destination end low byte
0084B6  1  85 A4              STA   Nbendl            ; save modified new block end low byte
0084B8  1  B0 08              BCS   LAB_1203          ; branch if no underflow
0084BA  1               
0084BA  1  C6 A5              DEC   Nbendh            ; else decrement block end high byte
0084BC  1  90 04              BCC   LAB_1203          ; branch always
0084BE  1               
0084BE  1               LAB_11FF
0084BE  1  B1 A6              LDA   (Obendl),Y        ; get byte from source
0084C0  1  91 A4              STA   (Nbendl),Y        ; copy byte to destination
0084C2  1               LAB_1203
0084C2  1  88                 DEY                     ; decrement index
0084C3  1  D0 F9              BNE   LAB_11FF          ; loop until Y=0
0084C5  1               
0084C5  1                                             ; now do Y=0 indexed byte
0084C5  1  B1 A6              LDA   (Obendl),Y        ; get byte from source
0084C7  1  91 A4              STA   (Nbendl),Y        ; save byte to destination
0084C9  1               LAB_120A
0084C9  1  C6 A7              DEC   Obendh            ; decrement source pointer high byte
0084CB  1  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
0084CD  1  CA                 DEX                     ; decrement block count
0084CE  1  D0 F2              BNE   LAB_1203          ; loop until count = $0
0084D0  1               
0084D0  1  60                 RTS
0084D1  1               
0084D1  1               ; check room on stack for A bytes
0084D1  1               ; stack too deep? do OM error
0084D1  1               
0084D1  1               LAB_1212
0084D1  1  85 78              STA   TempB             ; save result in temp byte
0084D3  1  BA                 TSX                     ; copy stack
0084D4  1  E4 78              CPX   TempB             ; compare new "limit" with stack
0084D6  1  90 5E              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
0084D8  1               
0084D8  1  60                 RTS
0084D9  1               
0084D9  1               ; check available memory, "Out of memory" error if no room
0084D9  1               ; addr to check is in AY (low/high)
0084D9  1               
0084D9  1               LAB_121F
0084D9  1  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
0084DB  1  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
0084DD  1               
0084DD  1  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
0084DF  1               
0084DF  1                                             ; high byte was =, now do low byte
0084DF  1  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
0084E1  1  90 24              BCC   LAB_124B          ; if less then exit (is ok)
0084E3  1               
0084E3  1                                             ; addr is > string storage ptr (oops!)
0084E3  1               LAB_1229
0084E3  1  48                 PHA                     ; push addr low byte
0084E4  1  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
0084E6  1  98                 TYA                     ; copy addr high byte (to push on stack)
0084E7  1               
0084E7  1                                             ; save misc numeric work area
0084E7  1               LAB_122D
0084E7  1  48                 PHA                     ; push byte
0084E8  1  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
0084EA  1  CA                 DEX                     ; decrement index
0084EB  1  10 FA              BPL   LAB_122D          ; loop until all done
0084ED  1               
0084ED  1  20 3B 97           JSR   LAB_GARB          ; garbage collection routine
0084F0  1               
0084F0  1                                             ; restore misc numeric work area
0084F0  1  A2 00              LDX   #$00              ; clear the index to restore bytes
0084F2  1               LAB_1238
0084F2  1  68                 PLA                     ; pop byte
0084F3  1  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
0084F5  1  E8                 INX                     ; increment index
0084F6  1  E0 08              CPX   #$08              ; compare with end + 1
0084F8  1  30 F8              BMI   LAB_1238          ; loop if more to do
0084FA  1               
0084FA  1  68                 PLA                     ; pop addr high byte
0084FB  1  A8                 TAY                     ; copy back to Y
0084FC  1  68                 PLA                     ; pop addr low byte
0084FD  1  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
0084FF  1  90 06              BCC   LAB_124B          ; if less then exit (is ok)
008501  1               
008501  1  D0 33              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
008503  1               
008503  1                                             ; high byte was =, now do low byte
008503  1  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
008505  1  B0 2F              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
008507  1               
008507  1                                             ; ok exit, carry clear
008507  1               LAB_124B
008507  1  60                 RTS
008508  1               
008508  1               .ifdef APPLE2
008508  1               LAB_GP8E                      ; get P8 error string
008508  1  A2 00              LDX   #$00
00850A  1  BD 01 BB     :     LDA   LAB_P8ER,x
00850D  1  F0 0A              BEQ   :+                ; hit end of table, set carry and exit
00850F  1  E8                 INX                     ; to pointer
008510  1  CD rr rr           CMP   ERRNO_PRODOS
008513  1  F0 06              BEQ   :++               ; found it, clear carry and exit
008515  1  E8                 INX                     ; to next entry
008516  1  E8                 INX
008517  1  D0 F1              BNE   :-                ; always, unless end of table marker gone
008519  1  38           :     SEC
00851A  1  60                 RTS
00851B  1  18           :     CLC
00851C  1  60                 RTS
00851D  1               
00851D  1               LAB_PP8E                      ; Print ProDOS 8 Error
00851D  1  B0 0A              BCS   :+                ; if X does not have valid error msg ref
00851F  1  BD 01 BB           LDA   LAB_P8ER,x        ; low byte of error message
008522  1  E8                 INX
008523  1  BC 01 BB           LDY   LAB_P8ER,x        ; high byte of error message
008526  1  4C 18 8E           JMP   LAB_18C3          ; print P8 error msg
008529  1  AE rr rr     :     LDX   ERRNO_PRODOS
00852C  1  A9 00              LDA   #$00
00852E  1  20 DD 9F           JSR   LAB_295E          ; print P8 error #
008531  1               LAB_ARTS                      ; a known RTS
008531  1  60                 RTS
008532  1               
008532  1               LAB_XCER
008532  1  A2 28              LDX   #$28
008534  1  D0 02              BNE   LAB_XERR
008536  1               .endif
008536  1               
008536  1               ; do "Out of memory" error then warm start
008536  1               
008536  1               LAB_OMER
008536  1  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
008538  1               
008538  1               ; do error #X, then warm start
008538  1               
008538  1               LAB_XERR
008538  1               .ifdef APPLE2
008538  1  9C rr rr           STZ   AUTO_RUN          ; prevent auto-run
00853B  1  A5 87              LDA   Clinel            ; save line number
00853D  1  8D rr rr           STA   ERRNO_LINE
008540  1  A5 88              LDA   Clineh
008542  1  8D rr rr           STA   ERRNO_LINE+1
008545  1  8A                 TXA
008546  1  4A                 LSR
008547  1  1A                 INC   A
008548  1  8D rr rr           STA   ERRNO_BASIC       ; save error number / 2 + 1
00854B  1  20 rr rr           JSR   ERR_VEC           ; tell potential interceptor (for clean up, etc.)
00854E  1  2C rr rr           BIT   TRY_STATUS
008551  1  10 03              BPL   :+                ; branch if no TRY active
008553  1  4C 89 A9           JMP   LAB_CATCH         ; otherwise catch error
008556  1               :
008556  1               .endif
008556  1  20 D4 8D           JSR   LAB_CRLF          ; print CR/LF
008559  1               
008559  1               .ifdef APPLE2
008559  1  E0 34              CPX   #LAST_ERR
00855B  1  90 0A              BCC   :+
00855D  1  AE rr rr           LDX   ERRNO_BASIC
008560  1  A9 00              LDA   #$00
008562  1  20 DD 9F           JSR   LAB_295E          ; print integer error number
008565  1  80 09              BRA   :++
008567  1  BD CD BA     :     LDA   LAB_BAER,X        ; get error message pointer low byte
00856A  1  BC CE BA           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00856D  1  20 18 8E           JSR   LAB_18C3          ; print null terminated string from memory
008570  1               :
008570  1               .else
008570  1                     LDA   LAB_BAER,X        ; get error message pointer low byte
008570  1                     LDY   LAB_BAER+1,X      ; get error message pointer high byte
008570  1                     JSR   LAB_18C3          ; print null terminated string from memory
008570  1               .endif
008570  1               
008570  1  20 8C 88           JSR   LAB_1491          ; flush stack and clear continue flag
008573  1               .ifdef APPLE2
008573  1  20 E2 B2           JSR   P8_CloseAll
008576  1  AD rr rr           LDA   ERRNO_BASIC       ; get error back
008579  1  C9 19              CMP   #$30/2+1          ; is P8 error?
00857B  1  D0 09              BNE   NOTP8ERR
00857D  1  AD rr rr           LDA   ERRNO_PRODOS
008580  1  20 08 85           JSR   LAB_GP8E          ; get error string
008583  1  20 1D 85           JSR   LAB_PP8E          ; print error string
008586  1               NOTP8ERR
008586  1               .endif
008586  1  A9 F4              LDA   #<LAB_EMSG        ; point to " Error" low addr
008588  1  A0 BC              LDY   #>LAB_EMSG        ; point to " Error" high addr
00858A  1               LAB_1269
00858A  1  20 18 8E           JSR   LAB_18C3          ; print null terminated string from memory
00858D  1  A4 88              LDY   Clineh            ; get current line high byte
00858F  1  C8                 INY                     ; increment it
008590  1  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
008592  1               
008592  1                                             ; else print line number
008592  1  20 D2 9F           JSR   LAB_2953          ; print " in line [LINE #]"
008595  1               
008595  1               ; BASIC warm start entry point
008595  1               ; wait for Basic command
008595  1               
008595  1               LAB_1274
008595  1               .ifndef NO_INT
008595  1                                             ; clear ON IRQ/NMI bytes
008595  1                     LDA   #$00              ; clear A
008595  1                     STA   IrqBase           ; clear enabled byte
008595  1                     STA   NmiBase           ; clear enabled byte
008595  1               .endif
008595  1               .ifdef APPLE2
008595  1  9C rr rr           STZ   TRY_STATUS        ; clear TRY status on all warm starts
008598  1  A9 45              LDA   #'E'
00859A  1  85 33              STA   ZP_PROMPT         ; this flags no CR->CRLF translation
00859C  1  20 rr rr           JSR   WS_VEC            ; warmstart vector in global page
00859F  1               .endif
00859F  1  A9 05              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
0085A1  1  A0 BD              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
0085A3  1               
0085A3  1  20 18 8E           JSR   LAB_18C3          ; go do print string
0085A6  1               
0085A6  1               ; wait for Basic command (no "Ready")
0085A6  1               
0085A6  1               LAB_127D
0085A6  1  20 B6 86           JSR   LAB_1357          ; call for BASIC input
0085A9  1               LAB_1280
0085A9  1  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
0085AB  1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
0085AD  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
0085B0  1  F0 F4              BEQ   LAB_127D          ; loop while null
0085B2  1               
0085B2  1               ; got to interpret input line now ..
0085B2  1               
0085B2  1  A2 FF              LDX   #$FF              ; current line to null value
0085B4  1  86 88              STX   Clineh            ; set current line high byte
0085B6  1  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
0085B8  1               
0085B8  1                                             ; no line number .. immediate mode
0085B8  1  20 56 87           JSR   LAB_13A6          ; crunch keywords into Basic tokens
0085BB  1  4C 05 8A           JMP   LAB_15F6          ; go scan and interpret code
0085BE  1               
0085BE  1               ; handle new BASIC line
0085BE  1               
0085BE  1               LAB_1295
0085BE  1  20 8B 8C           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0085C1  1  20 56 87           JSR   LAB_13A6          ; crunch keywords into Basic tokens
0085C4  1  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
0085C6  1  20 1F 88           JSR   LAB_SSLN          ; search BASIC for temp integer line number
0085C9  1  90 44              BCC   LAB_12E6          ; branch if not found
0085CB  1               
0085CB  1                                             ; aroooogah! line # already exists! delete it
0085CB  1  A0 01              LDY   #$01              ; set index to next line pointer high byte
0085CD  1  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
0085CF  1  85 72              STA   ut1_ph            ; save it
0085D1  1  A5 7B              LDA   Svarl             ; get start of vars low byte
0085D3  1  85 71              STA   ut1_pl            ; save it
0085D5  1  A5 AB              LDA   Baslnh            ; get found line pointer high byte
0085D7  1  85 74              STA   ut2_ph            ; save it
0085D9  1  A5 AA              LDA   Baslnl            ; get found line pointer low byte
0085DB  1  88                 DEY                     ; decrement index
0085DC  1  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
0085DE  1  18                 CLC                     ; clear carry for add
0085DF  1  65 7B              ADC   Svarl             ; add start of vars low byte
0085E1  1  85 7B              STA   Svarl             ; save new start of vars low byte
0085E3  1  85 73              STA   ut2_pl            ; save destination pointer low byte
0085E5  1  A5 7C              LDA   Svarh             ; get start of vars high byte
0085E7  1  69 FF              ADC   #$FF              ; -1 + carry
0085E9  1  85 7C              STA   Svarh             ; save start of vars high byte
0085EB  1  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
0085ED  1  AA                 TAX                     ; copy to block count
0085EE  1  38                 SEC                     ; set carry for subtract
0085EF  1  A5 AA              LDA   Baslnl            ; get found line pointer low byte
0085F1  1  E5 7B              SBC   Svarl             ; subtract start of vars low byte
0085F3  1  A8                 TAY                     ; copy to bytes in first block count
0085F4  1  B0 03              BCS   LAB_12D0          ; branch if overflow
0085F6  1               
0085F6  1  E8                 INX                     ; increment block count (correct for =0 loop exit)
0085F7  1  C6 74              DEC   ut2_ph            ; decrement destination high byte
0085F9  1               LAB_12D0
0085F9  1  18                 CLC                     ; clear carry for add
0085FA  1  65 71              ADC   ut1_pl            ; add source pointer low byte
0085FC  1  90 03              BCC   LAB_12D8          ; branch if no overflow
0085FE  1               
0085FE  1  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
008600  1  18                 CLC                     ; clear carry
008601  1               
008601  1                                             ; close up memory to delete old line
008601  1               LAB_12D8
008601  1  B1 71              LDA   (ut1_pl),Y        ; get byte from source
008603  1  91 73              STA   (ut2_pl),Y        ; copy to destination
008605  1  C8                 INY                     ; increment index
008606  1  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
008608  1               
008608  1  E6 72              INC   ut1_ph            ; increment source pointer high byte
00860A  1  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00860C  1  CA                 DEX                     ; decrement block count
00860D  1  D0 F2              BNE   LAB_12D8          ; loop until all done
00860F  1               
00860F  1                                             ; got new line in buffer and no existing same #
00860F  1               LAB_12E6
00860F  1  AD 00 02           LDA   Ibuffs            ; get byte from start of input buffer
008612  1  F0 4D              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
008614  1               
008614  1                                             ; got new line and it isn't empty line
008614  1  A5 85              LDA   Ememl             ; get end of mem low byte
008616  1  A4 86              LDY   Ememh             ; get end of mem high byte
008618  1  85 81              STA   Sstorl            ; set bottom of string space low byte
00861A  1  84 82              STY   Sstorh            ; set bottom of string space high byte
00861C  1  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00861E  1  85 A6              STA   Obendl            ; save old block end low byte
008620  1  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
008622  1  84 A7              STY   Obendh            ; save old block end high byte
008624  1  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
008626  1  90 01              BCC   LAB_1301          ; branch if no overflow from add
008628  1               
008628  1  C8                 INY                     ; else increment high byte
008629  1               LAB_1301
008629  1  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00862B  1  84 A5              STY   Nbendh            ; save new block end high byte
00862D  1  20 8F 84           JSR   LAB_11CF          ; open up space in memory
008630  1                                             ; old start pointer Ostrtl,Ostrth set by the find line call
008630  1  A5 7F              LDA   Earryl            ; get array mem end low byte
008632  1  A4 80              LDY   Earryh            ; get array mem end high byte
008634  1  85 7B              STA   Svarl             ; save start of vars low byte
008636  1  84 7C              STY   Svarh             ; save start of vars high byte
008638  1  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00863A  1  88                 DEY                     ; adjust for loop type
00863B  1               LAB_1311
00863B  1  B9 FC 01           LDA   Ibuffs-4,Y        ; get byte from crunched line
00863E  1  91 AA              STA   (Baslnl),Y        ; save it to program memory
008640  1  88                 DEY                     ; decrement count
008641  1  C0 03              CPY   #$03              ; compare with first byte-1
008643  1  D0 F6              BNE   LAB_1311          ; continue while count <> 3
008645  1               
008645  1  A5 12              LDA   Itemph            ; get line # high byte
008647  1  91 AA              STA   (Baslnl),Y        ; save it to program memory
008649  1               .ifdef APPLE2
008649  1  8D rr rr           STA   NEXT_LINE+1       ; for TAB auto-number
00864C  1               .endif
00864C  1  88                 DEY                     ; decrement count
00864D  1  A5 11              LDA   Itempl            ; get line # low byte
00864F  1  91 AA              STA   (Baslnl),Y        ; save it to program memory
008651  1               .ifdef APPLE2
008651  1  18                 CLC
008652  1  69 0A              ADC   #10
008654  1  8D rr rr           STA   NEXT_LINE         ; for TAB auto-number
008657  1  90 03              BCC   :+
008659  1  EE rr rr           INC   NEXT_LINE+1
00865C  1               :
00865C  1               .endif
00865C  1  88                 DEY                     ; decrement count
00865D  1  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00865F  1                                             ; byte then a zero already here would stop the chain rebuild
00865F  1                                             ; as it would think it was the [EOT] marker.
00865F  1  91 AA              STA   (Baslnl),Y        ; save it to program memory
008661  1               
008661  1               LAB_1319
008661  1  20 68 88           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
008664  1  A6 79              LDX   Smeml             ; get start of mem low byte
008666  1  A5 7A              LDA   Smemh             ; get start of mem high byte
008668  1  A0 01              LDY   #$01              ; index to high byte of next line pointer
00866A  1               LAB_1325
00866A  1  86 71              STX   ut1_pl            ; set line start pointer low byte
00866C  1  85 72              STA   ut1_ph            ; set line start pointer high byte
00866E  1  B1 71              LDA   (ut1_pl),Y        ; get it
008670  1  F0 18              BEQ   LAB_133E          ; exit if end of program
008672  1               
008672  1               ; rebuild chaining of Basic lines
008672  1               
008672  1  A0 04              LDY   #$04              ; point to first code byte of line
008674  1                                             ; there is always 1 byte + [EOL] as null entries are deleted
008674  1               LAB_1330
008674  1  C8                 INY                     ; next code byte
008675  1  B1 71              LDA   (ut1_pl),Y        ; get byte
008677  1  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
008679  1               
008679  1  38                 SEC                     ; set carry for add + 1
00867A  1  98                 TYA                     ; copy end index
00867B  1  65 71              ADC   ut1_pl            ; add to line start pointer low byte
00867D  1  AA                 TAX                     ; copy to X
00867E  1  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
008680  1  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
008682  1  98                 TYA                     ; clear A
008683  1  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
008685  1  C8                 INY                     ; increment index to high byte
008686  1  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
008688  1  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
00868A  1               
00868A  1               
00868A  1               LAB_133E
00868A  1               .ifdef APPLE2
00868A  1  2C rr rr           BIT   AUTO_RUN
00868D  1  10 16              BPL   :+
00868F  1  A2 00              LDX   #$00
008691  1  A9 8A              LDA   #TK_RUN
008693  1  9D 00 02           STA   Ibuffs,X          ; stuff a RUN token into the input buffer
008696  1  8A                 TXA
008697  1  E8                 INX
008698  1  9D 00 02           STA   Ibuffs,X
00869B  1  8D rr rr           STA   AUTO_RUN          ; don't keep auto-running
00869E  1  A2 00              LDX   #<Ibuffs
0086A0  1  A0 02              LDY   #>Ibuffs
0086A2  1  4C A9 85           JMP   LAB_1280          ; skip past input routine
0086A5  1               :
0086A5  1               .endif
0086A5  1  4C A6 85           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
0086A8  1               
0086A8  1               ; print "? " and get BASIC input
0086A8  1               
0086A8  1               LAB_INLN
0086A8  1  20 30 8E           JSR   LAB_18E3          ; print "?" character
0086AB  1  20 2D 8E           JSR   LAB_18E0          ; print " "
0086AE  1  D0 06              BNE   LAB_1357          ; call for BASIC input and return
0086B0  1               
0086B0  1               ; receive line from keyboard
0086B0  1               
0086B0  1                                             ; $08 as delete key (BACKSPACE on standard keyboard)
0086B0  1               LAB_134B
0086B0  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
0086B3  1  CA                 DEX                     ; decrement the buffer counter (delete)
0086B4  1               .ifdef APPLE2
0086B4  1  80 08              BRA   LAB_1359          ; skip zeroing line
0086B6  1               .else
0086B6  1                     .byte $2C               ; make LDX into BIT abs
0086B6  1               .endif
0086B6  1               ; call for BASIC input (main entry point)
0086B6  1               
0086B6  1               LAB_1357
0086B6  1               .ifdef APPLE2
0086B6  1  A9 45              LDA   #'E'
0086B8  1  85 33              STA   ZP_PROMPT         ; flag no CR/LF translation
0086BA  1               .endif
0086BA  1  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
0086BC  1               .ifdef APPLE2
0086BC  1  86 5B              STX   Temp3             ; zero max input (for right arrow support)
0086BE  1               .endif
0086BE  1               LAB_1359
0086BE  1               .ifdef APPLE2
0086BE  1  E4 5B              CPX   Temp3
0086C0  1  90 02              BCC   :+
0086C2  1  86 5B              STX   Temp3             ; update max input
0086C4  1  20 31 AF     :     JSR   V_INPT2           ; workaround to show cursor on 40-col
0086C7  1  90 FB              BCC   :-                ; if nothing
0086C9  1  C9 7F              CMP   #$7F              ; Apple //e and newer DELETE key
0086CB  1  D0 02              BNE   :+
0086CD  1  A9 08              LDA   #$08              ; translate to backspace
0086CF  1               :
0086CF  1               .else
0086CF  1                     JSR   V_INPT            ; call scan input device
0086CF  1                     BCC   LAB_1359          ; loop if no byte
0086CF  1               .endif
0086CF  1               
0086CF  1  F0 ED              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
0086D1  1               
0086D1  1  C9 07              CMP   #$07              ; compare with [BELL]
0086D3  1  F0 35              BEQ   LAB_1378          ; branch if [BELL]
0086D5  1               
0086D5  1  C9 0D              CMP   #$0D              ; compare with [CR]
0086D7  1  F0 3E              BEQ   LAB_1384          ; do CR/LF exit if [CR]
0086D9  1               
0086D9  1               .ifdef APPLE2
0086D9  1  C9 15              CMP   #$15              ; right arrow
0086DB  1  D0 07              BNE   :+                ; nope
0086DD  1  E4 5B              CPX   Temp3             ; check input length against most entered
0086DF  1  B0 DD              BCS   LAB_1359          ; nope, ignore it
0086E1  1  BD 00 02           LDA   Ibuffs,X          ; get next char in input buffer
0086E4  1  C9 18        :     CMP   #$18              ; ctrl-x - cancel line
0086E6  1  D0 0B              BNE   :+
0086E8  1  A9 5C              LDA   #'\'
0086EA  1  20 32 8E           JSR   LAB_PRNA
0086ED  1  20 D4 8D           JSR   LAB_CRLF
0086F0  1  4C B6 86           JMP   LAB_1357
0086F3  1               :
0086F3  1               .endif
0086F3  1               
0086F3  1  E0 00              CPX   #$00              ; compare pointer with $00
0086F5  1  D0 0F              BNE   LAB_1374          ; branch if not empty
0086F7  1               
0086F7  1               ; next two lines ignore any non print character and [SPACE] if input buffer empty
0086F7  1               .ifdef APPLE2
0086F7  1  C9 09              CMP   #$09              ; tab key
0086F9  1  D0 07              BNE   :+
0086FB  1  E4 5B              CPX   Temp3             ; X is 0 at this point
0086FD  1  D0 03              BNE   :+
0086FF  1  4C 1E 87           JMP   LAB_AUTONUM       ; do autonumber
008702  1               :
008702  1               .endif
008702  1               
008702  1  C9 21              CMP   #$21              ; compare with [SP]+1
008704  1  90 B8              BCC   LAB_1359          ; if < ignore character
008706  1               
008706  1               LAB_1374
008706  1  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
008708  1  F0 A6              BEQ   LAB_134B          ; go delete last character
00870A  1               
00870A  1               LAB_1378
00870A  1  E0 7F              CPX   #Ibuffe-Ibuffs    ; compare character count with max
00870C  1  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
00870E  1               
00870E  1  9D 00 02           STA   Ibuffs,X          ; else store in buffer
008711  1  E8                 INX                     ; increment pointer
008712  1               LAB_137F
008712  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
008715  1  D0 A7              BNE   LAB_1359          ; always loop for next character
008717  1               
008717  1               LAB_1384
008717  1  4C C6 8D           JMP   LAB_1866          ; do CR/LF exit to BASIC
00871A  1               
00871A  1               ; announce buffer full
00871A  1               
00871A  1               LAB_138E
00871A  1  A9 07              LDA   #$07              ; [BELL] character into A
00871C  1  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
00871E  1                                             ; branch always
00871E  1               .ifdef APPLE2
00871E  1               LAB_AUTONUM
00871E  1  5A                 PHY
00871F  1  A5 88              LDA   Clineh
008721  1  1A                 INC   A
008722  1  D0 27              BNE   LAB_AUTONUM_DN    ; not immediate mode, do none of this
008724  1  AD rr rr           LDA   NEXT_LINE+1
008727  1  AC rr rr           LDY   NEXT_LINE
00872A  1  20 B3 95           JSR   LAB_UAYFC         ; save and convert integer AY to FAC1
00872D  1  A0 00              LDY   #$00              ; have to do this for unsigned conversion
00872F  1  98                 TYA
008730  1  20 FD 9F           JSR   LAB_297B          ; convert FAC1 to string without sign
008733  1  A2 00              LDX   #$00
008735  1               LAB_AUTONUM_LP
008735  1  B5 F0              LDA   Decss+1,X
008737  1  F0 09              BEQ   :+
008739  1  9D 00 02           STA   Ibuffs,X
00873C  1  E8                 INX
00873D  1  20 32 8E           JSR   LAB_PRNA          ; we won't be printing a CR, so X is safe
008740  1  80 F3              BRA   LAB_AUTONUM_LP
008742  1  A9 20        :     LDA   #' '
008744  1  9D 00 02           STA   Ibuffs,X
008747  1  E8                 INX
008748  1  20 32 8E           JSR   LAB_PRNA
00874B  1               LAB_AUTONUM_DN
00874B  1  7A                 PLY
00874C  1  4C BE 86           JMP   LAB_1359
00874F  1               .endif
00874F  1               
00874F  1               ; crunch keywords into Basic tokens
00874F  1               ; position independent buffer version ..
00874F  1               ; faster, dictionary search version ....
00874F  1               
00874F  1               .ifdef LOW_TOKENS
00874F  1               ; Low token handling
00874F  1               LAB_13A0
00874F  1  24 60              BIT   Oquote            ; check quote mode
008751  1  70 03              BVS   :+                ; don't do if quoting
008753  1  E8                 INX                     ; skip this byte
008754  1  D0 0A              BNE   LAB_13AC          ; and go back to processing
008756  1               :
008756  1               .endif
008756  1               
008756  1               LAB_13A6
008756  1  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
008758  1               
008758  1  38                 SEC                     ; set carry for subtract
008759  1  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
00875B  1  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
00875D  1  AA                 TAX                     ; copy result to X (index past line # if any)
00875E  1               
00875E  1  86 60              STX   Oquote            ; clear open quote/DATA flag
008760  1               LAB_13AC
008760  1  BD 00 02           LDA   Ibuffs,X          ; get byte from input buffer
008763  1  F0 67              BEQ   LAB_13EC          ; if null save byte then exit
008765  1               
008765  1               .ifdef LOW_TOKENS
008765  1  C9 20              CMP   #$20
008767  1  90 E6              BCC   LAB_13A0          ; skip if not unprintable
008769  1               .endif
008769  1               
008769  1               .ifdef MIXED_CASE
008769  1  C9 7B              CMP   #'{'
00876B  1  B0 5F              BCS   LAB_13EC
00876D  1  C9 61              CMP   #'a'
00876F  1  90 02              BCC   PATCH_LC
008771  1  29 DF              AND   #$DF
008773  1               PATCH_LC
008773  1               .endif
008773  1  C9 5F              CMP   #'_'              ; compare with "_"
008775  1  B0 55              BCS   LAB_13EC          ; if >= go save byte then continue crunching
008777  1               
008777  1  C9 3C              CMP   #'<'              ; compare with "<"
008779  1  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
00877B  1               
00877B  1  C9 30              CMP   #'0'              ; compare with "0"
00877D  1  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
00877F  1               
00877F  1  85 5C              STA   Scnquo            ; save buffer byte as search character
008781  1  C9 22              CMP   #$22              ; is it quote character?
008783  1  F0 69              BEQ   LAB_1410          ; branch if so (copy quoted string)
008785  1               
008785  1  C9 2A              CMP   #'*'              ; compare with "*"
008787  1  90 43              BCC   LAB_13EC          ; if < go save byte then continue crunching
008789  1               
008789  1                                             ; else crunch now
008789  1               LAB_13CC
008789  1  24 60              BIT   Oquote            ; get open quote/DATA token flag
00878B  1  70 3F              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
00878D  1                                             ; go save byte then continue crunching
00878D  1  86 78              STX   TempB             ; save buffer read index
00878F  1  84 BA              STY   csidx             ; copy buffer save index
008791  1  A0 C6              LDY   #<TAB_1STC        ; get keyword first character table low address
008793  1  84 73              STY   ut2_pl            ; save pointer low byte
008795  1  A0 B5              LDY   #>TAB_1STC        ; get keyword first character table high address
008797  1  84 74              STY   ut2_ph            ; save pointer high byte
008799  1  A0 00              LDY   #$00              ; clear table pointer
00879B  1               
00879B  1               LAB_13D0
00879B  1  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
00879D  1  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
00879F  1               .ifdef MIXED_CASE
00879F  1  90 65              BCC   PATCH_LC2
0087A1  1               .else
0087A1  1                     BCC   LAB_13EA          ; if < keyword first character table byte go restore
0087A1  1                                             ; Y and save to crunched
0087A1  1               .endif
0087A1  1  C8                 INY                     ; else increment pointer
0087A2  1  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
0087A4  1               
0087A4  1               ; have matched first character of some keyword
0087A4  1               
0087A4  1               LAB_13D1
0087A4  1  98                 TYA                     ; copy matching index
0087A5  1  0A                 ASL                     ; *2 (bytes per pointer)
0087A6  1  AA                 TAX                     ; copy to new index
0087A7  1  BD E4 B5           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
0087AA  1  85 73              STA   ut2_pl            ; save pointer low byte
0087AC  1  BD E5 B5           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
0087AF  1  85 74              STA   ut2_ph            ; save pointer high byte
0087B1  1               
0087B1  1  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
0087B3  1               
0087B3  1  A6 78              LDX   TempB             ; restore buffer read index
0087B5  1               
0087B5  1               LAB_13D6
0087B5  1  C8                 INY                     ; next table byte
0087B6  1  B1 73              LDA   (ut2_pl),Y        ; get byte from table
0087B8  1               LAB_13D8
0087B8  1  30 10              BMI   LAB_13EA          ; all bytes matched so go save token
0087BA  1               .ifdef LOW_TOKENS
0087BA  1  C9 20              CMP   #$20              ; is low token?
0087BC  1  90 0C              BCC   LAB_13EA          ; yes, go save it
0087BE  1               .endif
0087BE  1  E8                 INX                     ; next buffer byte
0087BF  1               .ifdef  MIXED_CASE
0087BF  1  5D 00 02           EOR   Ibuffs,X          ; check bits against table
0087C2  1  29 DF              AND   #$DF              ; mask lower case bit
0087C4  1               .else
0087C4  1                     CMP   Ibuffs,X          ; compare with byte from input buffer
0087C4  1               .endif
0087C4  1  F0 EF              BEQ   LAB_13D6          ; go compare next if match
0087C6  1               
0087C6  1  D0 2D              BNE   LAB_1417          ; branch if >< (not found keyword)
0087C8  1               .ifdef LOW_TOKENS
0087C8  1               LAX_13AC
0087C8  1  80 96              BRA   LAB_13AC
0087CA  1               .endif
0087CA  1               
0087CA  1               LAB_13EA
0087CA  1  A4 BA              LDY   csidx             ; restore save index
0087CC  1               
0087CC  1                                             ; save crunched to output
0087CC  1               LAB_13EC
0087CC  1  E8                 INX                     ; increment buffer index (to next input byte)
0087CD  1  C8                 INY                     ; increment save index (to next output byte)
0087CE  1  99 00 02           STA   Ibuffs,Y          ; save byte to output
0087D1  1  C9 00              CMP   #$00              ; set the flags, set carry
0087D3  1  F0 39              BEQ   LAB_142A          ; do exit if was null [EOL]
0087D5  1               
0087D5  1                                             ; A holds token or byte here
0087D5  1  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
0087D7  1  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
0087D9  1               
0087D9  1                                             ; A now holds token-$3A
0087D9  1  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
0087DB  1  D0 02              BNE   LAB_1401          ; branch if not DATA
0087DD  1               
0087DD  1                                             ; token was : or DATA
0087DD  1               LAB_13FF
0087DD  1  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0087DF  1               LAB_1401
0087DF  1  49 55              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
0087E1  1               .ifdef LOW_TOKENS
0087E1  1  D0 E5              BNE   LAX_13AC          ; because we get out of range with low tokens
0087E3  1               .else
0087E3  1                     BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
0087E3  1               .endif
0087E3  1  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
0087E5  1               
0087E5  1                                             ; loop for REM, "..." etc.
0087E5  1               LAB_1408
0087E5  1  BD 00 02           LDA   Ibuffs,X          ; get byte from input buffer
0087E8  1  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
0087EA  1               
0087EA  1  C5 5C              CMP   Asrch             ; compare with stored character
0087EC  1  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
0087EE  1               
0087EE  1                                             ; entry for copy string in quotes, don't crunch
0087EE  1               LAB_1410
0087EE  1  C8                 INY                     ; increment buffer save index
0087EF  1  99 00 02           STA   Ibuffs,Y          ; save byte to output
0087F2  1  E8                 INX                     ; increment buffer read index
0087F3  1  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
0087F5  1               
0087F5  1                                             ; not found keyword this go
0087F5  1               LAB_1417
0087F5  1  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
0087F7  1               
0087F7  1                                             ; now find the end of this word in the table
0087F7  1               LAB_141B
0087F7  1  B1 73              LDA   (ut2_pl),Y        ; get table byte
0087F9  1  08                 PHP                     ; save status
0087FA  1  C8                 INY                     ; increment table index
0087FB  1               .ifdef LOW_TOKENS
0087FB  1  C9 20              CMP   #$20
0087FD  1  90 0C              BCC  LAB_1420           ; have low token
0087FF  1               .endif
0087FF  1  28                 PLP                     ; restore byte status
008800  1  10 F5              BPL   LAB_141B          ; if not end of keyword go do next
008802  1               .ifdef LOW_TOKENS
008802  1               LAB_141D
008802  1               .endif
008802  1  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
008804  1  D0 B2              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
008806  1               
008806  1               .ifdef MIXED_CASE
008806  1               PATCH_LC2
008806  1               .endif
008806  1                                             ; reached end of table with no match
008806  1  BD 00 02           LDA   Ibuffs,X          ; restore byte from input buffer
008809  1  10 BF              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
00880B  1                                             ; go save byte in output and continue crunching
00880B  1               
00880B  1                                             ; reached [EOL]
00880B  1               .ifdef LOW_TOKENS
00880B  1               LAB_1420
00880B  1  28                 PLP                     ; clean stack
00880C  1  80 F4              BRA   LAB_141D
00880E  1               .endif
00880E  1               LAB_142A
00880E  1  C8                 INY                     ; increment pointer
00880F  1  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
008810  1  99 00 02           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
008813  1  C8                 INY                     ; adjust for line copy
008814  1  C8                 INY                     ; adjust for line copy
008815  1  C8                 INY                     ; adjust for line copy
008816  1               ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
008816  1               ; *** insert
008816  1               .IF   Ibuffs&$FF=0
008816  1  A5 C3              LDA   Bpntrl            ; test for $00
008818  1  D0 02              BNE   LAB_142P          ; not $00
00881A  1  C6 C4              DEC   Bpntrh            ; allow for increment when $xx00
00881C  1               LAB_142P
00881C  1               .ENDIF
00881C  1               ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
00881C  1               ; end of patch
00881C  1  C6 C3              DEC   Bpntrl            ; allow for increment
00881E  1  60                 RTS
00881F  1               
00881F  1               ; search Basic for temp integer line number from start of mem
00881F  1               
00881F  1               LAB_SSLN
00881F  1  A5 79              LDA   Smeml             ; get start of mem low byte
008821  1  A6 7A              LDX   Smemh             ; get start of mem high byte
008823  1               
008823  1               ; search Basic for temp integer line number from AX
008823  1               ; returns carry set if found
008823  1               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
008823  1               
008823  1               ; old 541 new 507
008823  1               
008823  1               LAB_SHLN
008823  1  A0 01              LDY   #$01              ; set index
008825  1  85 AA              STA   Baslnl            ; save low byte as current
008827  1  86 AB              STX   Baslnh            ; save high byte as current
008829  1  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
00882B  1  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
00882D  1               
00882D  1  A0 03              LDY   #$03              ; set index to line # high byte
00882F  1  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
008831  1  88                 DEY                     ; decrement index (point to low byte)
008832  1  C5 12              CMP   Itemph            ; compare with temporary integer high byte
008834  1  D0 04              BNE   LAB_1455          ; if <> skip low byte check
008836  1               
008836  1  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
008838  1  C5 11              CMP   Itempl            ; compare with temporary integer low byte
00883A  1               LAB_1455
00883A  1  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
00883C  1               
00883C  1               LAB_1456
00883C  1  88                 DEY                     ; decrement index to next line ptr high byte
00883D  1  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00883F  1  AA                 TAX                     ; copy to X
008840  1  88                 DEY                     ; decrement index to next line ptr low byte
008841  1  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
008843  1  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
008845  1                                             ; (carry always clear)
008845  1               
008845  1               LAB_145E
008845  1  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
008847  1               
008847  1               LAB_145F
008847  1  18                 CLC                     ; clear found flag
008848  1               LAB_1460
008848  1  60                 RTS
008849  1               
008849  1               ; perform NEW
008849  1               
008849  1               LAB_NEW
008849  1  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
00884B  1               
00884B  1               LAB_1463
00884B  1               .ifdef APPLE2
00884B  1  A9 0A              LDA   #10
00884D  1  8D rr rr           STA   NEXT_LINE
008850  1  9C rr rr           STZ   NEXT_LINE+1
008853  1               .endif
008853  1  A9 00              LDA   #$00              ; clear A
008855  1  A8                 TAY                     ; clear Y
008856  1  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
008858  1  C8                 INY                     ; increment index
008859  1  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
00885B  1  18                 CLC                     ; clear carry
00885C  1  A5 79              LDA   Smeml             ; get start of mem low byte
00885E  1  69 02              ADC   #$02              ; calculate end of BASIC low byte
008860  1  85 7B              STA   Svarl             ; save start of vars low byte
008862  1  A5 7A              LDA   Smemh             ; get start of mem high byte
008864  1  69 00              ADC   #$00              ; add any carry
008866  1  85 7C              STA   Svarh             ; save start of vars high byte
008868  1               
008868  1               ; reset execution to start, clear vars and flush stack
008868  1               
008868  1               LAB_1477
008868  1  18                 CLC                     ; clear carry
008869  1  A5 79              LDA   Smeml             ; get start of mem low byte
00886B  1  69 FF              ADC   #$FF              ; -1
00886D  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00886F  1  A5 7A              LDA   Smemh             ; get start of mem high byte
008871  1  69 FF              ADC   #$FF              ; -1+carry
008873  1  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
008875  1               
008875  1               ; "CLEAR" command gets here
008875  1               
008875  1               LAB_147A
008875  1  A5 85              LDA   Ememl             ; get end of mem low byte
008877  1  A4 86              LDY   Ememh             ; get end of mem high byte
008879  1  85 81              STA   Sstorl            ; set bottom of string space low byte
00887B  1  84 82              STY   Sstorh            ; set bottom of string space high byte
00887D  1  A5 7B              LDA   Svarl             ; get start of vars low byte
00887F  1  A4 7C              LDY   Svarh             ; get start of vars high byte
008881  1  85 7D              STA   Sarryl            ; save var mem end low byte
008883  1  84 7E              STY   Sarryh            ; save var mem end high byte
008885  1  85 7F              STA   Earryl            ; save array mem end low byte
008887  1  84 80              STY   Earryh            ; save array mem end high byte
008889  1  20 6A 8A           JSR   LAB_161A          ; perform RESTORE command
00888C  1               
00888C  1               ; flush stack and clear continue flag
00888C  1               
00888C  1               LAB_1491
00888C  1  A2 68              LDX   #des_sk           ; set descriptor stack pointer
00888E  1  86 65              STX   next_s            ; save descriptor stack pointer
008890  1  68                 PLA                     ; pull return address low byte
008891  1  AA                 TAX                     ; copy return address low byte
008892  1  68                 PLA                     ; pull return address high byte
008893  1  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
008896  1  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
008899  1  A2 FD              LDX   #$FD              ; new stack pointer
00889B  1  9A                 TXS                     ; reset stack
00889C  1  A9 00              LDA   #$00              ; clear byte
00889E  1               ;*** fix p2: no longer necessary as the continue pointer is saved anyway
00889E  1               ;      STA   Cpntrh            ; clear continue pointer high byte
00889E  1  85 61              STA   Sufnxf            ; clear subscript/FNX flag
0088A0  1               LAB_14A6
0088A0  1  60                 RTS
0088A1  1               
0088A1  1               ; perform CLEAR
0088A1  1               
0088A1  1               LAB_CLEAR
0088A1  1  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
0088A3  1               
0088A3  1                                             ; else there was a following token (go do syntax error)
0088A3  1  60                 RTS
0088A4  1               
0088A4  1               ; perform LIST [n][-m]
0088A4  1               ; bigger, faster version (a _lot_ faster)
0088A4  1               
0088A4  1               LAB_LIST
0088A4  1  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
0088A6  1               
0088A6  1  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
0088A8  1               
0088A8  1  C9 C3              CMP   #TK_MINUS         ; compare with token for -
0088AA  1  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
0088AC  1               
0088AC  1                                             ; LIST [[n][-m]]
0088AC  1                                             ; this bit sets the n , if present, as the start and end
0088AC  1               LAB_14BD
0088AC  1  20 8B 8C           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0088AF  1  20 1F 88           JSR   LAB_SSLN          ; search BASIC for temp integer line number
0088B2  1                                             ; (pointer in Baslnl/Baslnh)
0088B2  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
0088B5  1  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
0088B7  1               
0088B7  1                                             ; this bit checks the - is present
0088B7  1  C9 C3              CMP   #TK_MINUS         ; compare with token for -
0088B9  1  D0 8D              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
0088BB  1               
0088BB  1                                             ; LIST [n]-m
0088BB  1                                             ; the - was there so set m as the end value
0088BB  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0088BE  1  20 8B 8C           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0088C1  1  D0 85              BNE   LAB_1460          ; exit if not ok
0088C3  1               
0088C3  1               LAB_14D4
0088C3  1  A5 11              LDA   Itempl            ; get temporary integer low byte
0088C5  1  05 12              ORA   Itemph            ; OR temporary integer high byte
0088C7  1  D0 06              BNE   LAB_14E2          ; branch if start set
0088C9  1               
0088C9  1  A9 FF              LDA   #$FF              ; set for -1
0088CB  1  85 11              STA   Itempl            ; set temporary integer low byte
0088CD  1  85 12              STA   Itemph            ; set temporary integer high byte
0088CF  1               LAB_14E2
0088CF  1  A0 01              LDY   #$01              ; set index for line
0088D1  1  84 60              STY   Oquote            ; clear open quote flag
0088D3  1  20 D4 8D           JSR   LAB_CRLF          ; print CR/LF
0088D6  1  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
0088D8  1                                             ; pointer initially set by search at LAB_14BD
0088D8  1  F0 3E              BEQ   LAB_152B          ; if null all done so exit
0088DA  1  20 40 8A           JSR   LAB_1629          ; do CRTL-C check vector
0088DD  1               
0088DD  1  C8                 INY                     ; increment index for line
0088DE  1  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
0088E0  1  AA                 TAX                     ; copy to X
0088E1  1  C8                 INY                     ; increment index
0088E2  1  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
0088E4  1  C5 12              CMP   Itemph            ; compare with temporary integer high byte
0088E6  1  D0 04              BNE   LAB_14FF          ; branch if no high byte match
0088E8  1               
0088E8  1  E4 11              CPX   Itempl            ; compare with temporary integer low byte
0088EA  1  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
0088EC  1               
0088EC  1               LAB_14FF                      ; else ..
0088EC  1  B0 2A              BCS   LAB_152B          ; if greater all done so exit
0088EE  1               
0088EE  1               LAB_1501
0088EE  1  84 97              STY   Tidx1             ; save index for line
0088F0  1  20 DD 9F           JSR   LAB_295E          ; print XA as unsigned integer
0088F3  1  A9 20              LDA   #$20              ; space is the next character
0088F5  1               LAB_1508
0088F5  1  A4 97              LDY   Tidx1             ; get index for line
0088F7  1  29 7F              AND   #$7F              ; mask top out bit of character
0088F9  1               LAB_150C
0088F9  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
0088FC  1  C9 22              CMP   #$22              ; was it " character
0088FE  1  D0 06              BNE   LAB_1519          ; branch if not
008900  1               
008900  1                                             ; we are either entering or leaving a pair of quotes
008900  1  A5 60              LDA   Oquote            ; get open quote flag
008902  1  49 FF              EOR   #$FF              ; toggle it
008904  1  85 60              STA   Oquote            ; save it back
008906  1               LAB_1519
008906  1  C8                 INY                     ; increment index
008907  1  B1 AA              LDA   (Baslnl),Y        ; get next byte
008909  1  D0 21              BNE   LAB_152E          ; branch if not [EOL] (go print character)
00890B  1  A8                 TAY                     ; else clear index
00890C  1  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00890E  1  AA                 TAX                     ; copy to X
00890F  1  C8                 INY                     ; increment index
008910  1  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
008912  1  86 AA              STX   Baslnl            ; set pointer to line low byte
008914  1  85 AB              STA   Baslnh            ; set pointer to line high byte
008916  1  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
008918  1                                             ; else ..
008918  1               LAB_152B
008918  1  60                 RTS
008919  1               
008919  1               .ifdef LOW_TOKENS
008919  1               LAB_152C
008919  1  C9 20              CMP   #$20
00891B  1  B0 DC              BCS   LAB_150C          ; not low token, go print it
00891D  1  A2 B8              LDX   #>LAB_KEYL        ; low token table address high byte
00891F  1  0A                 ASL                     ; *2
008920  1  0A                 ASL                     ; *4
008921  1  90 02              BCC   :+
008923  1  E8                 INX
008924  1  18                 CLC
008925  1  69 8D        :     ADC   #<LAB_KEYL        ; add low byte
008927  1  90 16              BCC   LAB_1530
008929  1  E8                 INX
00892A  1  80 13              BRA   LAB_1530          ; back to decoding
00892C  1               .endif
00892C  1               
00892C  1               LAB_152E
00892C  1               .ifdef LOW_TOKENS
00892C  1  10 EB              BPL   LAB_152C
00892E  1               .else
00892E  1                     BPL   LAB_150C          ; just go print it if not token byte
00892E  1               .endif
00892E  1                                             ; else was token byte so uncrunch it (maybe)
00892E  1  24 60              BIT   Oquote            ; test the open quote flag
008930  1  30 C7              BMI   LAB_150C          ; just go print character if open quote set
008932  1               
008932  1  A2 B8              LDX   #>LAB_KEYT        ; get table address high byte
008934  1  0A                 ASL                     ; *2
008935  1  0A                 ASL                     ; *4
008936  1  90 02              BCC   LAB_152F          ; branch if no carry
008938  1               
008938  1  E8                 INX                     ; else increment high byte
008939  1  18                 CLC                     ; clear carry for add
00893A  1               LAB_152F
00893A  1  69 DD              ADC   #<LAB_KEYT        ; add low byte
00893C  1  90 01              BCC   LAB_1530          ; branch if no carry
00893E  1               
00893E  1  E8                 INX                     ; else increment high byte
00893F  1               LAB_1530
00893F  1  85 73              STA   ut2_pl            ; save table pointer low byte
008941  1  86 74              STX   ut2_ph            ; save table pointer high byte
008943  1  84 97              STY   Tidx1             ; save index for line
008945  1  A0 00              LDY   #$00              ; clear index
008947  1  B1 73              LDA   (ut2_pl),Y        ; get length
008949  1  AA                 TAX                     ; copy length
00894A  1  C8                 INY                     ; increment index
00894B  1  B1 73              LDA   (ut2_pl),Y        ; get 1st character
00894D  1  CA                 DEX                     ; decrement length
00894E  1  F0 A5              BEQ   LAB_1508          ; if no more characters exit and print
008950  1               
008950  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
008953  1  C8                 INY                     ; increment index
008954  1  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
008956  1  48                 PHA                     ; save it for now
008957  1  C8                 INY                     ; increment index
008958  1  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
00895A  1  A0 00              LDY   #$00
00895C  1  85 74              STA   ut2_ph            ; save keyword pointer high byte
00895E  1  68                 PLA                     ; pull low byte
00895F  1  85 73              STA   ut2_pl            ; save keyword pointer low byte
008961  1               LAB_1540
008961  1  B1 73              LDA   (ut2_pl),Y        ; get character
008963  1  CA                 DEX                     ; decrement character count
008964  1  F0 8F              BEQ   LAB_1508          ; if last character exit and print
008966  1               
008966  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
008969  1  C8                 INY                     ; increment index
00896A  1  D0 F5              BNE   LAB_1540          ; loop for next character
00896C  1               
00896C  1               ; perform FOR
00896C  1               
00896C  1               LAB_FOR
00896C  1  A9 80              LDA   #$80              ; set FNX
00896E  1  85 61              STA   Sufnxf            ; set subscript/FNX flag
008970  1  20 EA 8C           JSR   LAB_LET           ; go do LET
008973  1  68                 PLA                     ; pull return address
008974  1  68                 PLA                     ; pull return address
008975  1  A9 10              LDA   #$10              ; we need 16d bytes !
008977  1  20 D1 84           JSR   LAB_1212          ; check room on stack for A bytes
00897A  1  20 DE 8B           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00897D  1  18                 CLC                     ; clear carry for add
00897E  1  98                 TYA                     ; copy index to A
00897F  1  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
008981  1  48                 PHA                     ; push onto stack
008982  1  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
008984  1  69 00              ADC   #$00              ; add carry
008986  1  48                 PHA                     ; push onto stack
008987  1  A5 88              LDA   Clineh            ; get current line high byte
008989  1  48                 PHA                     ; push onto stack
00898A  1  A5 87              LDA   Clinel            ; get current line low byte
00898C  1  48                 PHA                     ; push onto stack
00898D  1  A9 B8              LDA   #TK_TO            ; get "TO" token
00898F  1  20 40 91           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
008992  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
008995  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
008998  1                                             ; else do type mismatch
008998  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00899A  1  09 7F              ORA   #$7F              ; set all non sign bits
00899C  1  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
00899E  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
0089A0  1  A9 AB              LDA   #<LAB_159F        ; set return address low byte
0089A2  1  A0 89              LDY   #>LAB_159F        ; set return address high byte
0089A4  1  85 71              STA   ut1_pl            ; save return address low byte
0089A6  1  84 72              STY   ut1_ph            ; save return address high byte
0089A8  1  4C D3 90           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
0089AB  1               
0089AB  1               LAB_159F
0089AB  1  A9 32              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
0089AD  1  A0 B4              LDY   #>LAB_259C        ; set 1 pointer high addr
0089AF  1  20 D8 9D           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
0089B2  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
0089B5  1  C9 BD              CMP   #TK_STEP          ; compare with STEP token
0089B7  1  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
0089B9  1               
0089B9  1                                             ;.was step so ..
0089B9  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0089BC  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0089BF  1                                             ; else do type mismatch
0089BF  1               LAB_15B3
0089BF  1  20 44 9E           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
0089C2  1  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
0089C4  1                                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
0089C4  1                                             ; compare the FOR value and the TO value and return +1 if
0089C4  1                                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
0089C4  1                                             ; here (+/-1) is then compared to that result and if they
0089C4  1                                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
0089C4  1                                             ; the loop is done
0089C4  1  20 C8 90           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
0089C7  1  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
0089C9  1  48                 PHA                     ; push on stack
0089CA  1  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
0089CC  1  48                 PHA                     ; push on stack
0089CD  1  A9 81              LDA   #TK_FOR           ; get FOR token
0089CF  1  48                 PHA                     ; push on stack
0089D0  1               
0089D0  1               ; interpreter inner loop
0089D0  1               
0089D0  1               LAB_15C2
0089D0  1  20 40 8A           JSR   LAB_1629          ; do CRTL-C check vector
0089D3  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0089D5  1  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
0089D7  1               
0089D7  1  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
0089D9  1                                             ; ($00xx for RUN from immediate mode)
0089D9  1  E8                 INX                     ; increment it (now $00 if immediate mode)
0089DA  1               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
0089DA  1               ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
0089DA  1               
0089DA  1  85 8B              STA   Cpntrl            ; save continue pointer low byte
0089DC  1  84 8C              STY   Cpntrh            ; save continue pointer high byte
0089DE  1               LAB_15D1
0089DE  1  A0 00              LDY   #$00              ; clear index
0089E0  1  B1 C3              LDA   (Bpntrl),Y        ; get next byte
0089E2  1  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
0089E4  1               
0089E4  1  C9 3A              CMP   #':'              ; compare with ":"
0089E6  1  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
0089E8  1               
0089E8  1               LAB_15D9
0089E8  1  4C 51 91           JMP   LAB_SNER          ; else syntax error then warm start
0089EB  1               
0089EB  1                                             ; have reached [EOL]
0089EB  1               LAB_15DC
0089EB  1  A0 02              LDY   #$02              ; set index
0089ED  1  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
0089EF  1  18                 CLC                     ; clear carry for no "BREAK" message
0089F0  1  F0 6A              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
0089F2  1                                             ; marker)
0089F2  1               
0089F2  1  C8                 INY                     ; increment index
0089F3  1  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
0089F5  1  85 87              STA   Clinel            ; save current line low byte
0089F7  1  C8                 INY                     ; increment index
0089F8  1  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
0089FA  1  85 88              STA   Clineh            ; save current line high byte
0089FC  1  98                 TYA                     ; A now = 4
0089FD  1  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
0089FF  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008A01  1  90 02              BCC   LAB_15F6          ; branch if no overflow
008A03  1               
008A03  1  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
008A05  1               LAB_15F6
008A05  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008A08  1               
008A08  1               LAB_15F9
008A08  1  20 0E 8A           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
008A0B  1               
008A0B  1               LAB_15FC
008A0B  1  4C D0 89           JMP   LAB_15C2          ; loop
008A0E  1               
008A0E  1               ; interpret BASIC code from (Bpntrl)
008A0E  1               
008A0E  1               LAB_15FF
008A0E  1  F0 68              BEQ   LAB_1628          ; exit if zero [EOL]
008A10  1               
008A10  1               LAB_1602
008A10  1               .ifdef LOW_TOKENS
008A10  1  C9 20              CMP   #$20
008A12  1  90 24              BCC   LAB_1620          ; have low token
008A14  1               .endif
008A14  1  0A                 ASL                     ; *2 bytes per vector and normalise token
008A15  1  B0 11              BCS   LAB_1609          ; branch if was token
008A17  1               .ifdef APPLE2
008A17  1  C9 4E              CMP   #$4E              ; ASCII ' * 2
008A19  1  D0 03              BNE   :+
008A1B  1  4C 62 8C           JMP   LAB_REM           ; abbreviated REM
008A1E  1  C9 44        :     CMP   #$44              ; ASCII " * 2
008A20  1  D0 03              BNE   :+
008A22  1  4C 8D 8D           JMP   LAB_1831          ; abbreviated PRINT
008A25  1               :
008A25  1               .endif
008A25  1  4C EA 8C           JMP   LAB_LET           ; else go do implied LET
008A28  1               
008A28  1               LAB_1609
008A28  1               .ifdef APPLE2
008A28  1  C9 6C              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
008A2A  1               .else
008A2A  1                     CMP   #[TK_TAB-$80]*2   ; compare normalised token * 2 with TAB
008A2A  1               .endif
008A2A  1  B0 BC              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
008A2C  1                                             ; only tokens before TAB can start a line
008A2C  1  A8                 TAY                     ; copy to index
008A2D  1  B9 82 B4           LDA   LAB_CTBL+1,Y      ; get vector high byte
008A30  1  48                 PHA                     ; onto stack
008A31  1  B9 81 B4           LDA   LAB_CTBL,Y        ; get vector low byte
008A34  1  48                 PHA                     ; onto stack
008A35  1  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
008A38  1                                             ; then "return" to vector
008A38  1               
008A38  1               .ifdef LOW_TOKENS
008A38  1               ; 65C02 dispatch
008A38  1               LAB_1620
008A38  1  0A                 ASL
008A39  1  AA                 TAX
008A3A  1  20 BC 00           JSR   LAB_IGBY
008A3D  1  7C 59 B4           JMP   (LAB_LTBL,X)
008A40  1               .endif
008A40  1               
008A40  1               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
008A40  1               ; key press is detected.
008A40  1               LAB_1629
008A40  1  6C rr rr           JMP   (VEC_CC)          ; ctrl c check vector
008A43  1               
008A43  1               ; if there was a key press it gets back here ..
008A43  1               
008A43  1               LAB_1636
008A43  1  C9 03              CMP   #$03              ; compare with CTRL-C
008A45  1               
008A45  1               ; perform STOP
008A45  1               
008A45  1               LAB_STOP
008A45  1  B0 01              BCS   LAB_163B          ; branch if token follows STOP
008A47  1                                             ; else just END
008A47  1               ; END
008A47  1               
008A47  1               LAB_END
008A47  1  18                 CLC                     ; clear the carry, indicate a normal program end
008A48  1               LAB_163B
008A48  1  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
008A4A  1               
008A4A  1  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
008A4C  1               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
008A4C  1               ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
008A4C  1               ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
008A4C  1               ;                              ; (can't continue in immediate mode)
008A4C  1               ;                              ; else ..
008A4C  1               ;      EOR   #>Ibuffs          ; correct the bits
008A4C  1  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
008A4E  1  84 8B              STY   Cpntrl            ; save continue pointer low byte
008A50  1  85 8C              STA   Cpntrh            ; save continue pointer high byte
008A52  1               LAB_1647
008A52  1  A5 87              LDA   Clinel            ; get current line low byte
008A54  1  A4 88              LDY   Clineh            ; get current line high byte
008A56  1  85 89              STA   Blinel            ; save break line low byte
008A58  1  84 8A              STY   Blineh            ; save break line high byte
008A5A  1               LAB_164F
008A5A  1  68                 PLA                     ; pull return address low
008A5B  1  68                 PLA                     ; pull return address high
008A5C  1               LAB_1651
008A5C  1  90 07              BCC   LAB_165E          ; if was program end just do warm start
008A5E  1               
008A5E  1                                             ; else ..
008A5E  1  A9 EC              LDA   #<LAB_BMSG        ; point to "Break" low byte
008A60  1  A0 BC              LDY   #>LAB_BMSG        ; point to "Break" high byte
008A62  1  4C 8A 85           JMP   LAB_1269          ; print "Break" and do warm start
008A65  1               
008A65  1               LAB_165E
008A65  1  4C 95 85           JMP   LAB_1274          ; go do warm start
008A68  1               
008A68  1               ; perform RESTORE
008A68  1               
008A68  1               LAB_RESTORE
008A68  1  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
008A6A  1               
008A6A  1               LAB_161A
008A6A  1  38                 SEC                     ; set carry for subtract
008A6B  1  A5 79              LDA   Smeml             ; get start of mem low byte
008A6D  1  E9 01              SBC   #$01              ; -1
008A6F  1  A4 7A              LDY   Smemh             ; get start of mem high byte
008A71  1  B0 01              BCS   LAB_1624          ; branch if no underflow
008A73  1               
008A73  1               LAB_uflow
008A73  1  88                 DEY                     ; else decrement high byte
008A74  1               LAB_1624
008A74  1  85 8F              STA   Dptrl             ; save DATA pointer low byte
008A76  1  84 90              STY   Dptrh             ; save DATA pointer high byte
008A78  1               LAB_1628
008A78  1  60                 RTS
008A79  1               
008A79  1                                             ; is RESTORE n
008A79  1               LAB_RESTOREn
008A79  1  20 8B 8C           JSR   LAB_GFPN          ; get fixed-point number into temp integer
008A7C  1  20 E1 8B           JSR   LAB_SNBL          ; scan for next BASIC line
008A7F  1  A5 88              LDA   Clineh            ; get current line high byte
008A81  1  C5 12              CMP   Itemph            ; compare with temporary integer high byte
008A83  1  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
008A85  1               
008A85  1  98                 TYA                     ; else copy line index to A
008A86  1  38                 SEC                     ; set carry (+1)
008A87  1  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
008A89  1  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
008A8B  1  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
008A8D  1               
008A8D  1  E8                 INX                     ; increment high byte
008A8E  1  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
008A90  1               
008A90  1               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
008A90  1               
008A90  1               LAB_reset_search
008A90  1  A5 79              LDA   Smeml             ; get start of mem low byte
008A92  1  A6 7A              LDX   Smemh             ; get start of mem high byte
008A94  1               
008A94  1               ; search for line # in temp (Itempl/Itemph) from (AX)
008A94  1               
008A94  1               LAB_go_search
008A94  1               
008A94  1  20 23 88           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
008A97  1  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
008A99  1               
008A99  1  4C 9B 8B           JMP   LAB_16F7          ; else go do "Undefined statement" error
008A9C  1               
008A9C  1               LAB_line_found
008A9C  1                                             ; carry already set for subtract
008A9C  1  A5 AA              LDA   Baslnl            ; get pointer low byte
008A9E  1  E9 01              SBC   #$01              ; -1
008AA0  1  A4 AB              LDY   Baslnh            ; get pointer high byte
008AA2  1  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
008AA4  1               
008AA4  1  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
008AA6  1                                             ; return (branch always)
008AA6  1               
008AA6  1               ; perform NULL
008AA6  1               
008AA6  1               LAB_NULL
008AA6  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter
008AA9  1  86 0D              STX   Nullct            ; save new NULL count
008AAB  1               LAB_167A
008AAB  1  60                 RTS
008AAC  1               
008AAC  1               ; perform CONT
008AAC  1               
008AAC  1               LAB_CONT
008AAC  1  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
008AAE  1               
008AAE  1  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
008AB0  1  C0 02              CPY   #>Ibuffs          ; *** fix p2: test direct mode
008AB2  1  D0 05              BNE   LAB_166C          ; go do continue if we can
008AB4  1               
008AB4  1  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
008AB6  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
008AB9  1               
008AB9  1                                             ; we can continue so ..
008AB9  1               LAB_166C
008AB9  1               .ifndef NO_INT
008AB9  1                     LDA   #TK_ON            ; set token for ON
008AB9  1                     JSR   LAB_IRQ           ; set IRQ flags
008AB9  1                     LDA   #TK_ON            ; set token for ON
008AB9  1                     JSR   LAB_NMI           ; set NMI flags
008AB9  1               .endif
008AB9  1  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
008ABB  1  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
008ABD  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008ABF  1  A5 89              LDA   Blinel            ; get break line low byte
008AC1  1  A4 8A              LDY   Blineh            ; get break line high byte
008AC3  1  85 87              STA   Clinel            ; set current line low byte
008AC5  1  84 88              STY   Clineh            ; set current line high byte
008AC7  1  60                 RTS
008AC8  1               
008AC8  1               ; perform RUN
008AC8  1               
008AC8  1               LAB_RUN
008AC8  1  D0 03              BNE   LAB_1696          ; branch if RUN n
008ACA  1  4C 68 88           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
008ACD  1                                             ; return
008ACD  1               
008ACD  1               ; does RUN n
008ACD  1               
008ACD  1               LAB_1696
008ACD  1               .ifdef APPLE2
008ACD  1  C9 30              CMP   #$30
008ACF  1  90 04              BCC   RUN_FILE
008AD1  1  C9 40              CMP   #$40
008AD3  1  90 03              BCC   RUN_LINE
008AD5  1               RUN_FILE
008AD5  1  4C A0 B1           JMP   V_LOAD_AND_RUN
008AD8  1               RUN_LINE
008AD8  1               .endif
008AD8  1  20 75 88           JSR   LAB_147A          ; go do "CLEAR"
008ADB  1  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
008ADD  1               
008ADD  1               ; perform DO
008ADD  1               
008ADD  1               LAB_DO
008ADD  1  A9 05              LDA   #$05              ; need 5 bytes for DO
008ADF  1  20 D1 84           JSR   LAB_1212          ; check room on stack for A bytes
008AE2  1  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
008AE4  1  48                 PHA                     ; push on stack
008AE5  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
008AE7  1  48                 PHA                     ; push on stack
008AE8  1  A5 88              LDA   Clineh            ; get current line high byte
008AEA  1  48                 PHA                     ; push on stack
008AEB  1  A5 87              LDA   Clinel            ; get current line low byte
008AED  1  48                 PHA                     ; push on stack
008AEE  1  A9 9B              LDA   #TK_DO            ; token for DO
008AF0  1  48                 PHA                     ; push on stack
008AF1  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008AF4  1  4C D0 89           JMP   LAB_15C2          ; go do interpreter inner loop
008AF7  1               
008AF7  1               ; perform GOSUB
008AF7  1               
008AF7  1               LAB_GOSUB
008AF7  1  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
008AF9  1  20 D1 84           JSR   LAB_1212          ; check room on stack for A bytes
008AFC  1  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
008AFE  1  48                 PHA                     ; push on stack
008AFF  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
008B01  1  48                 PHA                     ; push on stack
008B02  1  A5 88              LDA   Clineh            ; get current line high byte
008B04  1  48                 PHA                     ; push on stack
008B05  1  A5 87              LDA   Clinel            ; get current line low byte
008B07  1  48                 PHA                     ; push on stack
008B08  1  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
008B0A  1  48                 PHA                     ; push on stack
008B0B  1               LAB_16B0
008B0B  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008B0E  1  20 14 8B           JSR   LAB_GOTO          ; perform GOTO n
008B11  1  4C D0 89           JMP   LAB_15C2          ; go do interpreter inner loop
008B14  1                                             ; (can't RTS, we used the stack!)
008B14  1               
008B14  1               ; perform GOTO
008B14  1               
008B14  1               LAB_GOTO
008B14  1  20 8B 8C           JSR   LAB_GFPN          ; get fixed-point number into temp integer
008B17  1  20 E1 8B           JSR   LAB_SNBL          ; scan for next BASIC line
008B1A  1  A5 88              LDA   Clineh            ; get current line high byte
008B1C  1  C5 12              CMP   Itemph            ; compare with temporary integer high byte
008B1E  1  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
008B20  1               
008B20  1  98                 TYA                     ; else copy line index to A
008B21  1  38                 SEC                     ; set carry (+1)
008B22  1  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
008B24  1  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
008B26  1  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
008B28  1               
008B28  1  E8                 INX                     ; increment high byte
008B29  1  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
008B2B  1               
008B2B  1               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
008B2B  1               
008B2B  1               LAB_16D0
008B2B  1  A5 79              LDA   Smeml             ; get start of mem low byte
008B2D  1  A6 7A              LDX   Smemh             ; get start of mem high byte
008B2F  1               
008B2F  1               ; search for line # in temp (Itempl/Itemph) from (AX)
008B2F  1               
008B2F  1               LAB_16D4
008B2F  1  20 23 88           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
008B32  1  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
008B34  1                                             ; (unspecified statement)
008B34  1               
008B34  1                                             ; carry already set for subtract
008B34  1  A5 AA              LDA   Baslnl            ; get pointer low byte
008B36  1  E9 01              SBC   #$01              ; -1
008B38  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008B3A  1  A5 AB              LDA   Baslnh            ; get pointer high byte
008B3C  1  E9 00              SBC   #$00              ; subtract carry
008B3E  1  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
008B40  1               LAB_16E5
008B40  1  60                 RTS
008B41  1               
008B41  1               LAB_DONOK
008B41  1  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
008B43  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
008B46  1               
008B46  1               ; perform LOOP
008B46  1               
008B46  1               LAB_LOOP
008B46  1  A8                 TAY                     ; save following token
008B47  1  BA                 TSX                     ; copy stack pointer
008B48  1  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
008B4B  1  C9 9B              CMP   #TK_DO            ; compare with DO token
008B4D  1  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
008B4F  1               
008B4F  1  E8                 INX                     ; dump calling routine return address
008B50  1  E8                 INX                     ; dump calling routine return address
008B51  1  9A                 TXS                     ; correct stack
008B52  1  98                 TYA                     ; get saved following token back
008B53  1  F0 20              BEQ   LoopAlways        ; if no following token loop forever
008B55  1                                             ; (stack pointer in X)
008B55  1               
008B55  1  C9 3A              CMP   #':'              ; could be ':'
008B57  1  F0 1C              BEQ   LoopAlways        ; if :... loop forever
008B59  1               
008B59  1  E9 BE              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
008B5B  1  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
008B5C  1  F0 04              BEQ   DoRest            ; branch if was UNTIL
008B5E  1               
008B5E  1  CA                 DEX                     ; decrement result
008B5F  1  D0 7A              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
008B61  1                                             ; only if the token was WHILE will this fail
008B61  1               
008B61  1  CA                 DEX                     ; set invert result byte
008B62  1               DoRest
008B62  1  86 98              STX   Frnxth            ; save invert result byte
008B64  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008B67  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
008B6A  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
008B6C  1  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
008B6E  1               
008B6E  1  A9 FF              LDA   #$FF              ; else set all bits
008B70  1               DoCmp
008B70  1  BA                 TSX                     ; copy stack pointer
008B71  1  45 98              EOR   Frnxth            ; EOR with invert byte
008B73  1  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
008B75  1               
008B75  1                                             ; loop condition wasn't met so do it again
008B75  1               LoopAlways
008B75  1  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
008B78  1  85 87              STA   Clinel            ; save current line low byte
008B7A  1  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
008B7D  1  85 88              STA   Clineh            ; save current line high byte
008B7F  1  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
008B82  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008B84  1  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
008B87  1  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
008B89  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008B8C  1  4C D0 89           JMP   LAB_15C2          ; go do interpreter inner loop
008B8F  1               
008B8F  1                                             ; clear stack and back to interpreter loop
008B8F  1               LoopDone
008B8F  1  E8                 INX                     ; dump DO token
008B90  1  E8                 INX                     ; dump current line low byte
008B91  1  E8                 INX                     ; dump current line high byte
008B92  1  E8                 INX                     ; dump BASIC execute pointer low byte
008B93  1  E8                 INX                     ; dump BASIC execute pointer high byte
008B94  1  9A                 TXS                     ; correct stack
008B95  1  4C CD 8B           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
008B98  1               
008B98  1               ; do the return without gosub error
008B98  1               
008B98  1               LAB_16F4
008B98  1  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
008B9A  1  2C                 .byte $2C               ; makes next line BIT LAB_0EA2
008B9B  1               
008B9B  1               LAB_16F7                      ; do undefined statement error
008B9B  1  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
008B9D  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
008BA0  1               
008BA0  1               .ifdef APPLE2
008BA0  1               LAB_POP
008BA0  1  D0 9E              BNE   LAB_16E5
008BA2  1  38                 SEC                     ; flag POP
008BA3  1  B0 0D              BCS   LAB_16E8
008BA5  1               DO_POP
008BA5  1  68                 PLA                     ; drop remaining crap (current line high)
008BA6  1  68                 PLA                     ; (exec ptr low)
008BA7  1  68                 PLA                     ; (exec ptr high)
008BA8  1  A5 12              LDA   Itemph            ; restore caller adddress
008BAA  1  48                 PHA
008BAB  1  A5 11              LDA   Itempl
008BAD  1  48                 PHA
008BAE  1  60                 RTS                     ; and carry on
008BAF  1               .endif
008BAF  1               
008BAF  1               ; perform RETURN
008BAF  1               
008BAF  1               LAB_RETURN
008BAF  1  D0 8F              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
008BB1  1               .ifdef APPLE2
008BB1  1  18                 CLC                     ; flag RETURN
008BB2  1               .endif
008BB2  1               
008BB2  1               LAB_16E8
008BB2  1  68                 PLA                     ; dump calling routine return address
008BB3  1               .ifdef APPLE2
008BB3  1  85 11              STA   Itempl            ; but save in case POP
008BB5  1               .endif
008BB5  1  68                 PLA                     ; dump calling routine return address
008BB6  1               .ifdef APPLE2
008BB6  1  85 12              STA   Itemph            ; but save in case POP
008BB8  1               .endif
008BB8  1  68                 PLA                     ; pull token
008BB9  1               .ifdef APPLE2
008BB9  1  08                 PHP                     ; save status
008BBA  1               .endif
008BBA  1  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
008BBC  1  D0 DA              BNE   LAB_16F4          ; branch if no matching GOSUB
008BBE  1               .ifdef APPLE2
008BBE  1  28                 PLP                     ; restore status (C flag important)
008BBF  1               .endif
008BBF  1               
008BBF  1               LAB_16FF
008BBF  1  68                 PLA                     ; pull current line low byte
008BC0  1               .ifdef APPLE2
008BC0  1  B0 E3              BCS   DO_POP
008BC2  1               .endif
008BC2  1  85 87              STA   Clinel            ; save current line low byte
008BC4  1  68                 PLA                     ; pull current line high byte
008BC5  1  85 88              STA   Clineh            ; save current line high byte
008BC7  1  68                 PLA                     ; pull BASIC execute pointer low byte
008BC8  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008BCA  1  68                 PLA                     ; pull BASIC execute pointer high byte
008BCB  1  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
008BCD  1               
008BCD  1                                             ; now do the DATA statement as we could be returning into
008BCD  1                                             ; the middle of an ON <var> GOSUB n,m,p,q line
008BCD  1                                             ; (the return address used by the DATA statement is the one
008BCD  1                                             ; pushed before the GOSUB was executed!)
008BCD  1               
008BCD  1               ; perform DATA
008BCD  1               
008BCD  1               LAB_DATA
008BCD  1  20 DE 8B           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
008BD0  1               
008BD0  1                                             ; set BASIC execute pointer
008BD0  1               LAB_170F
008BD0  1  98                 TYA                     ; copy index to A
008BD1  1  18                 CLC                     ; clear carry for add
008BD2  1  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
008BD4  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008BD6  1  90 02              BCC   LAB_1719          ; skip next if no carry
008BD8  1               
008BD8  1  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
008BDA  1               LAB_1719
008BDA  1  60                 RTS
008BDB  1               
008BDB  1               LAB_16FC
008BDB  1  4C 51 91           JMP   LAB_SNER          ; do syntax error then warm start
008BDE  1               
008BDE  1               ; scan for next BASIC statement ([:] or [EOL])
008BDE  1               ; returns Y as index to [:] or [EOL]
008BDE  1               
008BDE  1               LAB_SNBS
008BDE  1  A2 3A              LDX   #':'              ; set look for character = ":"
008BE0  1  2C                 .byte $2C               ; makes next line BIT $00A2
008BE1  1               
008BE1  1               ; scan for next BASIC line
008BE1  1               ; returns Y as index to [EOL]
008BE1  1               
008BE1  1               LAB_SNBL
008BE1  1  A2 00              LDX   #$00              ; set alt search character = [EOL]
008BE3  1  A0 00              LDY   #$00              ; set search character = [EOL]
008BE5  1  84 5C              STY   Asrch             ; store search character
008BE7  1               LAB_1725
008BE7  1  8A                 TXA                     ; get alt search character
008BE8  1  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
008BEA  1  85 5C              STA   Asrch             ; save swapped search character
008BEC  1               LAB_172D
008BEC  1  B1 C3              LDA   (Bpntrl),Y        ; get next byte
008BEE  1  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
008BF0  1               
008BF0  1  C5 5C              CMP   Asrch             ; compare with search character
008BF2  1  F0 E6              BEQ   LAB_1719          ; exit if found
008BF4  1               
008BF4  1  C8                 INY                     ; increment index
008BF5  1  C9 22              CMP   #$22              ; compare current character with open quote
008BF7  1  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
008BF9  1               
008BF9  1  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
008BFB  1               
008BFB  1               ; perform IF
008BFB  1               
008BFB  1               LAB_IF
008BFB  1  20 30 90           JSR   LAB_EVEX          ; evaluate the expression
008BFE  1               .ifdef APPLE2
008BFE  1               LAB_TRYTHEN
008BFE  1               .endif
008BFE  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008C01  1  C9 BB              CMP   #TK_THEN          ; compare with THEN token
008C03  1  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
008C05  1               
008C05  1                                             ; wasn't IF .. THEN so must be IF .. GOTO
008C05  1  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
008C07  1  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
008C09  1               
008C09  1  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
008C0B  1  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
008C0D  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008C10  1  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
008C12  1               
008C12  1  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
008C14  1  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
008C16  1               LAB_174B
008C16  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
008C18  1  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
008C1A  1               
008C1A  1  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
008C1D  1  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
008C1F  1               
008C1F  1               LAB_174C
008C1F  1  4C 14 8B           JMP   LAB_GOTO          ; else was numeric so do GOTO n
008C22  1               
008C22  1                                             ; is var or keyword
008C22  1               LAB_174D
008C22  1  C9 8E              CMP   #TK_RETURN        ; compare the byte with the token for RETURN
008C24  1  D0 03              BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
008C26  1                                             ; and return to this code to process any following code
008C26  1               
008C26  1  4C 10 8A           JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
008C29  1                                             ; but don't return here
008C29  1               
008C29  1               LAB_174G
008C29  1  20 0E 8A           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
008C2C  1               
008C2C  1               ; the IF was executed and there may be a following ELSE so the code needs to return
008C2C  1               ; here to check and ignore the ELSE if present
008C2C  1  A0 00              LDY   #$00              ; clear the index
008C2E  1  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
008C30  1  C9 B7              CMP   #TK_ELSE          ; compare it with the token for ELSE
008C32  1               .ifdef APPLE2
008C32  1  D0 03              BNE   :+
008C34  1  4C CD 8B           JMP   LAB_DATA
008C37  1  60           :     RTS
008C38  1               .else
008C38  1                     BEQ   LAB_DATA          ; if ELSE ignore the following statement
008C38  1               
008C38  1               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
008C38  1               ; following ELSE will, correctly, cause a syntax error
008C38  1               
008C38  1                     RTS                     ; else return to the interpreter inner loop
008C38  1               .endif
008C38  1               
008C38  1               ; perform ELSE after IF
008C38  1               
008C38  1               LAB_174E
008C38  1  A0 00              LDY   #$00              ; clear the BASIC byte index
008C3A  1  A2 01              LDX   #$01              ; clear the nesting depth
008C3C  1               LAB_1750
008C3C  1  C8                 INY                     ; increment the BASIC byte index
008C3D  1  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
008C3F  1  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
008C41  1               
008C41  1  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
008C43  1  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
008C45  1               
008C45  1  E8                 INX                     ; else increment the nesting depth ..
008C46  1  D0 F4              BNE   LAB_1750          ; .. and continue looking
008C48  1               
008C48  1               LAB_1752
008C48  1  C9 B7              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
008C4A  1  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
008C4C  1               
008C4C  1  CA                 DEX                     ; was ELSE so decrement the nesting depth
008C4D  1  D0 ED              BNE   LAB_1750          ; loop if still nested
008C4F  1               
008C4F  1  C8                 INY                     ; increment the BASIC byte index past the ELSE
008C50  1               
008C50  1               ; found the matching ELSE, now do <{n|statement}>
008C50  1               
008C50  1               LAB_1753
008C50  1  98                 TYA                     ; else copy line index to A
008C51  1  18                 CLC                     ; clear carry for add
008C52  1  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
008C54  1  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
008C56  1  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
008C58  1               
008C58  1  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
008C5A  1               LAB_1754
008C5A  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008C5D  1  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
008C5F  1                                             ; the code will return to the interpreter loop at the
008C5F  1                                             ; tail end of the GOTO <n>
008C5F  1               
008C5F  1  4C 0E 8A           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
008C62  1                                             ; the code will return to the interpreter loop at the
008C62  1                                             ; tail end of the <statement>
008C62  1               
008C62  1               ; perform REM, skip (rest of) line
008C62  1               
008C62  1               LAB_REM
008C62  1  20 E1 8B           JSR   LAB_SNBL          ; scan for next BASIC line
008C65  1  4C D0 8B           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
008C68  1               
008C68  1               LAB_16FD
008C68  1  4C 51 91           JMP   LAB_SNER          ; do syntax error then warm start
008C6B  1               
008C6B  1               ; perform ON
008C6B  1               
008C6B  1               LAB_ON
008C6B  1               .ifndef NO_INT
008C6B  1                     CMP   #TK_IRQ           ; was it IRQ token ?
008C6B  1                     BNE   LAB_NOIN          ; if not go check NMI
008C6B  1               
008C6B  1                     JMP   LAB_SIRQ          ; else go set-up IRQ
008C6B  1               
008C6B  1               LAB_NOIN
008C6B  1                     CMP   #TK_NMI           ; was it NMI token ?
008C6B  1                     BNE   LAB_NONM          ; if not go do normal ON command
008C6B  1               
008C6B  1                     JMP   LAB_SNMI          ; else go set-up NMI
008C6B  1               .endif
008C6B  1               LAB_NONM
008C6B  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter
008C6E  1  48                 PHA                     ; push GOTO/GOSUB token
008C6F  1  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
008C71  1  F0 04              BEQ   LAB_176B          ; branch if GOSUB
008C73  1               
008C73  1  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
008C75  1               LAB_1767
008C75  1  D0 F1              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
008C77  1               
008C77  1               
008C77  1               ; next character was GOTO or GOSUB
008C77  1               
008C77  1               LAB_176B
008C77  1  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
008C79  1  D0 04              BNE   LAB_1773          ; branch if not zero
008C7B  1               
008C7B  1  68                 PLA                     ; pull GOTO/GOSUB token
008C7C  1  4C 10 8A           JMP   LAB_1602          ; go execute it
008C7F  1               
008C7F  1               LAB_1773
008C7F  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008C82  1  20 8B 8C           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
008C85  1                                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
008C85  1                                             ; just BNE LAB_176B for the loop. should be quicker ..
008C85  1                                             ; no we can't, what if we meet a colon or [EOL]?)
008C85  1  C9 2C              CMP   #$2C              ; compare next character with ","
008C87  1  F0 EE              BEQ   LAB_176B          ; loop if ","
008C89  1               
008C89  1               LAB_177E
008C89  1  68                 PLA                     ; else pull keyword token (run out of options)
008C8A  1                                             ; also dump +/-1 pointer low byte and exit
008C8A  1               LAB_177F
008C8A  1  60                 RTS
008C8B  1               
008C8B  1               ; takes n * 106 + 11 cycles where n is the number of digits
008C8B  1               
008C8B  1               ; get fixed-point number into temp integer
008C8B  1               
008C8B  1               LAB_GFPN
008C8B  1  A2 00              LDX   #$00              ; clear reg
008C8D  1  86 11              STX   Itempl            ; clear temporary integer low byte
008C8F  1               LAB_1785
008C8F  1  86 12              STX   Itemph            ; save temporary integer high byte
008C91  1  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
008C93  1                                             ; not 0-9
008C93  1               
008C93  1  E0 19              CPX   #$19              ; compare high byte with $19
008C95  1  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
008C96  1  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
008C98  1                                             ; bit does *$0A, = 64000, compare at target will fail
008C98  1                                             ; and do syntax error
008C98  1               
008C98  1  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
008C9A  1  A8                 TAY                     ; copy binary digit
008C9B  1  A5 11              LDA   Itempl            ; get temporary integer low byte
008C9D  1  0A                 ASL                     ; *2 low byte
008C9E  1  26 12              ROL   Itemph            ; *2 high byte
008CA0  1  0A                 ASL                     ; *2 low byte
008CA1  1  26 12              ROL   Itemph            ; *2 high byte, *4
008CA3  1  65 11              ADC   Itempl            ; + low byte, *5
008CA5  1  85 11              STA   Itempl            ; save it
008CA7  1  8A                 TXA                     ; get high byte copy to A
008CA8  1  65 12              ADC   Itemph            ; + high byte, *5
008CAA  1  06 11              ASL   Itempl            ; *2 low byte, *10d
008CAC  1  2A                 ROL                     ; *2 high byte, *10d
008CAD  1  AA                 TAX                     ; copy high byte back to X
008CAE  1  98                 TYA                     ; get binary digit back
008CAF  1  65 11              ADC   Itempl            ; add number low byte
008CB1  1  85 11              STA   Itempl            ; save number low byte
008CB3  1  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
008CB5  1               
008CB5  1  E8                 INX                     ; else increment high byte
008CB6  1               LAB_17B3
008CB6  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008CB9  1  4C 8F 8C           JMP   LAB_1785          ; loop for next character
008CBC  1               
008CBC  1               ; perform DEC
008CBC  1               
008CBC  1               LAB_DEC
008CBC  1  A9 36              LDA   #<LAB_2AFD        ; set -1 pointer low byte
008CBE  1  2C                 .byte $2C               ; BIT abs to skip the LDA below
008CBF  1               
008CBF  1               ; perform INC
008CBF  1               
008CBF  1               LAB_INC
008CBF  1  A9 32              LDA   #<LAB_259C        ; set 1 pointer low byte
008CC1  1               LAB_17B5
008CC1  1  48                 PHA                     ; save +/-1 pointer low byte
008CC2  1               LAB_17B7
008CC2  1  20 F9 92           JSR   LAB_GVAR          ; get var address
008CC5  1  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
008CC7  1  30 1E              BMI   IncrErr           ; exit if string
008CC9  1               
008CC9  1  85 97              STA   Lvarpl            ; save var address low byte
008CCB  1  84 98              STY   Lvarph            ; save var address high byte
008CCD  1  20 D8 9D           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
008CD0  1  68                 PLA                     ; get +/-1 pointer low byte
008CD1  1  48                 PHA                     ; save +/-1 pointer low byte
008CD2  1  A0 B4              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
008CD4  1  20 19 9B           JSR   LAB_246C          ; add (AY) to FAC1
008CD7  1  20 FE 9D           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
008CDA  1               
008CDA  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008CDD  1  C9 2C              CMP   #','              ; compare with ","
008CDF  1  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
008CE1  1               
008CE1  1                                             ; was "," so another INCR variable to do
008CE1  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008CE4  1  4C C2 8C           JMP   LAB_17B7          ; go do next var
008CE7  1               
008CE7  1               IncrErr
008CE7  1  4C 2B 90           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
008CEA  1               
008CEA  1               ; perform LET
008CEA  1               
008CEA  1               LAB_LET
008CEA  1  20 F9 92           JSR   LAB_GVAR          ; get var address
008CED  1  85 97              STA   Lvarpl            ; save var address low byte
008CEF  1  84 98              STY   Lvarph            ; save var address high byte
008CF1  1  A9 CD              LDA   #TK_EQUAL         ; get = token
008CF3  1  20 40 91           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
008CF6  1  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
008CF8  1  48                 PHA                     ; push data type flag
008CF9  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
008CFC  1  68                 PLA                     ; pop data type flag
008CFD  1  2A                 ROL                     ; set carry if type = string
008CFE  1  20 22 90           JSR   LAB_CKTM          ; type match check, set C for string
008D01  1  D0 03              BNE   LAB_17D5          ; branch if string
008D03  1               
008D03  1  4C FE 9D           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
008D06  1               
008D06  1               ; string LET
008D06  1               
008D06  1               LAB_17D5
008D06  1  A0 02              LDY   #$02              ; set index to pointer high byte
008D08  1  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
008D0A  1  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
008D0C  1  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
008D0E  1               
008D0E  1  D0 07              BNE   LAB_17E6          ; branch if >
008D10  1                                             ; else was equal so compare low bytes
008D10  1  88                 DEY                     ; decrement index
008D11  1  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
008D13  1  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
008D15  1  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
008D17  1               
008D17  1                                             ; pointer was >= to bottom of string space pointer
008D17  1               LAB_17E6
008D17  1  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
008D19  1  C4 7C              CPY   Svarh             ; compare start of vars high byte
008D1B  1  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
008D1D  1               
008D1D  1  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
008D1F  1               
008D1F  1                                             ; else high bytes were equal so ..
008D1F  1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
008D21  1  C5 7B              CMP   Svarl             ; compare start of vars low byte
008D23  1  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
008D25  1               
008D25  1               LAB_17F4
008D25  1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
008D27  1  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
008D29  1  4C 42 8D           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
008D2C  1               
008D2C  1                                             ; make space and copy string
008D2C  1               LAB_17FB
008D2C  1  A0 00              LDY   #$00              ; index to length
008D2E  1  B1 AE              LDA   (des_pl),Y        ; get string length
008D30  1  20 8D 96           JSR   LAB_209C          ; copy string
008D33  1  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
008D35  1  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
008D37  1  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
008D39  1  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
008D3B  1  20 6D 98           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
008D3E  1  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
008D40  1  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
008D42  1               
008D42  1                                             ; clean stack and assign value to string variable
008D42  1               LAB_1811
008D42  1  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
008D44  1  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
008D46  1  20 CF 98           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
008D49  1  A0 00              LDY   #$00              ; index to length
008D4B  1  B1 9E              LDA   (des_2l),Y        ; get string length
008D4D  1  91 97              STA   (Lvarpl),Y        ; copy to let string variable
008D4F  1  C8                 INY                     ; index to string pointer low byte
008D50  1  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
008D52  1  91 97              STA   (Lvarpl),Y        ; copy to let string variable
008D54  1  C8                 INY                     ; index to string pointer high byte
008D55  1  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
008D57  1  91 97              STA   (Lvarpl),Y        ; copy to let string variable
008D59  1  60                 RTS
008D5A  1               
008D5A  1               ; perform GET
008D5A  1               
008D5A  1               LAB_GET
008D5A  1  20 F9 92           JSR   LAB_GVAR          ; get var address
008D5D  1  85 97              STA   Lvarpl            ; save var address low byte
008D5F  1  84 98              STY   Lvarph            ; save var address high byte
008D61  1  20 3B A4           JSR   INGET             ; get input byte
008D64  1  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
008D66  1  30 07              BMI   LAB_GETS          ; go get string character
008D68  1               
008D68  1                                             ; was numeric get
008D68  1  A8                 TAY                     ; copy character to Y
008D69  1  20 C1 95           JSR   LAB_1FD0          ; convert Y to byte in FAC1
008D6C  1  4C FE 9D           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
008D6F  1               
008D6F  1               LAB_GETS
008D6F  1  48                 PHA                     ; save character
008D70  1  A9 01              LDA   #$01              ; string is single byte
008D72  1  B0 01              BCS   LAB_IsByte        ; branch if byte received
008D74  1               
008D74  1  68                 PLA                     ; string is null
008D75  1               LAB_IsByte
008D75  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
008D78  1                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
008D78  1  F0 05              BEQ   LAB_NoSt          ; skip store if null string
008D7A  1               
008D7A  1  68                 PLA                     ; get character back
008D7B  1  A0 00              LDY   #$00              ; clear index
008D7D  1  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
008D7F  1               LAB_NoSt
008D7F  1  20 E1 96           JSR   LAB_RTST          ; check for space on descriptor stack then put address
008D82  1                                             ; and length on descriptor stack and update stack pointers
008D82  1               
008D82  1  4C 06 8D           JMP   LAB_17D5          ; do string LET and return
008D85  1               
008D85  1               ; perform PRINT
008D85  1               
008D85  1               LAB_1829
008D85  1  20 1B 8E           JSR   LAB_18C6          ; print string from Sutill/Sutilh
008D88  1               LAB_182C
008D88  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008D8B  1               
008D8B  1               ; PRINT
008D8B  1               
008D8B  1               LAB_PRINT
008D8B  1  F0 47              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
008D8D  1               
008D8D  1               LAB_1831
008D8D  1               .ifdef APPLE2
008D8D  1  C9 BB              CMP   #TK_THEN          ; might be part of TRY
008D8F  1  D0 03              BNE   :+
008D91  1  4C CD 8B           JMP   LAB_DATA          ; ignore the rest of the line
008D94  1               :
008D94  1               .endif
008D94  1               
008D94  1  C9 B6              CMP   #TK_TAB           ; compare with TAB( token
008D96  1  F0 5B              BEQ   LAB_18A2          ; go do TAB/SPC
008D98  1               
008D98  1  C9 BA              CMP   #TK_SPC           ; compare with SPC( token
008D9A  1  F0 57              BEQ   LAB_18A2          ; go do TAB/SPC
008D9C  1               
008D9C  1  C9 2C              CMP   #','              ; compare with ","
008D9E  1  F0 3D              BEQ   LAB_188B          ; go do move to next TAB mark
008DA0  1               
008DA0  1  C9 3B              CMP   #';'              ; compare with ";"
008DA2  1  F0 6B              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
008DA4  1               
008DA4  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
008DA7  1  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
008DA9  1  30 DA              BMI   LAB_1829          ; branch if string
008DAB  1               
008DAB  1  20 F0 9F           JSR   LAB_296E          ; convert FAC1 to string
008DAE  1  20 9F 96           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
008DB1  1  A0 00              LDY   #$00              ; clear index
008DB3  1               
008DB3  1               ; don't check fit if terminal width byte is zero
008DB3  1               
008DB3  1  A5 0F              LDA   TWidth            ; get terminal width byte
008DB5  1  F0 0A              BEQ   LAB_185E          ; skip check if zero
008DB7  1               
008DB7  1  38                 SEC                     ; set carry for subtract
008DB8  1  E5 0E              SBC   TPos              ; subtract terminal position
008DBA  1  F1 AE              SBC   (des_pl),Y        ; subtract string length
008DBC  1  B0 03              BCS   LAB_185E          ; branch if less than terminal width
008DBE  1               
008DBE  1  20 D4 8D           JSR   LAB_CRLF          ; else print CR/LF
008DC1  1               LAB_185E
008DC1  1  20 1B 8E           JSR   LAB_18C6          ; print string from Sutill/Sutilh
008DC4  1  F0 C2              BEQ   LAB_182C          ; always go continue processing line
008DC6  1               
008DC6  1               ; CR/LF return to BASIC from BASIC input handler
008DC6  1               
008DC6  1               LAB_1866
008DC6  1  A9 00              LDA   #$00              ; clear byte
008DC8  1  9D 00 02           STA   Ibuffs,X          ; null terminate input
008DCB  1  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
008DCD  1  A0 02              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
008DCF  1               .ifdef APPLE2
008DCF  1  A9 1D              LDA   #$1D              ; clear to end of line
008DD1  1  20 32 8E           JSR   LAB_PRNA
008DD4  1               .endif
008DD4  1               
008DD4  1               ; print CR/LF
008DD4  1               
008DD4  1               LAB_CRLF
008DD4  1  A9 0D              LDA   #$0D              ; load [CR]
008DD6  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
008DD9  1  A9 0A              LDA   #$0A              ; load [LF]
008DDB  1  D0 55              BNE   LAB_PRNA          ; go print the character and return, branch always
008DDD  1               
008DDD  1               LAB_188B
008DDD  1  A5 0E              LDA   TPos              ; get terminal position
008DDF  1  C5 10              CMP   Iclim             ; compare with input column limit
008DE1  1  90 05              BCC   LAB_1897          ; branch if less
008DE3  1               
008DE3  1  20 D4 8D           JSR   LAB_CRLF          ; else print CR/LF (next line)
008DE6  1  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
008DE8  1               
008DE8  1               LAB_1897
008DE8  1  38                 SEC                     ; set carry for subtract
008DE9  1               LAB_1898
008DE9  1  E5 64              SBC   TabSiz            ; subtract TAB size
008DEB  1  B0 FC              BCS   LAB_1898          ; loop if result was +ve
008DED  1               
008DED  1  49 FF              EOR   #$FF              ; complement it
008DEF  1  69 01              ADC   #$01              ; +1 (twos complement)
008DF1  1  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
008DF3  1               
008DF3  1                                             ; do TAB/SPC
008DF3  1               LAB_18A2
008DF3  1  48                 PHA                     ; save token
008DF4  1  20 E4 99           JSR   LAB_SGBY          ; scan and get byte parameter
008DF7  1  C9 29              CMP   #$29              ; is next character )
008DF9  1  D0 7E              BNE   LAB_1910          ; if not do syntax error then warm start
008DFB  1               
008DFB  1  68                 PLA                     ; get token back
008DFC  1  C9 B6              CMP   #TK_TAB           ; was it TAB ?
008DFE  1  D0 06              BNE   LAB_18B7          ; if not go do SPC
008E00  1               
008E00  1                                             ; calculate TAB offset
008E00  1  8A                 TXA                     ; copy integer value to A
008E01  1  E5 0E              SBC   TPos              ; subtract terminal position
008E03  1  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
008E05  1               
008E05  1                                             ; print A spaces
008E05  1               LAB_18B6
008E05  1  AA                 TAX                     ; copy result to X
008E06  1               LAB_18B7
008E06  1  8A                 TXA                     ; set flags on size for SPC
008E07  1  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
008E09  1               
008E09  1                                             ; print X spaces
008E09  1               LAB_18BA
008E09  1  20 2D 8E           JSR   LAB_18E0          ; print " "
008E0C  1  CA                 DEX                     ; decrement count
008E0D  1  D0 FA              BNE   LAB_18BA          ; loop if not all done
008E0F  1               
008E0F  1                                             ; continue with PRINT processing
008E0F  1               LAB_18BD
008E0F  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008E12  1               .ifdef APPLE2
008E12  1  F0 03              BEQ   :+
008E14  1  4C 8D 8D           JMP   LAB_1831
008E17  1               :
008E17  1               .else
008E17  1                     BNE   LAB_1831          ; if more to print go do it
008E17  1               .endif
008E17  1               
008E17  1  60                 RTS
008E18  1               
008E18  1               ; print null terminated string from memory
008E18  1               
008E18  1               LAB_18C3
008E18  1  20 9F 96           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
008E1B  1               
008E1B  1               ; print string from Sutill/Sutilh
008E1B  1               
008E1B  1               LAB_18C6
008E1B  1  20 9A 98           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
008E1E  1                                             ; space returns with A = length, X=$71=pointer low byte,
008E1E  1                                             ; Y=$72=pointer high byte
008E1E  1  A0 00              LDY   #$00              ; reset index
008E20  1  AA                 TAX                     ; copy length to X
008E21  1  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
008E23  1               
008E23  1               LAB_18CD
008E23  1               
008E23  1  B1 71              LDA   (ut1_pl),Y        ; get next byte
008E25  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
008E28  1  C8                 INY                     ; increment index
008E29  1  CA                 DEX                     ; decrement count
008E2A  1  D0 F7              BNE   LAB_18CD          ; loop if not done yet
008E2C  1               
008E2C  1  60                 RTS
008E2D  1               
008E2D  1                                             ; Print single format character
008E2D  1               ; print " "
008E2D  1               
008E2D  1               LAB_18E0
008E2D  1  A9 20              LDA   #$20              ; load " "
008E2F  1  2C                 .byte $2C               ; change next line to BIT LAB_3FA9
008E30  1               
008E30  1               ; print "?" character
008E30  1               
008E30  1               LAB_18E3
008E30  1  A9 3F              LDA   #$3F              ; load "?" character
008E32  1               
008E32  1               ; print character in A
008E32  1               ; now includes the null handler
008E32  1               ; also includes infinite line length code
008E32  1               ; note! some routines expect this one to exit with Zb=0
008E32  1               
008E32  1               LAB_PRNA
008E32  1  C9 20              CMP   #' '              ; compare with " "
008E34  1  90 19              BCC   LAB_18F9          ; branch if less (non printing)
008E36  1               
008E36  1                                             ; else printable character
008E36  1  48                 PHA                     ; save the character
008E37  1               
008E37  1               ; don't check fit if terminal width byte is zero
008E37  1               
008E37  1  A5 0F              LDA   TWidth            ; get terminal width
008E39  1  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
008E3B  1               
008E3B  1               ; is "infinite line" so check TAB position
008E3B  1               
008E3B  1  A5 0E              LDA   TPos              ; get position
008E3D  1  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
008E3F  1  D0 0B              BNE   LAB_18F7          ; skip reset if different
008E41  1               
008E41  1  85 0E              STA   TPos              ; else reset position
008E43  1  F0 07              BEQ   LAB_18F7          ; go print character
008E45  1               
008E45  1               LAB_18F0
008E45  1  C5 0E              CMP   TPos              ; compare with terminal character position
008E47  1  D0 03              BNE   LAB_18F7          ; branch if not at end of line
008E49  1               
008E49  1  20 D4 8D           JSR   LAB_CRLF          ; else print CR/LF
008E4C  1               LAB_18F7
008E4C  1  E6 0E              INC   TPos              ; increment terminal position
008E4E  1  68                 PLA                     ; get character back
008E4F  1               LAB_18F9
008E4F  1  20 58 AF           JSR   V_OUTP            ; output byte via output vector
008E52  1  C9 0D              CMP   #$0D              ; compare with [CR]
008E54  1  D0 14              BNE   LAB_188A          ; branch if not [CR]
008E56  1               
008E56  1                                             ; else print nullct nulls after the [CR]
008E56  1  86 78              STX   TempB             ; save buffer index
008E58  1  A6 0D              LDX   Nullct            ; get null count
008E5A  1  F0 0A              BEQ   LAB_1886          ; branch if no nulls
008E5C  1               
008E5C  1  A9 00              LDA   #$00              ; load [NULL]
008E5E  1               LAB_1880
008E5E  1  20 32 8E           JSR   LAB_PRNA          ; go print the character
008E61  1  CA                 DEX                     ; decrement count
008E62  1  D0 FA              BNE   LAB_1880          ; loop if not all done
008E64  1               
008E64  1  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
008E66  1               LAB_1886
008E66  1  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
008E68  1  A6 78              LDX   TempB             ; restore buffer index
008E6A  1               LAB_188A
008E6A  1  29 FF              AND   #$FF              ; set the flags
008E6C  1               LAB_188C
008E6C  1  60                 RTS
008E6D  1               
008E6D  1               ; handle bad input data
008E6D  1               
008E6D  1               LAB_1904
008E6D  1  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
008E6F  1  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
008E71  1               
008E71  1  A5 8D              LDA   Dlinel            ; get current DATA line low byte
008E73  1  A4 8E              LDY   Dlineh            ; get current DATA line high byte
008E75  1  85 87              STA   Clinel            ; save current line low byte
008E77  1  84 88              STY   Clineh            ; save current line high byte
008E79  1               LAB_1910
008E79  1  4C 51 91           JMP   LAB_SNER          ; do syntax error then warm start
008E7C  1               
008E7C  1                                             ; mode was INPUT
008E7C  1               LAB_1913
008E7C  1  A9 20              LDA   #<LAB_REDO        ; point to redo message (low addr)
008E7E  1  A0 BD              LDY   #>LAB_REDO        ; point to redo message (high addr)
008E80  1  20 18 8E           JSR   LAB_18C3          ; print null terminated string from memory
008E83  1  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
008E85  1  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
008E87  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
008E89  1  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
008E8B  1  60                 RTS
008E8C  1               
008E8C  1               ; perform INPUT
008E8C  1               
008E8C  1               LAB_INPUT
008E8C  1  C9 22              CMP   #$22              ; compare next byte with open quote
008E8E  1  D0 0D              BNE   LAB_1934          ; branch if no prompt string
008E90  1               
008E90  1  20 0D 91           JSR   LAB_1BC1          ; print "..." string
008E93  1  A9 3B              LDA   #$3B              ; load A with ";"
008E95  1  20 40 91           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
008E98  1  20 1B 8E           JSR   LAB_18C6          ; print string from Sutill/Sutilh
008E9B  1               .ifdef APPLE2
008E9B  1                     ; do Applesoft-style prompting, no ? when prompt string present
008E9B  1  A9 00              LDA   #$00              ; set z flag
008E9D  1               .endif
008E9D  1                                             ; done with prompt, now get data
008E9D  1               LAB_1934
008E9D  1               .ifdef APPLE2
008E9D  1  08                 PHP
008E9E  1  20 C5 95           JSR   LAB_CKRN          ; check not Direct, back here if ok
008EA1  1  28                 PLP
008EA2  1  D0 05              BNE   :+                ; do ? if no prompt string
008EA4  1  20 B6 86           JSR   LAB_1357          ; no ? prompt
008EA7  1  80 03              BRA   :++
008EA9  1               :
008EA9  1  20 A8 86           JSR   LAB_INLN          ; print "? " and get BASIC input
008EAC  1               :
008EAC  1               .else
008EAC  1                     JSR   LAB_CKRN          ; check not Direct, back here if ok
008EAC  1                     JSR   LAB_INLN          ; print "? " and get BASIC input
008EAC  1               .endif
008EAC  1  A9 00              LDA   #$00              ; set mode = INPUT
008EAE  1  CD 00 02           CMP   Ibuffs            ; test first byte in buffer
008EB1  1  D0 09              BNE   LAB_1953          ; branch if not null input
008EB3  1               
008EB3  1               ; *** change p2: keep carry set to throw break message
008EB3  1               ;      CLC                     ; was null input so clear carry to exit program
008EB3  1  4C 52 8A           JMP   LAB_1647          ; go do BREAK exit
008EB6  1               
008EB6  1               ; perform READ
008EB6  1               
008EB6  1               LAB_READ
008EB6  1  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
008EB8  1  A4 90              LDY   Dptrh             ; get DATA pointer high byte
008EBA  1  A9 80              LDA   #$80              ; set mode = READ
008EBC  1               
008EBC  1               LAB_1953
008EBC  1  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
008EBE  1  86 91              STX   Rdptrl            ; save READ pointer low byte
008EC0  1  84 92              STY   Rdptrh            ; save READ pointer high byte
008EC2  1               
008EC2  1                                             ; READ or INPUT next variable from list
008EC2  1               LAB_195B
008EC2  1  20 F9 92           JSR   LAB_GVAR          ; get (var) address
008EC5  1  85 97              STA   Lvarpl            ; save address low byte
008EC7  1  84 98              STY   Lvarph            ; save address high byte
008EC9  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
008ECB  1  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
008ECD  1  85 11              STA   Itempl            ; save as temporary integer low byte
008ECF  1  84 12              STY   Itemph            ; save as temporary integer high byte
008ED1  1  A6 91              LDX   Rdptrl            ; get READ pointer low byte
008ED3  1  A4 92              LDY   Rdptrh            ; get READ pointer high byte
008ED5  1  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
008ED7  1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
008ED9  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008EDC  1  D0 11              BNE   LAB_1988          ; branch if not null
008EDE  1               
008EDE  1                                             ; pointer was to null entry
008EDE  1  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
008EE0  1  30 65              BMI   LAB_19DD          ; branch if READ
008EE2  1               
008EE2  1                                             ; mode was INPUT
008EE2  1  20 30 8E           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
008EE5  1  20 A8 86           JSR   LAB_INLN          ; print "? " and get BASIC input
008EE8  1  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
008EEA  1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
008EEC  1               LAB_1985
008EEC  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008EEF  1               LAB_1988
008EEF  1  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
008EF1  1  10 24              BPL   LAB_19B0          ; branch if numeric
008EF3  1               
008EF3  1                                             ; else get string
008EF3  1  85 5B              STA   Srchc             ; save search character
008EF5  1  C9 22              CMP   #$22              ; was it " ?
008EF7  1  F0 07              BEQ   LAB_1999          ; branch if so
008EF9  1               
008EF9  1  A9 3A              LDA   #':'              ; else search character is ":"
008EFB  1  85 5B              STA   Srchc             ; set new search character
008EFD  1  A9 2C              LDA   #','              ; other search character is ","
008EFF  1  18                 CLC                     ; clear carry for add
008F00  1               LAB_1999
008F00  1  85 5C              STA   Asrch             ; set second search character
008F02  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
008F04  1  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
008F06  1               
008F06  1  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
008F08  1  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
008F0A  1               
008F0A  1  C8                 INY                     ; else increment high byte
008F0B  1               LAB_19A4
008F0B  1  20 A5 96           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
008F0E  1  20 2A 9A           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
008F11  1  20 06 8D           JSR   LAB_17D5          ; go do string LET
008F14  1  4C 1D 8F           JMP   LAB_19B6          ; go check string terminator
008F17  1               
008F17  1                                             ; get numeric INPUT
008F17  1               LAB_19B0
008F17  1  20 01 9F           JSR   LAB_2887          ; get FAC1 from string
008F1A  1  20 FE 9D           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
008F1D  1               LAB_19B6
008F1D  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008F20  1  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
008F22  1               
008F22  1  C9 2C              CMP   #','              ; else compare with ","
008F24  1  F0 03              BEQ   LAB_19C2          ; branch if ","
008F26  1               
008F26  1  4C 6D 8E           JMP   LAB_1904          ; else go handle bad input data
008F29  1               
008F29  1                                             ; got good input data
008F29  1               LAB_19C2
008F29  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
008F2C  1               LAB_19C5
008F2C  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
008F2E  1  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
008F30  1  85 91              STA   Rdptrl            ; save for now
008F32  1  84 92              STY   Rdptrh            ; save for now
008F34  1  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
008F36  1  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
008F38  1  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
008F3A  1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
008F3C  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
008F3F  1  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
008F41  1               
008F41  1  20 4D 91           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
008F44  1  4C C2 8E           JMP   LAB_195B          ; go INPUT next variable from list
008F47  1               
008F47  1                                             ; find next DATA statement or do "Out of DATA" error
008F47  1               LAB_19DD
008F47  1  20 DE 8B           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
008F4A  1  C8                 INY                     ; increment index
008F4B  1  AA                 TAX                     ; copy character ([:] or [EOL])
008F4C  1  D0 12              BNE   LAB_19F6          ; branch if [:]
008F4E  1               
008F4E  1  A2 06              LDX   #$06              ; set for "Out of DATA" error
008F50  1  C8                 INY                     ; increment index, now points to next line pointer high byte
008F51  1  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
008F53  1  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
008F55  1               
008F55  1  C8                 INY                     ; increment index
008F56  1  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
008F58  1  85 8D              STA   Dlinel            ; save current DATA line low byte
008F5A  1  C8                 INY                     ; increment index
008F5B  1  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
008F5D  1  C8                 INY                     ; increment index
008F5E  1  85 8E              STA   Dlineh            ; save current DATA line high byte
008F60  1               LAB_19F6
008F60  1  B1 C3              LDA   (Bpntrl),Y        ; get byte
008F62  1  C8                 INY                     ; increment index
008F63  1  AA                 TAX                     ; copy to X
008F64  1  20 D0 8B           JSR   LAB_170F          ; set BASIC execute pointer
008F67  1  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
008F69  1  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
008F6B  1               
008F6B  1  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
008F6D  1               
008F6D  1               ; end of INPUT/READ routine
008F6D  1               
008F6D  1               LAB_1A03
008F6D  1  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
008F6F  1  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
008F71  1  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
008F73  1  10 03              BPL   LAB_1A0E          ; branch if INPUT
008F75  1               
008F75  1  4C 74 8A           JMP   LAB_1624          ; save AY as DATA pointer and return
008F78  1               
008F78  1                                             ; we were getting INPUT
008F78  1               LAB_1A0E
008F78  1  A0 00              LDY   #$00              ; clear index
008F7A  1  B1 91              LDA   (Rdptrl),Y        ; get next byte
008F7C  1  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
008F7E  1               
008F7E  1  60                 RTS
008F7F  1               
008F7F  1                                             ; user typed too much
008F7F  1               LAB_1A1B
008F7F  1  A9 0F              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
008F81  1  A0 BD              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
008F83  1  4C 18 8E           JMP   LAB_18C3          ; print null terminated string from memory and return
008F86  1               
008F86  1               ; search the stack for FOR activity
008F86  1               ; exit with z=1 if FOR else exit with z=0
008F86  1               
008F86  1               LAB_11A1
008F86  1  BA                 TSX                     ; copy stack pointer
008F87  1  E8                 INX                     ; +1 pass return address
008F88  1  E8                 INX                     ; +2 pass return address
008F89  1  E8                 INX                     ; +3 pass calling routine return address
008F8A  1  E8                 INX                     ; +4 pass calling routine return address
008F8B  1               LAB_11A6
008F8B  1  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
008F8E  1  C9 81              CMP   #TK_FOR           ; is it FOR token
008F90  1  D0 21              BNE   LAB_11CE          ; exit if not FOR token
008F92  1               
008F92  1                                             ; was FOR token
008F92  1  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
008F94  1  D0 0A              BNE   LAB_11BB          ; branch if not null
008F96  1               
008F96  1  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
008F99  1  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
008F9B  1  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
008F9E  1  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
008FA0  1               LAB_11BB
008FA0  1  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
008FA3  1  D0 07              BNE   LAB_11C7          ; branch if no match
008FA5  1               
008FA5  1  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
008FA7  1  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
008FAA  1  F0 07              BEQ   LAB_11CE          ; exit if match found
008FAC  1               
008FAC  1               LAB_11C7
008FAC  1  8A                 TXA                     ; copy index
008FAD  1  18                 CLC                     ; clear carry for add
008FAE  1  69 10              ADC   #$10              ; add FOR stack use size
008FB0  1  AA                 TAX                     ; copy back to index
008FB1  1  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
008FB3  1               
008FB3  1               LAB_11CE
008FB3  1  60                 RTS
008FB4  1               
008FB4  1               ; perform NEXT
008FB4  1               
008FB4  1               LAB_NEXT
008FB4  1  D0 04              BNE   LAB_1A46          ; branch if NEXT var
008FB6  1               
008FB6  1  A0 00              LDY   #$00              ; else clear Y
008FB8  1  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
008FBA  1               
008FBA  1               ; NEXT var
008FBA  1               
008FBA  1               LAB_1A46
008FBA  1  20 F9 92           JSR   LAB_GVAR          ; get variable address
008FBD  1               LAB_1A49
008FBD  1  85 97              STA   Frnxtl            ; store variable pointer low byte
008FBF  1  84 98              STY   Frnxth            ; store variable pointer high byte
008FC1  1                                             ; (both cleared if no variable defined)
008FC1  1  20 86 8F           JSR   LAB_11A1          ; search the stack for FOR activity
008FC4  1  F0 04              BEQ   LAB_1A56          ; branch if found
008FC6  1               
008FC6  1  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
008FC8  1               LAB_1A54
008FC8  1  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
008FCA  1               
008FCA  1               LAB_1A56
008FCA  1  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
008FCB  1               
008FCB  1  8A                 TXA                     ; copy stack pointer
008FCC  1  38                 SEC                     ; set carry for subtract
008FCD  1  E9 F7              SBC   #$F7              ; point to TO var
008FCF  1  85 73              STA   ut2_pl            ; save pointer to TO var for compare
008FD1  1  69 FB              ADC   #$FB              ; point to STEP var
008FD3  1               
008FD3  1  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
008FD5  1  20 D8 9D           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
008FD8  1  BA                 TSX                     ; get stack pointer back
008FD9  1  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
008FDC  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
008FDE  1  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
008FE0  1  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
008FE2  1  20 19 9B           JSR   LAB_246C          ; add (FOR variable) to FAC1
008FE5  1  20 FE 9D           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
008FE8  1  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
008FEA  1  20 74 9E           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
008FED  1  BA                 TSX                     ; get stack pointer back
008FEE  1  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
008FF1  1  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
008FF3  1               
008FF3  1                                             ; loop back and do it all again
008FF3  1  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
008FF6  1  85 87              STA   Clinel            ; save current line low byte
008FF8  1  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
008FFB  1  85 88              STA   Clineh            ; save current line high byte
008FFD  1  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
009000  1  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
009002  1  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
009005  1  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
009007  1               LAB_1A98
009007  1  4C D0 89           JMP   LAB_15C2          ; go do interpreter inner loop
00900A  1               
00900A  1                                             ; loop complete so carry on
00900A  1               LAB_1A9B
00900A  1  8A                 TXA                     ; stack copy to A
00900B  1  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
00900D  1  AA                 TAX                     ; copy back to index
00900E  1  9A                 TXS                     ; copy to stack pointer
00900F  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
009012  1  C9 2C              CMP   #','              ; compare with ","
009014  1  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
009016  1               
009016  1                                             ; was "," so another NEXT variable to do
009016  1  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
009019  1  20 BA 8F           JSR   LAB_1A46          ; do NEXT (var)
00901C  1               
00901C  1               ; evaluate expression and check is numeric, else do type mismatch
00901C  1               
00901C  1               LAB_EVNM
00901C  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
00901F  1               
00901F  1               ; check if source is numeric, else do type mismatch
00901F  1               
00901F  1               LAB_CTNM
00901F  1  18                 CLC                     ; destination is numeric
009020  1  24                 .byte $24               ; makes next line BIT $38
009021  1               
009021  1               ; check if source is string, else do type mismatch
009021  1               
009021  1               LAB_CTST
009021  1  38                 SEC                     ; required type is string
009022  1               
009022  1               ; type match check, set C for string, clear C for numeric
009022  1               
009022  1               LAB_CKTM
009022  1  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
009024  1  30 03              BMI   LAB_1ABA          ; branch if data type is string
009026  1               
009026  1                                             ; else data type was numeric
009026  1  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
009028  1               LAB_1AB9
009028  1  60                 RTS
009029  1               
009029  1                                             ; data type was string, now check required type
009029  1               LAB_1ABA
009029  1  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
00902B  1               
00902B  1                                             ; else do type mismatch error
00902B  1               LAB_1ABC
00902B  1  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
00902D  1               LAB_1ABE
00902D  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
009030  1               
009030  1               ; evaluate expression
009030  1               
009030  1               LAB_EVEX
009030  1  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
009032  1  D0 02              BNE   LAB_1AC7          ; skip next if not zero
009034  1               
009034  1  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
009036  1               LAB_1AC7
009036  1  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
009038  1               
009038  1               LAB_EVEZ
009038  1  A9 00              LDA   #$00              ; set null precedence (flag done)
00903A  1               LAB_1ACC
00903A  1  48                 PHA                     ; push precedence byte
00903B  1  A9 02              LDA   #$02              ; 2 bytes
00903D  1  20 D1 84           JSR   LAB_1212          ; check room on stack for A bytes
009040  1  20 1C 91           JSR   LAB_GVAL          ; get value from line
009043  1  A9 00              LDA   #$00              ; clear A
009045  1  85 9B              STA   comp_f            ; clear compare function flag
009047  1               LAB_1ADB
009047  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
00904A  1               LAB_1ADE
00904A  1  38                 SEC                     ; set carry for subtract
00904B  1  E9 CC              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
00904D  1  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
00904F  1               
00904F  1  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
009051  1  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
009053  1               
009053  1                                             ; was token for > = or < (A = 0, 1 or 2)
009053  1  C9 01              CMP   #$01              ; compare with token for =
009055  1  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
009056  1                                             ; (A = 0, 3 or 5)
009056  1  49 01              EOR   #$01              ; toggle b0
009058  1                                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
009058  1  45 9B              EOR   comp_f            ; EOR with compare function flag bits
00905A  1  C5 9B              CMP   comp_f            ; compare with compare function flag
00905C  1  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
00905E  1                                             ; was more than one <, = or >)
00905E  1               
00905E  1  85 9B              STA   comp_f            ; save new compare function flag
009060  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
009063  1  4C 4A 90           JMP   LAB_1ADE          ; go do next character
009066  1               
009066  1                                             ; token is < ">" or > "<" tokens
009066  1               LAB_1AFA
009066  1  A6 9B              LDX   comp_f            ; get compare function flag
009068  1  D0 2C              BNE   LAB_1B2A          ; branch if compare function
00906A  1               
00906A  1  B0 79              BCS   LAB_1B78          ; go do functions
00906C  1               
00906C  1                                             ; else was <  TK_GT so is operator or lower
00906C  1  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
00906E  1  90 75              BCC   LAB_1B78          ; branch if < + operator
009070  1               
009070  1                                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
009070  1  D0 07              BNE   LAB_1B0B          ; branch if not + token
009072  1               
009072  1  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
009074  1  10 03              BPL   LAB_1B0B          ; branch if not string
009076  1               
009076  1                                             ; will only be $00 if type is string and token was +
009076  1  4C 30 98           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
009079  1                                             ; is in line, and return
009079  1               
009079  1               LAB_1B0B
009079  1  85 71              STA   ut1_pl            ; save it
00907B  1  0A                 ASL                     ; *2
00907C  1  65 71              ADC   ut1_pl            ; *3
00907E  1  A8                 TAY                     ; copy to index
00907F  1               LAB_1B13
00907F  1  68                 PLA                     ; pull previous precedence
009080  1  D9 9F B5           CMP   LAB_OPPT,Y        ; compare with precedence byte
009083  1  B0 65              BCS   LAB_1B7D          ; branch if A >=
009085  1               
009085  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
009088  1               LAB_1B1C
009088  1  48                 PHA                     ; save precedence
009089  1               LAB_1B1D
009089  1  20 B1 90           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
00908C  1  68                 PLA                     ; restore precedence
00908D  1  A4 99              LDY   prstk             ; get precedence stacked flag
00908F  1  10 19              BPL   LAB_1B3C          ; branch if stacked values
009091  1               
009091  1  AA                 TAX                     ; copy precedence (set flags)
009092  1  F0 76              BEQ   LAB_1B9D          ; exit if done
009094  1               
009094  1  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
009096  1               
009096  1               LAB_1B2A
009096  1  26 5F              ROL   Dtypef            ; shift data type flag into Cb
009098  1  8A                 TXA                     ; copy compare function flag
009099  1  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
00909B  1  2A                 ROL                     ; shift data type into compare function byte b0
00909C  1  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
00909E  1  D0 02              BNE   LAB_1B34          ; branch if no underflow
0090A0  1               
0090A0  1  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
0090A2  1               LAB_1B34
0090A2  1  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
0090A4  1               TK_LT_PLUS  = TK_LT-TK_PLUS
0090A4  1  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
0090A6  1  85 9B              STA   comp_f            ; save new compare function flag
0090A8  1  D0 D5              BNE   LAB_1B13          ; branch always
0090AA  1               
0090AA  1               LAB_1B3C
0090AA  1  D9 9F B5           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
0090AD  1  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
0090AF  1               
0090AF  1  90 D7              BCC   LAB_1B1C          ; branch always
0090B1  1               
0090B1  1               ;.get vector, execute function then continue evaluation
0090B1  1               
0090B1  1               LAB_1B43
0090B1  1  B9 A1 B5           LDA   LAB_OPPT+2,Y      ; get function vector high byte
0090B4  1  48                 PHA                     ; onto stack
0090B5  1  B9 A0 B5           LDA   LAB_OPPT+1,Y      ; get function vector low byte
0090B8  1  48                 PHA                     ; onto stack
0090B9  1                                             ; now push sign, round FAC1 and put on stack
0090B9  1  20 C8 90           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
0090BC  1                                             ; the function
0090BC  1  A5 9B              LDA   comp_f            ; get compare function flag
0090BE  1  48                 PHA                     ; push compare evaluation byte
0090BF  1  B9 9F B5           LDA   LAB_OPPT,Y        ; get precedence byte
0090C2  1  4C 3A 90           JMP   LAB_1ACC          ; continue evaluating expression
0090C5  1               
0090C5  1               LAB_1B53
0090C5  1  4C 51 91           JMP   LAB_SNER          ; do syntax error then warm start
0090C8  1               
0090C8  1               ; push sign, round FAC1 and put on stack
0090C8  1               
0090C8  1               LAB_1B5B
0090C8  1  68                 PLA                     ; get return addr low byte
0090C9  1  85 71              STA   ut1_pl            ; save it
0090CB  1  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
0090CD  1                                             ; note! no check is made on the high byte! if the calling
0090CD  1                                             ; routine assembles to a page edge then this all goes
0090CD  1                                             ; horribly wrong !!!
0090CD  1  68                 PLA                     ; get return addr high byte
0090CE  1  85 72              STA   ut1_ph            ; save it
0090D0  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
0090D2  1  48                 PHA                     ; push sign
0090D3  1               
0090D3  1               ; round FAC1 and put on stack
0090D3  1               
0090D3  1               LAB_1B66
0090D3  1  20 34 9E           JSR   LAB_27BA          ; round FAC1
0090D6  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
0090D8  1  48                 PHA                     ; push on stack
0090D9  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
0090DB  1  48                 PHA                     ; push on stack
0090DC  1  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
0090DE  1  48                 PHA                     ; push on stack
0090DF  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0090E1  1  48                 PHA                     ; push on stack
0090E2  1  6C 71 00           JMP   (ut1_pl)          ; return, sort of
0090E5  1               
0090E5  1               ; do functions
0090E5  1               
0090E5  1               LAB_1B78
0090E5  1  A0 FF              LDY   #$FF              ; flag function
0090E7  1  68                 PLA                     ; pull precedence byte
0090E8  1               LAB_1B7B
0090E8  1  F0 20              BEQ   LAB_1B9D          ; exit if done
0090EA  1               
0090EA  1               LAB_1B7D
0090EA  1  C9 64              CMP   #$64              ; compare previous precedence with $64
0090EC  1  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
0090EE  1               
0090EE  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
0090F1  1               LAB_1B84
0090F1  1  84 99              STY   prstk             ; save precedence stacked flag
0090F3  1               
0090F3  1                                             ; pop FAC2 and return
0090F3  1               LAB_1B86
0090F3  1  68                 PLA                     ; pop byte
0090F4  1  4A                 LSR                     ; shift out comparison evaluation lowest bit
0090F5  1  85 63              STA   Cflag             ; save comparison evaluation flag
0090F7  1  68                 PLA                     ; pop exponent
0090F8  1  85 B3              STA   FAC2_e            ; save FAC2 exponent
0090FA  1  68                 PLA                     ; pop mantissa1
0090FB  1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
0090FD  1  68                 PLA                     ; pop mantissa2
0090FE  1  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
009100  1  68                 PLA                     ; pop mantissa3
009101  1  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
009103  1  68                 PLA                     ; pop sign
009104  1  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
009106  1  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
009108  1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00910A  1               LAB_1B9D
00910A  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00910C  1  60                 RTS
00910D  1               
00910D  1               ; print "..." string to string util area
00910D  1               
00910D  1               LAB_1BC1
00910D  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00910F  1  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
009111  1  69 00              ADC   #$00              ; add carry to low byte
009113  1  90 01              BCC   LAB_1BCA          ; branch if no overflow
009115  1               
009115  1  C8                 INY                     ; increment high byte
009116  1               LAB_1BCA
009116  1  20 9F 96           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
009119  1  4C 2A 9A           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
00911C  1               
00911C  1               ; get value from line
00911C  1               
00911C  1               LAB_GVAL
00911C  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00911F  1  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
009121  1               
009121  1                                             ; else numeric string found (e.g. 123)
009121  1               LAB_1BA9
009121  1  4C 01 9F           JMP   LAB_2887          ; get FAC1 from string and return
009124  1               
009124  1               ; get value from line .. continued
009124  1               
009124  1                                             ; wasn't a number so ..
009124  1               LAB_1BAC
009124  1  AA                 TAX                     ; set the flags
009125  1  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
009127  1               
009127  1                                             ; else it is either a string, number, variable or (<expr>)
009127  1  C9 24              CMP   #'$'              ; compare with "$"
009129  1  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
00912B  1               
00912B  1  C9 25              CMP   #'%'              ; else compare with "%"
00912D  1  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
00912F  1               
00912F  1  C9 2E              CMP   #'.'              ; compare with "."
009131  1  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
009133  1               
009133  1                                             ; it wasn't any sort of number so ..
009133  1  C9 22              CMP   #$22              ; compare with "
009135  1  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
009137  1               
009137  1                                             ; wasn't any sort of number so ..
009137  1               
009137  1               ; evaluate expression within parentheses
009137  1               
009137  1  C9 28              CMP   #'('              ; compare with "("
009139  1  D0 4F              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
00913B  1               
00913B  1               LAB_1BF7
00913B  1  20 38 90           JSR   LAB_EVEZ          ; evaluate expression, no decrement
00913E  1               
00913E  1               ; all the 'scan for' routines return the character after the sought character
00913E  1               
00913E  1               ; scan for ")" , else do syntax error then warm start
00913E  1               
00913E  1               LAB_1BFB
00913E  1  A9 29              LDA   #$29              ; load A with ")"
009140  1               
009140  1               ; scan for CHR$(A) , else do syntax error then warm start
009140  1               
009140  1               LAB_SCCA
009140  1  A0 00              LDY   #$00              ; clear index
009142  1  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
009144  1  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
009146  1               
009146  1  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
009149  1               
009149  1               ; scan for "(" , else do syntax error then warm start
009149  1               
009149  1               LAB_1BFE
009149  1  A9 28              LDA   #$28              ; load A with "("
00914B  1  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00914D  1                                             ; (branch always)
00914D  1               
00914D  1               ; scan for "," , else do syntax error then warm start
00914D  1               
00914D  1               LAB_1C01
00914D  1  A9 2C              LDA   #$2C              ; load A with ","
00914F  1  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
009151  1                                             ; (branch always)
009151  1               
009151  1               ; syntax error then warm start
009151  1               
009151  1               LAB_SNER
009151  1  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
009153  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
009156  1               
009156  1               ; get value from line .. continued
009156  1               ; do tokens
009156  1               
009156  1               LAB_1BD0
009156  1  C9 C3              CMP   #TK_MINUS         ; compare with token for -
009158  1  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
00915A  1               
00915A  1                                             ; wasn't -n so ..
00915A  1  C9 C2              CMP   #TK_PLUS          ; compare with token for +
00915C  1  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
00915E  1               
00915E  1  C9 BC              CMP   #TK_NOT           ; compare with token for NOT
009160  1  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
009162  1               
009162  1                                             ; was NOT token
009162  1               TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
009162  1  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
009164  1  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
009166  1               
009166  1               ; do = compare
009166  1               
009166  1               LAB_EQUAL
009166  1  20 F5 93           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
009169  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00916B  1  49 FF              EOR   #$FF              ; invert it
00916D  1  A8                 TAY                     ; copy it
00916E  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009170  1  49 FF              EOR   #$FF              ; invert it
009172  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009175  1               
009175  1               ; get value from line .. continued
009175  1               
009175  1                                             ; wasn't +, -, or NOT so ..
009175  1               LAB_1BE7
009175  1  C9 B9              CMP   #TK_FN            ; compare with token for FN
009177  1  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
009179  1               
009179  1  4C 0F 96           JMP   LAB_201E          ; go evaluate FNx
00917C  1               
00917C  1               ; get value from line .. continued
00917C  1               
00917C  1                                             ; wasn't +, -, NOT or FN so ..
00917C  1               LAB_1BEE
00917C  1  E9 CF              SBC   #TK_SGN           ; subtract with token for SGN
00917E  1  B0 19              BCS   LAB_1C27          ; if a function token go do it
009180  1               
009180  1  4C 51 91           JMP   LAB_SNER          ; else do syntax error
009183  1               
009183  1               ; set-up for functions
009183  1               
009183  1               LAB_1C11
009183  1               TK_GT_PLUS  = TK_GT-TK_PLUS
009183  1  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
009185  1               LAB_1C13
009185  1  68                 PLA                     ; dump return address low byte
009186  1  68                 PLA                     ; dump return address high byte
009187  1  4C 89 90           JMP   LAB_1B1D          ; execute function then continue evaluation
00918A  1               
00918A  1               ; variable name set-up
00918A  1               ; get (var), return value in FAC_1 and $ flag
00918A  1               
00918A  1               LAB_1C18
00918A  1  20 F9 92           JSR   LAB_GVAR          ; get (var) address
00918D  1  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
00918F  1  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
009191  1  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
009193  1  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
009195  1               
009195  1               LAB_1C24
009195  1  4C D8 9D           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
009198  1               
009198  1               LAB_1C25
009198  1  60                 RTS
009199  1               
009199  1               ; get value from line .. continued
009199  1               ; only functions left so ..
009199  1               
009199  1               ; set up function references
009199  1               
009199  1               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
009199  1               ; to process function calls. now the function vector is computed and pushed on the stack
009199  1               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
009199  1               ; is calculated and the routine called, if not this routine just does RTS. whichever
009199  1               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
009199  1               ; the function code
009199  1               
009199  1               ; this also removes some less than elegant code that was used to bypass type checking
009199  1               ; for functions that returned strings
009199  1               
009199  1               LAB_1C27
009199  1  0A                 ASL                     ; *2 (2 bytes per function address)
00919A  1  A8                 TAY                     ; copy to index
00919B  1               
00919B  1  B9 46 B5           LDA   LAB_FTBM,Y        ; get function jump vector high byte
00919E  1  48                 PHA                     ; push functions jump vector high byte
00919F  1  B9 45 B5           LDA   LAB_FTBL,Y        ; get function jump vector low byte
0091A2  1  48                 PHA                     ; push functions jump vector low byte
0091A3  1               
0091A3  1  B9 EC B4           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
0091A6  1  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
0091A8  1               
0091A8  1  48                 PHA                     ; push functions pre process vector high byte
0091A9  1  B9 EB B4           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
0091AC  1  48                 PHA                     ; push functions pre process vector low byte
0091AD  1               
0091AD  1               LAB_1C56
0091AD  1  60                 RTS                     ; do function, or pre process, call
0091AE  1               
0091AE  1               ; process string expression in parenthesis
0091AE  1               
0091AE  1               LAB_PPFS
0091AE  1  20 3B 91           JSR   LAB_1BF7          ; process expression in parenthesis
0091B1  1  4C 21 90           JMP   LAB_CTST          ; check if source is string then do function,
0091B4  1                                             ; else do type mismatch
0091B4  1               
0091B4  1               ; process numeric expression in parenthesis
0091B4  1               
0091B4  1               LAB_PPFN
0091B4  1  20 3B 91           JSR   LAB_1BF7          ; process expression in parenthesis
0091B7  1  4C 1F 90           JMP   LAB_CTNM          ; check if source is numeric then do function,
0091BA  1                                             ; else do type mismatch
0091BA  1               
0091BA  1               ; set numeric data type and increment BASIC execute pointer
0091BA  1               
0091BA  1               LAB_PPBI
0091BA  1  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
0091BC  1  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
0091BF  1               
0091BF  1               ; process string for LEFT$, RIGHT$ or MID$
0091BF  1               
0091BF  1               LAB_LRMS
0091BF  1  20 38 90           JSR   LAB_EVEZ          ; evaluate (should be string) expression
0091C2  1  20 4D 91           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
0091C5  1  20 21 90           JSR   LAB_CTST          ; check if source is string, else do type mismatch
0091C8  1               
0091C8  1  68                 PLA                     ; get function jump vector low byte
0091C9  1  AA                 TAX                     ; save functions jump vector low byte
0091CA  1  68                 PLA                     ; get function jump vector high byte
0091CB  1  A8                 TAY                     ; save functions jump vector high byte
0091CC  1  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
0091CE  1  48                 PHA                     ; push string pointer high byte
0091CF  1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
0091D1  1  48                 PHA                     ; push string pointer low byte
0091D2  1  98                 TYA                     ; get function jump vector high byte back
0091D3  1  48                 PHA                     ; save functions jump vector high byte
0091D4  1  8A                 TXA                     ; get function jump vector low byte back
0091D5  1  48                 PHA                     ; save functions jump vector low byte
0091D6  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter
0091D9  1  8A                 TXA                     ; copy byte parameter to A
0091DA  1  60                 RTS                     ; go do function
0091DB  1               
0091DB  1               ; process numeric expression(s) for BIN$ or HEX$
0091DB  1               
0091DB  1               LAB_BHSS
0091DB  1  20 38 90           JSR   LAB_EVEZ          ; process expression
0091DE  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
0091E1  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0091E3  1  C9 98              CMP   #$98              ; compare with exponent = 2^24
0091E5  1  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
0091E7  1               
0091E7  1  20 AB 9E           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
0091EA  1  A2 02              LDX   #$02              ; 3 bytes to do
0091EC  1               LAB_CFAC
0091EC  1  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
0091EE  1  95 11              STA   nums_1,X          ; save byte to temp
0091F0  1  CA                 DEX                     ; decrement index
0091F1  1  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
0091F3  1               
0091F3  1  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
0091F6  1  A2 00              LDX   #$00              ; set default to no leading "0"s
0091F8  1  C9 29              CMP   #')'              ; compare with close bracket
0091FA  1  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
0091FC  1               
0091FC  1  20 39 9A           JSR   LAB_SCGB          ; scan for "," and get byte
0091FF  1  20 C2 00           JSR   LAB_GBYT          ; get last byte back
009202  1  C9 29              CMP   #')'              ; is next character )
009204  1  D0 01              BNE   LAB_BHER          ; if not ")" go do error
009206  1               
009206  1               LAB_1C54
009206  1  60                 RTS                     ; else do function
009207  1               
009207  1               LAB_BHER
009207  1  4C 78 94           JMP   LAB_FCER          ; do function call error then warm start
00920A  1               
00920A  1               ; perform EOR
00920A  1               
00920A  1               ; added operator format is the same as AND or OR, precedence is the same as OR
00920A  1               
00920A  1               ; this bit worked first time but it took a while to sort out the operator table
00920A  1               ; pointers and offsets afterwards!
00920A  1               
00920A  1               LAB_EOR
00920A  1  20 31 92           JSR   GetFirst          ; get first integer expression (no sign check)
00920D  1  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
00920F  1  A8                 TAY                     ; save in Y
009210  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009212  1  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
009214  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009217  1               
009217  1               ; perform OR
009217  1               
009217  1               LAB_OR
009217  1  20 31 92           JSR   GetFirst          ; get first integer expression (no sign check)
00921A  1  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
00921C  1  A8                 TAY                     ; save in Y
00921D  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00921F  1  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
009221  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009224  1               
009224  1               ; perform AND
009224  1               
009224  1               LAB_AND
009224  1  20 31 92           JSR   GetFirst          ; get first integer expression (no sign check)
009227  1  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
009229  1  A8                 TAY                     ; save in Y
00922A  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00922C  1  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
00922E  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009231  1               
009231  1               ; get first value for OR, AND or EOR
009231  1               
009231  1               GetFirst
009231  1  20 F5 93           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
009234  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009236  1  85 5C              STA   XOAw_h            ; save it
009238  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00923A  1  85 5B              STA   XOAw_l            ; save it
00923C  1  20 1E 9B           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
00923F  1  20 F5 93           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
009242  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
009244  1               LAB_1C95
009244  1  60                 RTS
009245  1               
009245  1               ; perform comparisons
009245  1               
009245  1               ; do < compare
009245  1               
009245  1               LAB_LTHAN
009245  1  20 22 90           JSR   LAB_CKTM          ; type match check, set C for string
009248  1  B0 13              BCS   LAB_1CAE          ; branch if string
00924A  1               
00924A  1                                             ; do numeric < compare
00924A  1  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00924C  1  09 7F              ORA   #$7F              ; set all non sign bits
00924E  1  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
009250  1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
009252  1  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
009254  1  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
009256  1  20 72 9E           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
009259  1  AA                 TAX                     ; copy result
00925A  1  4C 8E 92           JMP   LAB_1CE1          ; go evaluate result
00925D  1               
00925D  1                                             ; do string < compare
00925D  1               LAB_1CAE
00925D  1  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00925F  1  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
009261  1  20 9A 98           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
009264  1                                             ; space returns with A = length, X=pointer low byte,
009264  1                                             ; Y=pointer high byte
009264  1  85 AC              STA   str_ln            ; save length
009266  1  86 AD              STX   str_pl            ; save string pointer low byte
009268  1  84 AE              STY   str_ph            ; save string pointer high byte
00926A  1  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
00926C  1  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
00926E  1  20 9E 98           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
009271  1                                             ; returns with A = length, X=pointer low byte,
009271  1                                             ; Y=pointer high byte
009271  1  86 B5              STX   FAC2_2            ; save string pointer low byte
009273  1  84 B6              STY   FAC2_3            ; save string pointer high byte
009275  1  AA                 TAX                     ; copy length
009276  1  38                 SEC                     ; set carry for subtract
009277  1  E5 AC              SBC   str_ln            ; subtract string 1 length
009279  1  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
00927B  1               
00927B  1  A9 01              LDA   #$01              ; set str 1 length > string 2 length
00927D  1  90 04              BCC   LAB_1CD6          ; branch if so
00927F  1               
00927F  1  A6 AC              LDX   str_ln            ; get string 1 length
009281  1  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
009283  1               LAB_1CD6
009283  1  85 B0              STA   FAC1_s            ; save length compare
009285  1  A0 FF              LDY   #$FF              ; set index
009287  1  E8                 INX                     ; adjust for loop
009288  1               LAB_1CDB
009288  1  C8                 INY                     ; increment index
009289  1  CA                 DEX                     ; decrement count
00928A  1  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
00928C  1               
00928C  1  A6 B0              LDX   FAC1_s            ; get length compare back
00928E  1               LAB_1CE1
00928E  1  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
009290  1               
009290  1  18                 CLC                     ; flag str 1 <= str 2
009291  1  90 0C              BCC   LAB_1CF2          ; go evaluate result
009293  1               
009293  1               LAB_1CE6
009293  1  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
009295  1  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
009297  1  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
009299  1               
009299  1  A2 FF              LDX   #$FF              ; set str 1 < string 2
00929B  1  B0 02              BCS   LAB_1CF2          ; branch if so
00929D  1               
00929D  1  A2 01              LDX   #$01              ;  set str 1 > string 2
00929F  1               LAB_1CF2
00929F  1  E8                 INX                     ; x = 0, 1 or 2
0092A0  1  8A                 TXA                     ; copy to A
0092A1  1  2A                 ROL                     ; *2 (1, 2 or 4)
0092A2  1  25 63              AND   Cflag             ; AND with comparison evaluation flag
0092A4  1  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
0092A6  1               
0092A6  1  A9 FF              LDA   #$FF              ; else set result true
0092A8  1               LAB_1CFB
0092A8  1  4C 55 9E           JMP   LAB_27DB          ; save A as integer byte and return
0092AB  1               
0092AB  1               LAB_1CFE
0092AB  1  20 4D 91           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
0092AE  1               
0092AE  1               ; perform DIM
0092AE  1               
0092AE  1               LAB_DIM
0092AE  1  AA                 TAX                     ; copy "DIM" flag to X
0092AF  1  20 FE 92           JSR   LAB_1D10          ; search for variable
0092B2  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
0092B5  1  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
0092B7  1               
0092B7  1  60                 RTS
0092B8  1               
0092B8  1               ; perform << (left shift)
0092B8  1               
0092B8  1               LAB_LSHIFT
0092B8  1  20 EE 92           JSR   GetPair           ; get integer expression and byte (no sign check)
0092BB  1  A5 AE              LDA   FAC1_2            ; get expression high byte
0092BD  1  A6 78              LDX   TempB             ; get shift count
0092BF  1  F0 22              BEQ   NoShift           ; branch if zero
0092C1  1               
0092C1  1  E0 10              CPX   #$10              ; compare bit count with 16d
0092C3  1  B0 23              BCS   TooBig            ; branch if >=
0092C5  1               
0092C5  1               Ls_loop
0092C5  1  06 AF              ASL   FAC1_3            ; shift low byte
0092C7  1  2A                 ROL                     ; shift high byte
0092C8  1  CA                 DEX                     ; decrement bit count
0092C9  1  D0 FA              BNE   Ls_loop           ; loop if shift not complete
0092CB  1               
0092CB  1  A4 AF              LDY   FAC1_3            ; get expression low byte
0092CD  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0092D0  1               
0092D0  1               ; perform >> (right shift)
0092D0  1               
0092D0  1               LAB_RSHIFT
0092D0  1  20 EE 92           JSR   GetPair           ; get integer expression and byte (no sign check)
0092D3  1  A5 AE              LDA   FAC1_2            ; get expression high byte
0092D5  1  A6 78              LDX   TempB             ; get shift count
0092D7  1  F0 0A              BEQ   NoShift           ; branch if zero
0092D9  1               
0092D9  1  E0 10              CPX   #$10              ; compare bit count with 16d
0092DB  1  B0 0B              BCS   TooBig            ; branch if >=
0092DD  1               
0092DD  1               Rs_loop
0092DD  1  4A                 LSR                     ; shift high byte
0092DE  1  66 AF              ROR   FAC1_3            ; shift low byte
0092E0  1  CA                 DEX                     ; decrement bit count
0092E1  1  D0 FA              BNE   Rs_loop           ; loop if shift not complete
0092E3  1               
0092E3  1               NoShift
0092E3  1  A4 AF              LDY   FAC1_3            ; get expression low byte
0092E5  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0092E8  1               
0092E8  1               TooBig
0092E8  1  A9 00              LDA   #$00              ; clear high byte
0092EA  1  A8                 TAY                     ; copy to low byte
0092EB  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0092EE  1               
0092EE  1               GetPair
0092EE  1  20 EA 99           JSR   LAB_EVBY          ; evaluate byte expression, result in X
0092F1  1  86 78              STX   TempB             ; save it
0092F3  1  20 1E 9B           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
0092F6  1  4C F5 93           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
0092F9  1               
0092F9  1               ; search for variable
0092F9  1               
0092F9  1               ; return pointer to variable in Cvaral/Cvarah
0092F9  1               
0092F9  1               LAB_GVAR
0092F9  1  A2 00              LDX   #$00              ; set DIM flag = $00
0092FB  1  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
0092FE  1               LAB_1D10
0092FE  1  86 5E              STX   Defdim            ; save DIM flag
009300  1               LAB_1D12
009300  1  85 93              STA   Varnm1            ; save 1st character
009302  1  29 7F              AND   #$7F              ; clear FN flag bit
009304  1  20 6D 93           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
009307  1  B0 03              BCS   LAB_1D1F          ; branch if ok
009309  1               
009309  1  4C 51 91           JMP   LAB_SNER          ; else syntax error then warm start
00930C  1               
00930C  1                                             ; was variable name so ..
00930C  1               LAB_1D1F
00930C  1  A2 00              LDX   #$00              ; clear 2nd character temp
00930E  1  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
009310  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
009313  1  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
009315  1               
009315  1                                             ; 2nd character wasn't "0" to "9" so ..
009315  1  20 6D 93           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
009318  1  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
00931A  1               
00931A  1               LAB_1D2D
00931A  1  AA                 TAX                     ; copy 2nd character
00931B  1               
00931B  1                                             ; ignore further (valid) characters in the variable name
00931B  1               LAB_1D2E
00931B  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
00931E  1  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
009320  1               
009320  1  20 6D 93           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
009323  1  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
009325  1               
009325  1                                             ; check if string variable
009325  1               LAB_1D38
009325  1  C9 24              CMP   #'$'              ; compare with "$"
009327  1  D0 0B              BNE   LAB_1D47          ; branch if not string
009329  1               
009329  1               ; to introduce a new variable type (% suffix for integers say) then this branch
009329  1               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
009329  1               
009329  1                                             ; type is string
009329  1  A9 FF              LDA   #$FF              ; set data type = string
00932B  1  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
00932D  1  8A                 TXA                     ; get 2nd character back
00932E  1  09 80              ORA   #$80              ; set top bit (indicate string var)
009330  1  AA                 TAX                     ; copy back to 2nd character temp
009331  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
009334  1               
009334  1               ; after we have determined the variable type we need to come back here to determine
009334  1               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
009334  1               
009334  1               
009334  1               LAB_1D47                      ; gets here with character after var name in A
009334  1  86 94              STX   Varnm2            ; save 2nd character
009336  1  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
009338  1  C9 28              CMP   #'('              ; compare with "("
00933A  1  D0 03              BNE   LAB_1D53          ; branch if not "("
00933C  1               
00933C  1  4C 07 94           JMP   LAB_1E17          ; go find, or make, array
00933F  1               
00933F  1               ; either find or create var
00933F  1               ; var name (1st two characters only!) is in Varnm1,Varnm2
00933F  1               
00933F  1                                             ; variable name wasn't var(... so look for plain var
00933F  1               LAB_1D53
00933F  1  A9 00              LDA   #$00              ; clear A
009341  1  85 61              STA   Sufnxf            ; clear subscript/FNX flag
009343  1  A5 7B              LDA   Svarl             ; get start of vars low byte
009345  1  A6 7C              LDX   Svarh             ; get start of vars high byte
009347  1  A0 00              LDY   #$00              ; clear index
009349  1               LAB_1D5D
009349  1  86 AB              STX   Vrschh            ; save search address high byte
00934B  1               LAB_1D5F
00934B  1  85 AA              STA   Vrschl            ; save search address low byte
00934D  1  E4 7E              CPX   Sarryh            ; compare high address with var space end
00934F  1  D0 04              BNE   LAB_1D69          ; skip next compare if <>
009351  1               
009351  1                                             ; high addresses were = so compare low addresses
009351  1  C5 7D              CMP   Sarryl            ; compare low address with var space end
009353  1  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
009355  1               
009355  1               LAB_1D69
009355  1  A5 93              LDA   Varnm1            ; get 1st character of var to find
009357  1  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
009359  1  D0 08              BNE   LAB_1D77          ; branch if no match
00935B  1               
00935B  1                                             ; 1st characters match so compare 2nd characters
00935B  1  A5 94              LDA   Varnm2            ; get 2nd character of var to find
00935D  1  C8                 INY                     ; index to point to variable name 2nd character
00935E  1  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
009360  1  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
009362  1               
009362  1  88                 DEY                     ; else decrement index (now = $00)
009363  1               LAB_1D77
009363  1  18                 CLC                     ; clear carry for add
009364  1  A5 AA              LDA   Vrschl            ; get search address low byte
009366  1  69 06              ADC   #$06              ; +6 (offset to next var name)
009368  1  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
00936A  1               
00936A  1  E8                 INX                     ; else increment high byte
00936B  1  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
00936D  1               
00936D  1               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
00936D  1               
00936D  1               LAB_CASC
00936D  1  C9 61              CMP   #'a'              ; compare with "a"
00936F  1  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
009371  1               
009371  1               ; check byte, return C=0 if<"A" or >"Z"
009371  1               
009371  1               LAB_1D82
009371  1  C9 41              CMP   #'A'              ; compare with "A"
009373  1  90 05              BCC   LAB_1D8A          ; exit if less
009375  1               
009375  1                                             ; carry is set
009375  1  E9 5B              SBC   #$5B              ; subtract "Z"+1
009377  1  38                 SEC                     ; set carry
009378  1  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
00937A  1                                             ; carry clear if byte>$5A
00937A  1               LAB_1D8A
00937A  1  60                 RTS
00937B  1               
00937B  1               LAB_1D83
00937B  1  E9 7B              SBC   #$7B              ; subtract "z"+1
00937D  1  38                 SEC                     ; set carry
00937E  1  E9 85              SBC   #$85              ; subtract $85 (restore byte)
009380  1                                             ; carry clear if byte>$7A
009380  1  60                 RTS
009381  1               
009381  1                                             ; reached end of variable mem without match
009381  1                                             ; .. so create new variable
009381  1               LAB_1D8B
009381  1  68                 PLA                     ; pop return address low byte
009382  1  48                 PHA                     ; push return address low byte
009383  1               LAB_1C18p2  = LAB_1C18+2
009383  1  C9 8C              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
009385  1  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
009387  1               
009387  1               ; This will only drop through if the call was from LAB_1C18 and is only called
009387  1               ; from there if it is searching for a variable from the RHS of a LET a=b statement
009387  1               ; it prevents the creation of variables not assigned a value.
009387  1               
009387  1               ; value returned by this is either numeric zero (exponent byte is $00) or null string
009387  1               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
009387  1               
009387  1               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
009387  1               
009387  1               ; this is where you would put the undefined variable error call e.g.
009387  1               
009387  1               ;                             ; variable doesn't exist so flag error
009387  1               ;     LDX   #$24              ; error code $24 ("undefined variable" error)
009387  1               ;     JMP   LAB_XERR          ; do error #X then warm start
009387  1               
009387  1               ; the above code has been tested and works a treat! (it replaces the three code lines
009387  1               ; below)
009387  1               
009387  1                                             ; else return dummy null value
009387  1  A9 33              LDA   #<LAB_1D96        ; low byte point to $00,$00
009389  1                                             ; (uses part of misc constants table)
009389  1  A0 B4              LDY   #>LAB_1D96        ; high byte point to $00,$00
00938B  1  60                 RTS
00938C  1               
00938C  1                                             ; create new numeric variable
00938C  1               LAB_1D98
00938C  1  A5 7D              LDA   Sarryl            ; get var mem end low byte
00938E  1  A4 7E              LDY   Sarryh            ; get var mem end high byte
009390  1  85 AA              STA   Ostrtl            ; save old block start low byte
009392  1  84 AB              STY   Ostrth            ; save old block start high byte
009394  1  A5 7F              LDA   Earryl            ; get array mem end low byte
009396  1  A4 80              LDY   Earryh            ; get array mem end high byte
009398  1  85 A6              STA   Obendl            ; save old block end low byte
00939A  1  84 A7              STY   Obendh            ; save old block end high byte
00939C  1  18                 CLC                     ; clear carry for add
00939D  1  69 06              ADC   #$06              ; +6 (space for one var)
00939F  1  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
0093A1  1               
0093A1  1  C8                 INY                     ; else increment high byte
0093A2  1               LAB_1DAE
0093A2  1  85 A4              STA   Nbendl            ; set new block end low byte
0093A4  1  84 A5              STY   Nbendh            ; set new block end high byte
0093A6  1  20 8F 84           JSR   LAB_11CF          ; open up space in memory
0093A9  1  A5 A4              LDA   Nbendl            ; get new start low byte
0093AB  1  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
0093AD  1  C8                 INY                     ; correct high byte
0093AE  1  85 7D              STA   Sarryl            ; save new var mem end low byte
0093B0  1  84 7E              STY   Sarryh            ; save new var mem end high byte
0093B2  1  A0 00              LDY   #$00              ; clear index
0093B4  1  A5 93              LDA   Varnm1            ; get var name 1st character
0093B6  1  91 AA              STA   (Vrschl),Y        ; save var name 1st character
0093B8  1  C8                 INY                     ; increment index
0093B9  1  A5 94              LDA   Varnm2            ; get var name 2nd character
0093BB  1  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
0093BD  1  A9 00              LDA   #$00              ; clear A
0093BF  1  C8                 INY                     ; increment index
0093C0  1  91 AA              STA   (Vrschl),Y        ; initialise var byte
0093C2  1  C8                 INY                     ; increment index
0093C3  1  91 AA              STA   (Vrschl),Y        ; initialise var byte
0093C5  1  C8                 INY                     ; increment index
0093C6  1  91 AA              STA   (Vrschl),Y        ; initialise var byte
0093C8  1  C8                 INY                     ; increment index
0093C9  1  91 AA              STA   (Vrschl),Y        ; initialise var byte
0093CB  1               
0093CB  1                                             ; found a match for var ((Vrschl) = ptr)
0093CB  1               LAB_1DD7
0093CB  1  A5 AA              LDA   Vrschl            ; get var address low byte
0093CD  1  18                 CLC                     ; clear carry for add
0093CE  1  69 02              ADC   #$02              ; +2 (offset past var name bytes)
0093D0  1  A4 AB              LDY   Vrschh            ; get var address high byte
0093D2  1  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
0093D4  1               
0093D4  1  C8                 INY                     ; else increment high byte
0093D5  1               LAB_1DE1
0093D5  1  85 95              STA   Cvaral            ; save current var address low byte
0093D7  1  84 96              STY   Cvarah            ; save current var address high byte
0093D9  1  60                 RTS
0093DA  1               
0093DA  1               ; set-up array pointer (Adatal/h) to first element in array
0093DA  1               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
0093DA  1               
0093DA  1               LAB_1DE6
0093DA  1  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
0093DC  1  0A                 ASL                     ; *2 (also clears the carry !)
0093DD  1  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
0093DF  1  65 AA              ADC   Astrtl            ; add array start pointer low byte
0093E1  1  A4 AB              LDY   Astrth            ; get array pointer high byte
0093E3  1  90 01              BCC   LAB_1DF2          ; branch if no overflow
0093E5  1               
0093E5  1  C8                 INY                     ; else increment high byte
0093E6  1               LAB_1DF2
0093E6  1  85 A4              STA   Adatal            ; save array data pointer low byte
0093E8  1  84 A5              STY   Adatah            ; save array data pointer high byte
0093EA  1  60                 RTS
0093EB  1               
0093EB  1               ; evaluate integer expression
0093EB  1               
0093EB  1               LAB_EVIN
0093EB  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0093EE  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0093F1  1                                             ; else do type mismatch
0093F1  1               
0093F1  1               ; evaluate integer expression (no check)
0093F1  1               
0093F1  1               LAB_EVPI
0093F1  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
0093F3  1  30 0D              BMI   LAB_1E12          ; do function call error if -ve
0093F5  1               
0093F5  1               ; evaluate integer expression (no sign check)
0093F5  1               
0093F5  1               LAB_EVIR
0093F5  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0093F7  1  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
0093F9  1  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
0093FB  1               
0093FB  1  A9 3A              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
0093FD  1  A0 B4              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
0093FF  1  20 72 9E           JSR   LAB_27F8          ; compare FAC1 with (AY)
009402  1               LAB_1E12
009402  1  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
009404  1               
009404  1               LAB_1E14
009404  1  4C AB 9E           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
009407  1               
009407  1               ; find or make array
009407  1               
009407  1               LAB_1E17
009407  1  A5 5E              LDA   Defdim            ; get DIM flag
009409  1  48                 PHA                     ; push it
00940A  1  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00940C  1  48                 PHA                     ; push it
00940D  1  A0 00              LDY   #$00              ; clear dimensions count
00940F  1               
00940F  1               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
00940F  1               
00940F  1               LAB_1E1F
00940F  1  98                 TYA                     ; copy dimensions count
009410  1  48                 PHA                     ; save it
009411  1  A5 94              LDA   Varnm2            ; get array name 2nd byte
009413  1  48                 PHA                     ; save it
009414  1  A5 93              LDA   Varnm1            ; get array name 1st byte
009416  1  48                 PHA                     ; save it
009417  1  20 EB 93           JSR   LAB_EVIN          ; evaluate integer expression
00941A  1  68                 PLA                     ; pull array name 1st byte
00941B  1  85 93              STA   Varnm1            ; restore array name 1st byte
00941D  1  68                 PLA                     ; pull array name 2nd byte
00941E  1  85 94              STA   Varnm2            ; restore array name 2nd byte
009420  1  68                 PLA                     ; pull dimensions count
009421  1  A8                 TAY                     ; restore it
009422  1  BA                 TSX                     ; copy stack pointer
009423  1  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
009426  1  48                 PHA                     ; push it
009427  1  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
00942A  1  48                 PHA                     ; push it
00942B  1  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
00942D  1  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
009430  1  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
009432  1  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
009435  1  C8                 INY                     ; increment dimensions count
009436  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
009439  1  C9 2C              CMP   #','              ; compare with ","
00943B  1  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
00943D  1               
00943D  1  84 5D              STY   Dimcnt            ; store dimensions count
00943F  1  20 3E 91           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
009442  1  68                 PLA                     ; pull data type flag
009443  1  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
009445  1  68                 PLA                     ; pull DIM flag
009446  1  85 5E              STA   Defdim            ; restore DIM flag
009448  1  A6 7D              LDX   Sarryl            ; get array mem start low byte
00944A  1  A5 7E              LDA   Sarryh            ; get array mem start high byte
00944C  1               
00944C  1               ; now check to see if we are at the end of array memory (we would be if there were
00944C  1               ; no arrays).
00944C  1               
00944C  1               LAB_1E5C
00944C  1  86 AA              STX   Astrtl            ; save as array start pointer low byte
00944E  1  85 AB              STA   Astrth            ; save as array start pointer high byte
009450  1  C5 80              CMP   Earryh            ; compare with array mem end high byte
009452  1  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
009454  1               
009454  1  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
009456  1  F0 39              BEQ   LAB_1EA1          ; go build array if not found
009458  1               
009458  1                                             ; search for array
009458  1               LAB_1E68
009458  1  A0 00              LDY   #$00              ; clear index
00945A  1  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
00945C  1  C8                 INY                     ; increment index to second name byte
00945D  1  C5 93              CMP   Varnm1            ; compare with this array name first byte
00945F  1  D0 06              BNE   LAB_1E77          ; branch if no match
009461  1               
009461  1  A5 94              LDA   Varnm2            ; else get this array name second byte
009463  1  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
009465  1  F0 16              BEQ   LAB_1E8D          ; array found so branch
009467  1               
009467  1                                             ; no match
009467  1               LAB_1E77
009467  1  C8                 INY                     ; increment index
009468  1  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
00946A  1  18                 CLC                     ; clear carry for add
00946B  1  65 AA              ADC   Astrtl            ; add array start pointer low byte
00946D  1  AA                 TAX                     ; copy low byte to X
00946E  1  C8                 INY                     ; increment index
00946F  1  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
009471  1  65 AB              ADC   Astrth            ; add array mem pointer high byte
009473  1  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
009475  1               
009475  1               ; do array bounds error
009475  1               
009475  1               LAB_1E85
009475  1  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
009477  1  2C                 .byte $2C               ; makes next bit BIT LAB_08A2
009478  1               
009478  1               ; do function call error
009478  1               
009478  1               LAB_FCER
009478  1  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
00947A  1               LAB_1E8A
00947A  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
00947D  1               
00947D  1                                             ; found array, are we trying to dimension it?
00947D  1               LAB_1E8D
00947D  1  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
00947F  1  A5 5E              LDA   Defdim            ; get DIM flag
009481  1  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
009483  1                                             ; start
009483  1               
009483  1               ; found the array and we're not dimensioning it so we must find an element in it
009483  1               
009483  1  20 DA 93           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
009486  1                                             ; (Astrtl,Astrth points to start of array)
009486  1  A5 5D              LDA   Dimcnt            ; get dimensions count
009488  1  A0 04              LDY   #$04              ; set index to array's # of dimensions
00948A  1  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
00948C  1  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
00948E  1                                             ; dimensions" error here .. if we want a different
00948E  1                                             ; error message
00948E  1               
00948E  1  4C 14 95           JMP   LAB_1F28          ; found array so go get element
009491  1                                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
009491  1                                             ; Dimcnt and save it at (Astrtl),Y which is already the
009491  1                                             ; same or we would have taken the BNE)
009491  1               
009491  1                                             ; array not found, so build it
009491  1               LAB_1EA1
009491  1  20 DA 93           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
009494  1                                             ; (Astrtl,Astrth points to start of array)
009494  1  20 D9 84           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
009497  1                                             ; addr to check is in AY (low/high)
009497  1  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
009499  1  84 BB              STY   Aspth             ; clear array data size high byte
00949B  1  A5 93              LDA   Varnm1            ; get variable name 1st byte
00949D  1  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
00949F  1  C8                 INY                     ; increment index
0094A0  1  A5 94              LDA   Varnm2            ; get variable name 2nd byte
0094A2  1  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
0094A4  1  A5 5D              LDA   Dimcnt            ; get dimensions count
0094A6  1  A0 04              LDY   #$04              ; index to dimension count
0094A8  1  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
0094AA  1  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
0094AC  1               
0094AC  1                                             ; now calculate the size of the data space for the array
0094AC  1  18                 CLC                     ; clear carry for add (clear on subsequent loops)
0094AD  1               LAB_1EC0
0094AD  1  A2 0B              LDX   #$0B              ; set default dimension value low byte
0094AF  1  A9 00              LDA   #$00              ; set default dimension value high byte
0094B1  1  24 5E              BIT   Defdim            ; test default DIM flag
0094B3  1  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
0094B5  1               
0094B5  1  68                 PLA                     ; else pull dimension value low byte
0094B6  1  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
0094B8  1  AA                 TAX                     ; copy low byte to X
0094B9  1  68                 PLA                     ; pull dimension value high byte
0094BA  1  69 00              ADC   #$00              ; add carry from low byte
0094BC  1               
0094BC  1               LAB_1ED0
0094BC  1  C8                 INY                     ; index to dimension value high byte
0094BD  1  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
0094BF  1  C8                 INY                     ; index to dimension value high byte
0094C0  1  8A                 TXA                     ; get dimension value low byte
0094C1  1  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
0094C3  1  20 63 95           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
0094C6  1  86 BA              STX   Asptl             ; save array data size low byte
0094C8  1  85 BB              STA   Aspth             ; save array data size high byte
0094CA  1  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
0094CC  1  C6 5D              DEC   Dimcnt            ; decrement dimensions count
0094CE  1  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
0094D0  1               
0094D0  1  65 A5              ADC   Adatah            ; add size high byte to first element high byte
0094D2  1                                             ; (carry is always clear here)
0094D2  1  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
0094D4  1               
0094D4  1  85 A5              STA   Adatah            ; save end of array high byte
0094D6  1  A8                 TAY                     ; copy end high byte to Y
0094D7  1  8A                 TXA                     ; get array size low byte
0094D8  1  65 A4              ADC   Adatal            ; add array start low byte
0094DA  1  90 03              BCC   LAB_1EF3          ; branch if no carry
0094DC  1               
0094DC  1  C8                 INY                     ; else increment end of array high byte
0094DD  1  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
0094DF  1               
0094DF  1                                             ; set-up mostly complete, now zero the array
0094DF  1               LAB_1EF3
0094DF  1  20 D9 84           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
0094E2  1                                             ; addr to check is in AY (low/high)
0094E2  1  85 7F              STA   Earryl            ; save array mem end low byte
0094E4  1  84 80              STY   Earryh            ; save array mem end high byte
0094E6  1  A9 00              LDA   #$00              ; clear byte for array clear
0094E8  1  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
0094EA  1  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
0094EC  1  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
0094EE  1               
0094EE  1               LAB_1F02
0094EE  1  88                 DEY                     ; decrement index (do 0 to n-1)
0094EF  1  91 A4              STA   (Adatal),Y        ; zero byte
0094F1  1  D0 FB              BNE   LAB_1F02          ; loop until this block done
0094F3  1               
0094F3  1               LAB_1F07
0094F3  1  C6 A5              DEC   Adatah            ; decrement array pointer high byte
0094F5  1  C6 BB              DEC   Aspth             ; decrement block count high byte
0094F7  1  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
0094F9  1               
0094F9  1  E6 A5              INC   Adatah            ; correct for last loop
0094FB  1  38                 SEC                     ; set carry for subtract
0094FC  1  A0 02              LDY   #$02              ; index to array size low byte
0094FE  1  A5 7F              LDA   Earryl            ; get array mem end low byte
009500  1  E5 AA              SBC   Astrtl            ; subtract array start low byte
009502  1  91 AA              STA   (Astrtl),Y        ; save array size low byte
009504  1  C8                 INY                     ; index to array size high byte
009505  1  A5 80              LDA   Earryh            ; get array mem end high byte
009507  1  E5 AB              SBC   Astrth            ; subtract array start high byte
009509  1  91 AA              STA   (Astrtl),Y        ; save array size high byte
00950B  1  A5 5E              LDA   Defdim            ; get default DIM flag
00950D  1  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
00950F  1               
00950F  1                                             ; else, find element
00950F  1  C8                 INY                     ; index to # of dimensions
009510  1               
009510  1               LAB_1F24
009510  1  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
009512  1  85 5D              STA   Dimcnt            ; save it
009514  1               
009514  1               ; we have found, or built, the array. now we need to find the element
009514  1               
009514  1               LAB_1F28
009514  1  A9 00              LDA   #$00              ; clear byte
009516  1  85 BA              STA   Asptl             ; clear array data pointer low byte
009518  1               LAB_1F2C
009518  1  85 BB              STA   Aspth             ; save array data pointer high byte
00951A  1  C8                 INY                     ; increment index (point to array bound high byte)
00951B  1  68                 PLA                     ; pull array index low byte
00951C  1  AA                 TAX                     ; copy to X
00951D  1  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
00951F  1  68                 PLA                     ; pull array index high byte
009520  1  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
009522  1  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
009524  1  90 0E              BCC   LAB_1F48          ; branch if within bounds
009526  1               
009526  1  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
009528  1               
009528  1                                             ; else high byte was = so test low bytes
009528  1  C8                 INY                     ; index to array bound low byte
009529  1  8A                 TXA                     ; get array index low byte
00952A  1  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
00952C  1  90 07              BCC   LAB_1F49          ; branch if within bounds
00952E  1               
00952E  1               LAB_1F42
00952E  1  4C 75 94           JMP   LAB_1E85          ; else do array bounds error
009531  1               
009531  1               LAB_1F45
009531  1  4C 36 85           JMP   LAB_OMER          ; do "Out of memory" error then warm start
009534  1               
009534  1               LAB_1F48
009534  1  C8                 INY                     ; index to array bound low byte
009535  1               LAB_1F49
009535  1  A5 BB              LDA   Aspth             ; get array data pointer high byte
009537  1  05 BA              ORA   Asptl             ; OR with array data pointer low byte
009539  1  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
00953B  1               
00953B  1  20 63 95           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
00953E  1  8A                 TXA                     ; get result low byte
00953F  1  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
009541  1  AA                 TAX                     ; save result low byte
009542  1  98                 TYA                     ; get result high byte
009543  1  A4 71              LDY   ut1_pl            ; restore index
009545  1               LAB_1F5A
009545  1  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
009547  1  86 BA              STX   Asptl             ; save array data pointer low byte
009549  1  C6 5D              DEC   Dimcnt            ; decrement dimensions count
00954B  1  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
00954D  1               
00954D  1  06 BA              ASL   Asptl             ; array data pointer low byte * 2
00954F  1  2A                 ROL                     ; array data pointer high byte * 2
009550  1  06 BA              ASL   Asptl             ; array data pointer low byte * 4
009552  1  2A                 ROL                     ; array data pointer high byte * 4
009553  1  A8                 TAY                     ; copy high byte
009554  1  A5 BA              LDA   Asptl             ; get low byte
009556  1  65 A4              ADC   Adatal            ; add array data start pointer low byte
009558  1  85 95              STA   Cvaral            ; save as current var address low byte
00955A  1  98                 TYA                     ; get high byte back
00955B  1  65 A5              ADC   Adatah            ; add array data start pointer high byte
00955D  1  85 96              STA   Cvarah            ; save as current var address high byte
00955F  1  A8                 TAY                     ; copy high byte to Y
009560  1  A5 95              LDA   Cvaral            ; get current var address low byte
009562  1               LAB_1F7B
009562  1  60                 RTS
009563  1               
009563  1               ; does XY = (Astrtl),Y * (Asptl)
009563  1               
009563  1               LAB_1F7C
009563  1  84 71              STY   ut1_pl            ; save index
009565  1  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
009567  1  85 76              STA   dims_l            ; save dimension size low byte
009569  1  88                 DEY                     ; decrement index
00956A  1  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
00956C  1  85 77              STA   dims_h            ; save dimension size high byte
00956E  1               
00956E  1  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
009570  1  85 A8              STA   numbit            ; save bit count
009572  1  A2 00              LDX   #$00              ; clear result low byte
009574  1  A0 00              LDY   #$00              ; clear result high byte
009576  1               LAB_1F8F
009576  1  8A                 TXA                     ; get result low byte
009577  1  0A                 ASL                     ; *2
009578  1  AA                 TAX                     ; save result low byte
009579  1  98                 TYA                     ; get result high byte
00957A  1  2A                 ROL                     ; *2
00957B  1  A8                 TAY                     ; save result high byte
00957C  1  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00957E  1               
00957E  1  06 BA              ASL   Asptl             ; shift multiplier low byte
009580  1  26 BB              ROL   Aspth             ; shift multiplier high byte
009582  1  90 0B              BCC   LAB_1FA8          ; skip add if no carry
009584  1               
009584  1  18                 CLC                     ; else clear carry for add
009585  1  8A                 TXA                     ; get result low byte
009586  1  65 76              ADC   dims_l            ; add dimension size low byte
009588  1  AA                 TAX                     ; save result low byte
009589  1  98                 TYA                     ; get result high byte
00958A  1  65 77              ADC   dims_h            ; add dimension size high byte
00958C  1  A8                 TAY                     ; save result high byte
00958D  1  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00958F  1               
00958F  1               LAB_1FA8
00958F  1  C6 A8              DEC   numbit            ; decrement bit count
009591  1  D0 E3              BNE   LAB_1F8F          ; loop until all done
009593  1               
009593  1  60                 RTS
009594  1               
009594  1               ; perform FRE()
009594  1               
009594  1               LAB_FRE
009594  1  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
009596  1  10 03              BPL   LAB_1FB4          ; branch if numeric
009598  1               
009598  1  20 9A 98           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00959B  1                                             ; space returns with A = length, X=$71=pointer low byte,
00959B  1                                             ; Y=$72=pointer high byte
00959B  1               
00959B  1                                             ; FRE(n) was numeric so do this
00959B  1               LAB_1FB4
00959B  1  20 3B 97           JSR   LAB_GARB          ; go do garbage collection
00959E  1  38                 SEC                     ; set carry for subtract
00959F  1  A5 81              LDA   Sstorl            ; get bottom of string space low byte
0095A1  1  E5 7F              SBC   Earryl            ; subtract array mem end low byte
0095A3  1  A8                 TAY                     ; copy result to Y
0095A4  1  A5 82              LDA   Sstorh            ; get bottom of string space high byte
0095A6  1  E5 80              SBC   Earryh            ; subtract array mem end high byte
0095A8  1               
0095A8  1               ; save and convert integer AY to FAC1
0095A8  1               
0095A8  1               LAB_AYFC
0095A8  1  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
0095AA  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
0095AC  1  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
0095AE  1  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
0095B0  1  4C 5D 9E           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
0095B3  1               
0095B3  1               .ifdef APPLE2
0095B3  1               ; unsigned version of the above.  It shares 8 of 11 bytes with the above
0095B3  1               ; but it's a wash to split out the common code.
0095B3  1               LAB_UAYFC
0095B3  1  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
0095B5  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
0095B7  1  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
0095B9  1  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
0095BB  1  38                 SEC                     ; always positive
0095BC  1  4C 62 9E           JMP   LAB_STFA          ; set exp=X, clear FAC1_3, normalise and return
0095BF  1               .endif
0095BF  1               
0095BF  1               ; perform POS()
0095BF  1               
0095BF  1               LAB_POS
0095BF  1  A4 0E              LDY   TPos              ; get terminal position
0095C1  1               
0095C1  1               ; convert Y to byte in FAC1
0095C1  1               
0095C1  1               LAB_1FD0
0095C1  1  A9 00              LDA   #$00              ; clear high byte
0095C3  1  F0 E3              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
0095C5  1               
0095C5  1               ; check not Direct (used by DEF and INPUT)
0095C5  1               
0095C5  1               LAB_CKRN
0095C5  1  A6 88              LDX   Clineh            ; get current line high byte
0095C7  1  E8                 INX                     ; increment it
0095C8  1  D0 98              BNE   LAB_1F7B          ; return if can continue not direct mode
0095CA  1               
0095CA  1                                             ; else do illegal direct error
0095CA  1               LAB_1FD9
0095CA  1  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
0095CC  1               LAB_1FDB
0095CC  1  4C 38 85           JMP   LAB_XERR          ; go do error #X, then warm start
0095CF  1               
0095CF  1               ; perform DEF
0095CF  1               
0095CF  1               LAB_DEF
0095CF  1  20 00 96           JSR   LAB_200B          ; check FNx syntax
0095D2  1  85 9C              STA   func_l            ; save function pointer low byte
0095D4  1  84 9D              STY   func_h            ; save function pointer high byte
0095D6  1  20 C5 95           JSR   LAB_CKRN          ; check not Direct (back here if ok)
0095D9  1  20 49 91           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
0095DC  1  A9 80              LDA   #$80              ; set flag for FNx
0095DE  1  85 61              STA   Sufnxf            ; save subscript/FNx flag
0095E0  1  20 F9 92           JSR   LAB_GVAR          ; get (var) address
0095E3  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
0095E6  1  20 3E 91           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
0095E9  1  A9 CD              LDA   #TK_EQUAL         ; get = token
0095EB  1  20 40 91           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
0095EE  1  A5 96              LDA   Cvarah            ; get current var address high byte
0095F0  1  48                 PHA                     ; push it
0095F1  1  A5 95              LDA   Cvaral            ; get current var address low byte
0095F3  1  48                 PHA                     ; push it
0095F4  1  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
0095F6  1  48                 PHA                     ; push it
0095F7  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0095F9  1  48                 PHA                     ; push it
0095FA  1  20 CD 8B           JSR   LAB_DATA          ; go perform DATA
0095FD  1  4C 6F 96           JMP   LAB_207A          ; put execute pointer and variable pointer into function
009600  1                                             ; and return
009600  1               
009600  1               ; check FNx syntax
009600  1               
009600  1               LAB_200B
009600  1  A9 B9              LDA   #TK_FN            ; get FN" token
009602  1  20 40 91           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
009605  1                                             ; return character after A
009605  1  09 80              ORA   #$80              ; set FN flag bit
009607  1  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
009609  1  20 00 93           JSR   LAB_1D12          ; search for FN variable
00960C  1  4C 1F 90           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
00960F  1                                             ; mismatch
00960F  1               
00960F  1                                             ; Evaluate FNx
00960F  1               LAB_201E
00960F  1  20 00 96           JSR   LAB_200B          ; check FNx syntax
009612  1  48                 PHA                     ; push function pointer low byte
009613  1  98                 TYA                     ; copy function pointer high byte
009614  1  48                 PHA                     ; push function pointer high byte
009615  1  20 49 91           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
009618  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
00961B  1  20 3E 91           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00961E  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
009621  1  68                 PLA                     ; pop function pointer high byte
009622  1  85 9D              STA   func_h            ; restore it
009624  1  68                 PLA                     ; pop function pointer low byte
009625  1  85 9C              STA   func_l            ; restore it
009627  1  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
009629  1  A0 03              LDY   #$03              ; index to variable pointer high byte
00962B  1  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
00962D  1  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
00962F  1               
00962F  1  85 96              STA   Cvarah            ; save variable address high byte
009631  1  88                 DEY                     ; index to variable address low byte
009632  1  B1 9C              LDA   (func_l),Y        ; get variable address low byte
009634  1  85 95              STA   Cvaral            ; save variable address low byte
009636  1  AA                 TAX                     ; copy address low byte
009637  1               
009637  1                                             ; now stack the function variable value before use
009637  1  C8                 INY                     ; index to mantissa_3
009638  1               LAB_2043
009638  1  B1 95              LDA   (Cvaral),Y        ; get byte from variable
00963A  1  48                 PHA                     ; stack it
00963B  1  88                 DEY                     ; decrement index
00963C  1  10 FA              BPL   LAB_2043          ; loop until variable stacked
00963E  1               
00963E  1  A4 96              LDY   Cvarah            ; get variable address high byte
009640  1  20 02 9E           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
009643  1                                             ; (function variable), return Y=0, always
009643  1  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
009645  1  48                 PHA                     ; push it
009646  1  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
009648  1  48                 PHA                     ; push it
009649  1  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
00964B  1  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
00964D  1  C8                 INY                     ; index to high byte
00964E  1  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
009650  1  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
009652  1  A5 96              LDA   Cvarah            ; get variable address high byte
009654  1  48                 PHA                     ; push it
009655  1  A5 95              LDA   Cvaral            ; get variable address low byte
009657  1  48                 PHA                     ; push it
009658  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00965B  1                                             ; else do type mismatch
00965B  1  68                 PLA                     ; pull variable address low byte
00965C  1  85 9C              STA   func_l            ; save variable address low byte
00965E  1  68                 PLA                     ; pull variable address high byte
00965F  1  85 9D              STA   func_h            ; save variable address high byte
009661  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
009664  1  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
009666  1               
009666  1  4C 51 91           JMP   LAB_SNER          ; else syntax error then warm start
009669  1               
009669  1               ; restore Bpntrl,Bpntrh and function variable from stack
009669  1               
009669  1               LAB_2074
009669  1  68                 PLA                     ; pull BASIC execute pointer low byte
00966A  1  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
00966C  1  68                 PLA                     ; pull BASIC execute pointer high byte
00966D  1  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
00966F  1               
00966F  1               ; put execute pointer and variable pointer into function
00966F  1               
00966F  1               LAB_207A
00966F  1  A0 00              LDY   #$00              ; clear index
009671  1  68                 PLA                     ; pull BASIC execute pointer low byte
009672  1  91 9C              STA   (func_l),Y        ; save to function
009674  1  C8                 INY                     ; increment index
009675  1  68                 PLA                     ; pull BASIC execute pointer high byte
009676  1  91 9C              STA   (func_l),Y        ; save to function
009678  1  C8                 INY                     ; increment index
009679  1  68                 PLA                     ; pull current var address low byte
00967A  1  91 9C              STA   (func_l),Y        ; save to function
00967C  1  C8                 INY                     ; increment index
00967D  1  68                 PLA                     ; pull current var address high byte
00967E  1  91 9C              STA   (func_l),Y        ; save to function
009680  1  60                 RTS
009681  1               
009681  1               ; perform STR$()
009681  1               
009681  1               LAB_STRS
009681  1  20 1F 90           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
009684  1  20 F0 9F           JSR   LAB_296E          ; convert FAC1 to string
009687  1  A9 F0              LDA   #<Decssp1         ; set result string low pointer
009689  1  A0 00              LDY   #>Decssp1         ; set result string high pointer
00968B  1  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
00968D  1               
00968D  1               ; Do string vector
00968D  1               ; copy des_pl/h to des_2l/h and make string space A bytes long
00968D  1               
00968D  1               LAB_209C
00968D  1  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
00968F  1  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
009691  1  86 9E              STX   des_2l            ; save descriptor pointer low byte
009693  1  84 9F              STY   des_2h            ; save descriptor pointer high byte
009695  1               
009695  1               ; make string space A bytes long
009695  1               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009695  1               
009695  1               LAB_MSSP
009695  1  20 09 97           JSR   LAB_2115          ; make space in string memory for string A long
009698  1                                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009698  1  86 AD              STX   str_pl            ; save string pointer low byte
00969A  1  84 AE              STY   str_ph            ; save string pointer high byte
00969C  1  85 AC              STA   str_ln            ; save length
00969E  1  60                 RTS
00969F  1               
00969F  1               ; Scan, set up string
00969F  1               ; print " terminated string to Sutill/Sutilh
00969F  1               
00969F  1               LAB_20AE
00969F  1  A2 22              LDX   #$22              ; set terminator to "
0096A1  1  86 5B              STX   Srchc             ; set search character (terminator 1)
0096A3  1  86 5C              STX   Asrch             ; set terminator 2
0096A5  1               
0096A5  1               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
0096A5  1               ; source is AY
0096A5  1               
0096A5  1               LAB_20B4
0096A5  1  85 B8              STA   ssptr_l           ; store string start low byte
0096A7  1  84 B9              STY   ssptr_h           ; store string start high byte
0096A9  1  85 AD              STA   str_pl            ; save string pointer low byte
0096AB  1  84 AE              STY   str_ph            ; save string pointer high byte
0096AD  1  A0 FF              LDY   #$FF              ; set length to -1
0096AF  1               LAB_20BE
0096AF  1  C8                 INY                     ; increment length
0096B0  1  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
0096B2  1  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
0096B4  1               
0096B4  1  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
0096B6  1  F0 04              BEQ   LAB_20CB          ; branch if terminator
0096B8  1               
0096B8  1  C5 5C              CMP   Asrch             ; compare with terminator 2
0096BA  1  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
0096BC  1               
0096BC  1               LAB_20CB
0096BC  1  C9 22              CMP   #$22              ; compare with "
0096BE  1  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
0096C0  1               
0096C0  1               LAB_20CF
0096C0  1  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
0096C1  1               LAB_20D0
0096C1  1  84 AC              STY   str_ln            ; save length in FAC1 exponent
0096C3  1  98                 TYA                     ; copy length to A
0096C4  1  65 B8              ADC   ssptr_l           ; add string start low byte
0096C6  1  85 BA              STA   Sendl             ; save string end low byte
0096C8  1  A6 B9              LDX   ssptr_h           ; get string start high byte
0096CA  1  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
0096CC  1               
0096CC  1  E8                 INX                     ; else increment high byte
0096CD  1               LAB_20DC
0096CD  1  86 BB              STX   Sendh             ; save string end high byte
0096CF  1  A5 B9              LDA   ssptr_h           ; get string start high byte
0096D1  1               .ifdef APPLE2
0096D1  1                     ; This was driving me insane.  The patch below fails for STR$
0096D1  1                     ; because the conversion happens in the zero page, which it leaves
0096D1  1                     ; pointing in the zero page.
0096D1  1  CD rr rr           CMP   RAM_BASE+1
0096D4  1  B0 0B              BCS   LAB_RTST
0096D6  1               .else
0096D6  1               ; *** begin RAM above code / Ibuff above EhBASIC patch ***
0096D6  1               ; *** replace
0096D6  1               ;     CMP   #>Ram_base        ; compare with start of program memory
0096D6  1               ;     BCS   LAB_RTST          ; branch if not in utility area
0096D6  1               ; *** with
0096D6  1                     CMP   #>Ibuffs          ; compare with location of input buffer page
0096D6  1                     BNE   LAB_RTST          ; branch if not in utility area
0096D6  1               ; *** end   RAM above code / Ibuff above EhBASIC patch ***
0096D6  1               .endif
0096D6  1                                             ; string in utility area, move to string memory
0096D6  1  98                 TYA                     ; copy length to A
0096D7  1  20 8D 96           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
0096DA  1                                             ; long
0096DA  1  A6 B8              LDX   ssptr_l           ; get string start low byte
0096DC  1  A4 B9              LDY   ssptr_h           ; get string start high byte
0096DE  1  20 7B 98           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
0096E1  1               
0096E1  1               ; check for space on descriptor stack then ..
0096E1  1               ; put string address and length on descriptor stack and update stack pointers
0096E1  1               
0096E1  1               LAB_RTST
0096E1  1  A6 65              LDX   next_s            ; get string stack pointer
0096E3  1  E0 71              CPX   #des_sk+$09       ; compare with max+1
0096E5  1  D0 05              BNE   LAB_20F8          ; branch if space on string stack
0096E7  1               
0096E7  1                                             ; else do string too complex error
0096E7  1  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
0096E9  1               LAB_20F5
0096E9  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
0096EC  1               
0096EC  1               ; put string address and length on descriptor stack and update stack pointers
0096EC  1               
0096EC  1               LAB_20F8
0096EC  1  A5 AC              LDA   str_ln            ; get string length
0096EE  1  95 00              STA   PLUS_0,X          ; put on string stack
0096F0  1  A5 AD              LDA   str_pl            ; get string pointer low byte
0096F2  1  95 01              STA   PLUS_1,X          ; put on string stack
0096F4  1  A5 AE              LDA   str_ph            ; get string pointer high byte
0096F6  1  95 02              STA   PLUS_2,X          ; put on string stack
0096F8  1  A0 00              LDY   #$00              ; clear Y
0096FA  1  86 AE              STX   des_pl            ; save string descriptor pointer low byte
0096FC  1  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
0096FE  1  88                 DEY                     ; Y = $FF
0096FF  1  84 5F              STY   Dtypef            ; save data type flag, $FF=string
009701  1  86 66              STX   last_sl           ; save old stack pointer (current top item)
009703  1  E8                 INX                     ; update stack pointer
009704  1  E8                 INX                     ; update stack pointer
009705  1  E8                 INX                     ; update stack pointer
009706  1  86 65              STX   next_s            ; save new top item value
009708  1  60                 RTS
009709  1               
009709  1               ; Build descriptor
009709  1               ; make space in string memory for string A long
009709  1               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
009709  1               
009709  1               LAB_2115
009709  1  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
00970B  1               
00970B  1                                             ; make space for string A long
00970B  1               LAB_2117
00970B  1  48                 PHA                     ; save string length
00970C  1  49 FF              EOR   #$FF              ; complement it
00970E  1  38                 SEC                     ; set carry for subtract (twos comp add)
00970F  1  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
009711  1  A4 82              LDY   Sstorh            ; get bottom of string space high byte
009713  1  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
009715  1               
009715  1  88                 DEY                     ; decrement bottom of string space high byte
009716  1               LAB_2122
009716  1  C4 80              CPY   Earryh            ; compare with array mem end high byte
009718  1  90 11              BCC   LAB_2137          ; do out of memory error if less
00971A  1               
00971A  1  D0 04              BNE   LAB_212C          ; if not = skip next test
00971C  1               
00971C  1  C5 7F              CMP   Earryl            ; compare with array mem end low byte
00971E  1  90 0B              BCC   LAB_2137          ; do out of memory error if less
009720  1               
009720  1               LAB_212C
009720  1  85 81              STA   Sstorl            ; save bottom of string space low byte
009722  1  84 82              STY   Sstorh            ; save bottom of string space high byte
009724  1  85 83              STA   Sutill            ; save string utility ptr low byte
009726  1  84 84              STY   Sutilh            ; save string utility ptr high byte
009728  1  AA                 TAX                     ; copy low byte to X
009729  1  68                 PLA                     ; get string length back
00972A  1  60                 RTS
00972B  1               
00972B  1               LAB_2137
00972B  1  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00972D  1  A5 60              LDA   Gclctd            ; get garbage collected flag
00972F  1  30 B8              BMI   LAB_20F5          ; if set then do error code X
009731  1               
009731  1  20 3B 97           JSR   LAB_GARB          ; else go do garbage collection
009734  1  A9 80              LDA   #$80              ; flag for garbage collected
009736  1  85 60              STA   Gclctd            ; set garbage collected flag
009738  1  68                 PLA                     ; pull length
009739  1  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
00973B  1               
00973B  1               ; garbage collection routine
00973B  1               
00973B  1               LAB_GARB
00973B  1  A6 85              LDX   Ememl             ; get end of mem low byte
00973D  1  A5 86              LDA   Ememh             ; get end of mem high byte
00973F  1               
00973F  1               ; re-run routine from last ending
00973F  1               
00973F  1               LAB_214B
00973F  1  86 81              STX   Sstorl            ; set string storage low byte
009741  1  85 82              STA   Sstorh            ; set string storage high byte
009743  1  A0 00              LDY   #$00              ; clear index
009745  1  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
009747  1  A5 7F              LDA   Earryl            ; get array mem end low byte
009749  1  A6 80              LDX   Earryh            ; get array mem end high byte
00974B  1  85 AA              STA   Histrl            ; save as highest string low byte
00974D  1  86 AB              STX   Histrh            ; save as highest string high byte
00974F  1  A9 68              LDA   #des_sk           ; set descriptor stack pointer
009751  1  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
009753  1  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
009755  1               LAB_2161
009755  1  C5 65              CMP   next_s            ; compare with descriptor stack pointer
009757  1  F0 05              BEQ   LAB_216A          ; branch if =
009759  1               
009759  1  20 BF 97           JSR   LAB_21D7          ; go garbage collect descriptor stack
00975C  1  F0 F7              BEQ   LAB_2161          ; loop always
00975E  1               
00975E  1                                             ; done stacked strings, now do string vars
00975E  1               LAB_216A
00975E  1  06 A0              ASL   g_step            ; set step size = $06
009760  1  A5 7B              LDA   Svarl             ; get start of vars low byte
009762  1  A6 7C              LDX   Svarh             ; get start of vars high byte
009764  1  85 71              STA   ut1_pl            ; save as pointer low byte
009766  1  86 72              STX   ut1_ph            ; save as pointer high byte
009768  1               LAB_2176
009768  1  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
00976A  1  D0 04              BNE   LAB_217E          ; branch if no high byte match
00976C  1               
00976C  1  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
00976E  1  F0 05              BEQ   LAB_2183          ; branch if = var mem end
009770  1               
009770  1               LAB_217E
009770  1  20 B9 97           JSR   LAB_21D1          ; go garbage collect strings
009773  1  F0 F3              BEQ   LAB_2176          ; loop always
009775  1               
009775  1                                             ; done string vars, now do string arrays
009775  1               LAB_2183
009775  1  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
009777  1  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
009779  1  A9 04              LDA   #$04              ; set step size
00977B  1  85 A0              STA   g_step            ; save step size
00977D  1               LAB_218B
00977D  1  A5 A4              LDA   Nbendl            ; get pointer low byte
00977F  1  A6 A5              LDX   Nbendh            ; get pointer high byte
009781  1               LAB_218F
009781  1  E4 80              CPX   Earryh            ; compare with array mem end high byte
009783  1  D0 04              BNE   LAB_219A          ; branch if not at end
009785  1               
009785  1  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
009787  1  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
009789  1               
009789  1               LAB_219A
009789  1  85 71              STA   ut1_pl            ; save pointer low byte
00978B  1  86 72              STX   ut1_ph            ; save pointer high byte
00978D  1  A0 02              LDY   #$02              ; set index
00978F  1  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
009791  1  65 A4              ADC   Nbendl            ; add start of this array low byte
009793  1  85 A4              STA   Nbendl            ; save start of next array low byte
009795  1  C8                 INY                     ; increment index
009796  1  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
009798  1  65 A5              ADC   Nbendh            ; add start of this array high byte
00979A  1  85 A5              STA   Nbendh            ; save start of next array high byte
00979C  1  A0 01              LDY   #$01              ; set index
00979E  1  B1 71              LDA   (ut1_pl),Y        ; get name second byte
0097A0  1  10 DB              BPL   LAB_218B          ; skip if not string array
0097A2  1               
0097A2  1               ; was string array so ..
0097A2  1               
0097A2  1  A0 04              LDY   #$04              ; set index
0097A4  1  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
0097A6  1  0A                 ASL                     ; *2
0097A7  1  69 05              ADC   #$05              ; +5 (array header size)
0097A9  1  20 F1 97           JSR   LAB_2208          ; go set up for first element
0097AC  1               LAB_21C4
0097AC  1  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
0097AE  1  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
0097B0  1               
0097B0  1  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
0097B2  1                                             ; low byte
0097B2  1  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
0097B4  1               
0097B4  1               LAB_21CC
0097B4  1  20 BF 97           JSR   LAB_21D7          ; go defrag array strings
0097B7  1  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
0097B9  1               
0097B9  1               ; defrag string variables
0097B9  1               ; enter with XA = variable pointer
0097B9  1               ; return with XA = next variable pointer
0097B9  1               
0097B9  1               LAB_21D1
0097B9  1  C8                 INY                     ; increment index (Y was $00)
0097BA  1  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
0097BC  1  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
0097BE  1               
0097BE  1  C8                 INY                     ; else increment index
0097BF  1               LAB_21D7
0097BF  1  B1 71              LDA   (ut1_pl),Y        ; get string length
0097C1  1  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
0097C3  1               
0097C3  1  C8                 INY                     ; else increment index
0097C4  1  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
0097C6  1  AA                 TAX                     ; copy to X
0097C7  1  C8                 INY                     ; increment index
0097C8  1  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
0097CA  1  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
0097CC  1  90 06              BCC   LAB_21EC          ; branch if less
0097CE  1               
0097CE  1  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
0097D0  1               
0097D0  1                                             ; high bytes were = so compare low bytes
0097D0  1  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
0097D2  1  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
0097D4  1               
0097D4  1                                             ; string pointer is < string storage pointer (pos in mem)
0097D4  1               LAB_21EC
0097D4  1  C5 AB              CMP   Histrh            ; compare to highest string high byte
0097D6  1  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
0097D8  1               
0097D8  1  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
0097DA  1               
0097DA  1                                             ; high bytes were = so compare low bytes
0097DA  1  E4 AA              CPX   Histrl            ; compare to highest string low byte
0097DC  1  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
0097DE  1               
0097DE  1                                             ; string is in string memory space
0097DE  1               LAB_21F6
0097DE  1  86 AA              STX   Histrl            ; save as new highest string low byte
0097E0  1  85 AB              STA   Histrh            ; save as new highest string high byte
0097E2  1  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
0097E4  1  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
0097E6  1  85 9C              STA   garb_l            ; save as working pointer low byte
0097E8  1  86 9D              STX   garb_h            ; save as working pointer high byte
0097EA  1  88                 DEY                     ; decrement index DIFFERS
0097EB  1  88                 DEY                     ; decrement index (should point to descriptor start)
0097EC  1  84 A2              STY   g_indx            ; save index pointer
0097EE  1               
0097EE  1                                             ; step pointer to next string
0097EE  1               LAB_2206
0097EE  1  18                 CLC                     ; clear carry for add
0097EF  1               LAB_2207
0097EF  1  A5 A0              LDA   g_step            ; get step size
0097F1  1               LAB_2208
0097F1  1  65 71              ADC   ut1_pl            ; add pointer low byte
0097F3  1  85 71              STA   ut1_pl            ; save pointer low byte
0097F5  1  90 02              BCC   LAB_2211          ; branch if no overflow
0097F7  1               
0097F7  1  E6 72              INC   ut1_ph            ; else increment high byte
0097F9  1               LAB_2211
0097F9  1  A6 72              LDX   ut1_ph            ; get pointer high byte
0097FB  1  A0 00              LDY   #$00              ; clear Y
0097FD  1  60                 RTS
0097FE  1               
0097FE  1               ; search complete, now either exit or set-up and move string
0097FE  1               
0097FE  1               LAB_2216
0097FE  1  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
009800  1  A6 9D              LDX   garb_h            ; get string to move high byte
009802  1  F0 F5              BEQ   LAB_2211          ; exit if nothing to move
009804  1               
009804  1  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
009806  1  18                 CLC                     ; clear carry for add
009807  1  B1 9C              LDA   (garb_l),Y        ; get string length
009809  1  65 AA              ADC   Histrl            ; add highest string low byte
00980B  1  85 A6              STA   Obendl            ; save old block end low pointer
00980D  1  A5 AB              LDA   Histrh            ; get highest string high byte
00980F  1  69 00              ADC   #$00              ; add any carry
009811  1  85 A7              STA   Obendh            ; save old block end high byte
009813  1  A5 81              LDA   Sstorl            ; get bottom of string space low byte
009815  1  A6 82              LDX   Sstorh            ; get bottom of string space high byte
009817  1  85 A4              STA   Nbendl            ; save new block end low byte
009819  1  86 A5              STX   Nbendh            ; save new block end high byte
00981B  1  20 96 84           JSR   LAB_11D6          ; open up space in memory, don't set array end
00981E  1  A4 A2              LDY   g_indx            ; get index byte
009820  1  C8                 INY                     ; point to descriptor low byte
009821  1  A5 A4              LDA   Nbendl            ; get string pointer low byte
009823  1  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
009825  1  AA                 TAX                     ; copy string pointer low byte
009826  1  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
009828  1  A5 A5              LDA   Nbendh            ; get new string pointer high byte
00982A  1  C8                 INY                     ; point to descriptor high byte
00982B  1  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
00982D  1  4C 3F 97           JMP   LAB_214B          ; re-run routine from last ending
009830  1                                             ; (but don't collect this string)
009830  1               
009830  1               ; concatenate
009830  1               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
009830  1               
009830  1               LAB_224D
009830  1  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
009832  1  48                 PHA                     ; put on stack
009833  1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
009835  1  48                 PHA                     ; put on stack
009836  1  20 1C 91           JSR   LAB_GVAL          ; get value from line
009839  1  20 21 90           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00983C  1  68                 PLA                     ; get descriptor pointer low byte back
00983D  1  85 B8              STA   ssptr_l           ; set pointer low byte
00983F  1  68                 PLA                     ; get descriptor pointer high byte back
009840  1  85 B9              STA   ssptr_h           ; set pointer high byte
009842  1  A0 00              LDY   #$00              ; clear index
009844  1  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
009846  1  18                 CLC                     ; clear carry for add
009847  1  71 AE              ADC   (des_pl),Y        ; add length_2
009849  1  90 05              BCC   LAB_226D          ; branch if no overflow
00984B  1               
00984B  1  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
00984D  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
009850  1               
009850  1               LAB_226D
009850  1  20 8D 96           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
009853  1                                             ; long
009853  1  20 6D 98           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
009856  1  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
009858  1  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00985A  1  20 9E 98           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00985D  1                                             ; returns with A = length, ut1_pl = pointer low byte,
00985D  1                                             ; ut1_ph = pointer high byte
00985D  1  20 7F 98           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
009860  1  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
009862  1  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
009864  1  20 9E 98           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
009867  1                                             ; returns with A = length, X=ut1_pl=pointer low byte,
009867  1                                             ; Y=ut1_ph=pointer high byte
009867  1  20 E1 96           JSR   LAB_RTST          ; check for space on descriptor stack then put string
00986A  1                                             ; address and length on descriptor stack and update stack
00986A  1                                             ; pointers
00986A  1  4C 47 90           JMP   LAB_1ADB          ;.continue evaluation
00986D  1               
00986D  1               ; copy string from descriptor (sdescr) to (Sutill)
00986D  1               
00986D  1               LAB_228A
00986D  1  A0 00              LDY   #$00              ; clear index
00986F  1  B1 B8              LDA   (sdescr),Y        ; get string length
009871  1  48                 PHA                     ; save on stack
009872  1  C8                 INY                     ; increment index
009873  1  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
009875  1  AA                 TAX                     ; copy to X
009876  1  C8                 INY                     ; increment index
009877  1  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
009879  1  A8                 TAY                     ; copy to Y
00987A  1  68                 PLA                     ; get length back
00987B  1               
00987B  1               ; store string A bytes long from YX to (Sutill)
00987B  1               
00987B  1               LAB_2298
00987B  1  86 71              STX   ut1_pl            ; save source string pointer low byte
00987D  1  84 72              STY   ut1_ph            ; save source string pointer high byte
00987F  1               
00987F  1               ; store string A bytes long from (ut1_pl) to (Sutill)
00987F  1               
00987F  1               LAB_229C
00987F  1  AA                 TAX                     ; copy length to index (don't count with Y)
009880  1  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
009882  1               
009882  1  A0 00              LDY   #$00              ; zero pointer (copy forward)
009884  1               LAB_22A0
009884  1  B1 71              LDA   (ut1_pl),Y        ; get source byte
009886  1  91 83              STA   (Sutill),Y        ; save destination byte
009888  1               
009888  1  C8                 INY                     ; increment index
009889  1  CA                 DEX                     ; decrement counter
00988A  1  D0 F8              BNE   LAB_22A0          ; loop while <> 0
00988C  1               
00988C  1  98                 TYA                     ; restore length from Y
00988D  1               LAB_22A9
00988D  1  18                 CLC                     ; clear carry for add
00988E  1  65 83              ADC   Sutill            ; add string utility ptr low byte
009890  1  85 83              STA   Sutill            ; save string utility ptr low byte
009892  1  90 02              BCC   LAB_22B2          ; branch if no carry
009894  1               
009894  1  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
009896  1               LAB_22B2
009896  1  60                 RTS
009897  1               
009897  1               ; evaluate string
009897  1               
009897  1               LAB_EVST
009897  1  20 21 90           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00989A  1               
00989A  1               ; pop string off descriptor stack, or from top of string space
00989A  1               ; returns with A = length, X=pointer low byte, Y=pointer high byte
00989A  1               
00989A  1               LAB_22B6
00989A  1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00989C  1  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00989E  1               
00989E  1               ; pop (YA) descriptor off stack or from top of string space
00989E  1               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
00989E  1               
00989E  1               LAB_22BA
00989E  1  85 71              STA   ut1_pl            ; save descriptor pointer low byte
0098A0  1  84 72              STY   ut1_ph            ; save descriptor pointer high byte
0098A2  1  20 CF 98           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
0098A5  1  08                 PHP                     ; save status flags
0098A6  1  A0 00              LDY   #$00              ; clear index
0098A8  1  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
0098AA  1  48                 PHA                     ; put on stack
0098AB  1  C8                 INY                     ; increment index
0098AC  1  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
0098AE  1  AA                 TAX                     ; copy to X
0098AF  1  C8                 INY                     ; increment index
0098B0  1  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
0098B2  1  A8                 TAY                     ; copy to Y
0098B3  1  68                 PLA                     ; get string length back
0098B4  1  28                 PLP                     ; restore status
0098B5  1  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
0098B7  1               
0098B7  1  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
0098B9  1  D0 0F              BNE   LAB_22E6          ; branch if <>
0098BB  1               
0098BB  1  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
0098BD  1  D0 0B              BNE   LAB_22E6          ; branch if <>
0098BF  1               
0098BF  1  48                 PHA                     ; save string length
0098C0  1  18                 CLC                     ; clear carry for add
0098C1  1  65 81              ADC   Sstorl            ; add bottom of string space low byte
0098C3  1  85 81              STA   Sstorl            ; save bottom of string space low byte
0098C5  1  90 02              BCC   LAB_22E5          ; skip increment if no overflow
0098C7  1               
0098C7  1  E6 82              INC   Sstorh            ; increment bottom of string space high byte
0098C9  1               LAB_22E5
0098C9  1  68                 PLA                     ; restore string length
0098CA  1               LAB_22E6
0098CA  1  86 71              STX   ut1_pl            ; save string pointer low byte
0098CC  1  84 72              STY   ut1_ph            ; save string pointer high byte
0098CE  1  60                 RTS
0098CF  1               
0098CF  1               ; clean descriptor stack, YA = pointer
0098CF  1               ; checks if AY is on the descriptor stack, if so does a stack discard
0098CF  1               
0098CF  1               LAB_22EB
0098CF  1  C4 67              CPY   last_sh           ; compare pointer high byte
0098D1  1  D0 0C              BNE   LAB_22FB          ; exit if <>
0098D3  1               
0098D3  1  C5 66              CMP   last_sl           ; compare pointer low byte
0098D5  1  D0 08              BNE   LAB_22FB          ; exit if <>
0098D7  1               
0098D7  1  85 65              STA   next_s            ; save descriptor stack pointer
0098D9  1  E9 03              SBC   #$03              ; -3
0098DB  1  85 66              STA   last_sl           ; save low byte -3
0098DD  1  A0 00              LDY   #$00              ; clear high byte
0098DF  1               LAB_22FB
0098DF  1  60                 RTS
0098E0  1               
0098E0  1               ; perform CHR$()
0098E0  1               
0098E0  1               LAB_CHRS
0098E0  1  20 EA 99           JSR   LAB_EVBY          ; evaluate byte expression, result in X
0098E3  1               .ifdef APPLE2
0098E3  1  DA                 PHX                     ; 65C02
0098E4  1               .else
0098E4  1                     TXA                     ; copy to A
0098E4  1                     PHA                     ; save character
0098E4  1               .endif
0098E4  1  A9 01              LDA   #$01              ; string is single byte
0098E6  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
0098E9  1                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0098E9  1  68                 PLA                     ; get character back
0098EA  1  A0 00              LDY   #$00              ; clear index
0098EC  1  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
0098EE  1  4C E1 96           JMP   LAB_RTST          ; check for space on descriptor stack then put string
0098F1  1                                             ; address and length on descriptor stack and update stack
0098F1  1                                             ; pointers
0098F1  1               
0098F1  1               ; perform LEFT$()
0098F1  1               
0098F1  1               LAB_LEFT
0098F1  1  48                 PHA                     ; push byte parameter
0098F2  1  20 52 99           JSR   LAB_236F          ; pull string data and byte parameter from stack
0098F5  1                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
0098F5  1  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
0098F7  1  98                 TYA                     ; clear A
0098F8  1  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
0098FA  1               
0098FA  1               ; perform RIGHT$()
0098FA  1               
0098FA  1               LAB_RIGHT
0098FA  1  48                 PHA                     ; push byte parameter
0098FB  1  20 52 99           JSR   LAB_236F          ; pull string data and byte parameter from stack
0098FE  1                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
0098FE  1  18                 CLC                     ; clear carry for add-1
0098FF  1  F1 9E              SBC   (des_2l),Y        ; subtract string length
009901  1  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
009903  1               
009903  1               LAB_2316
009903  1  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
009905  1               
009905  1  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
009907  1  AA                 TAX                     ; copy to byte parameter copy
009908  1  98                 TYA                     ; clear string start offset
009909  1               LAB_231C
009909  1  48                 PHA                     ; save string start offset
00990A  1               LAB_231D
00990A  1  8A                 TXA                     ; copy byte parameter (or string length if <)
00990B  1               LAB_231E
00990B  1  48                 PHA                     ; save string length
00990C  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00990F  1                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00990F  1  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
009911  1  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
009913  1  20 9E 98           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
009916  1                                             ; returns with A = length, X=ut1_pl=pointer low byte,
009916  1                                             ; Y=ut1_ph=pointer high byte
009916  1  68                 PLA                     ; get string length back
009917  1  A8                 TAY                     ; copy length to Y
009918  1  68                 PLA                     ; get string start offset back
009919  1  18                 CLC                     ; clear carry for add
00991A  1  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
00991C  1  85 71              STA   ut1_pl            ; save string start pointer low byte
00991E  1  90 02              BCC   LAB_2335          ; branch if no overflow
009920  1               
009920  1  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
009922  1               LAB_2335
009922  1  98                 TYA                     ; copy length to A
009923  1  20 7F 98           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
009926  1  4C E1 96           JMP   LAB_RTST          ; check for space on descriptor stack then put string
009929  1                                             ; address and length on descriptor stack and update stack
009929  1                                             ; pointers
009929  1               
009929  1               ; perform MID$()
009929  1               
009929  1               LAB_MIDS
009929  1  48                 PHA                     ; push byte parameter
00992A  1  A9 FF              LDA   #$FF              ; set default length = 255
00992C  1  85 AF              STA   mids_l            ; save default length
00992E  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
009931  1  C9 29              CMP   #')'              ; compare with ")"
009933  1  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
009935  1               
009935  1  20 4D 91           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
009938  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
00993B  1               LAB_2358
00993B  1  20 52 99           JSR   LAB_236F          ; pull string data and byte parameter from stack
00993E  1                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00993E  1  CA                 DEX                     ; decrement start index
00993F  1  8A                 TXA                     ; copy to A
009940  1  48                 PHA                     ; save string start offset
009941  1  18                 CLC                     ; clear carry for sub-1
009942  1  A2 00              LDX   #$00              ; clear output string length
009944  1  F1 9E              SBC   (des_2l),Y        ; subtract string length
009946  1  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
009948  1               
009948  1  49 FF              EOR   #$FF              ; complement -length
00994A  1  C5 AF              CMP   mids_l            ; compare byte parameter
00994C  1  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
00994E  1               
00994E  1  A5 AF              LDA   mids_l            ; get length byte
009950  1  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
009952  1               
009952  1               ; pull string data and byte parameter from stack
009952  1               ; return pointer in des_2l/h, byte in A (and X), Y=0
009952  1               
009952  1               LAB_236F
009952  1  20 3E 91           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
009955  1  68                 PLA                     ; pull return address low byte (return address)
009956  1  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
009958  1  68                 PLA                     ; pull return address high byte (return address)
009959  1  85 A3              STA   Fnxjph            ; save functions jump vector high byte
00995B  1  68                 PLA                     ; pull byte parameter
00995C  1  AA                 TAX                     ; copy byte parameter to X
00995D  1  68                 PLA                     ; pull string pointer low byte
00995E  1  85 9E              STA   des_2l            ; save it
009960  1  68                 PLA                     ; pull string pointer high byte
009961  1  85 9F              STA   des_2h            ; save it
009963  1  A0 00              LDY   #$00              ; clear index
009965  1  8A                 TXA                     ; copy byte parameter
009966  1  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
009968  1               
009968  1  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
00996A  1                                             ; (JSR pushes return addr-1. this is all very nice
00996A  1                                             ; but will go tits up if either call is on a page
00996A  1                                             ; boundary!)
00996A  1  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
00996D  1               
00996D  1               ; perform LCASE$()
00996D  1               
00996D  1               LAB_LCASE
00996D  1  20 97 98           JSR   LAB_EVST          ; evaluate string
009970  1  85 AC              STA   str_ln            ; set string length
009972  1  A8                 TAY                     ; copy length to Y
009973  1  F0 38              BEQ   NoString          ; branch if null string
009975  1               
009975  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long A=length,
009978  1                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009978  1  86 AD              STX   str_pl            ; save string pointer low byte
00997A  1  84 AE              STY   str_ph            ; save string pointer high byte
00997C  1  A8                 TAY                     ; get string length back
00997D  1               
00997D  1               LC_loop
00997D  1  88                 DEY                     ; decrement index
00997E  1  B1 71              LDA   (ut1_pl),Y        ; get byte from string
009980  1  20 71 93           JSR   LAB_1D82          ; is character "A" to "Z"
009983  1  90 02              BCC   NoUcase           ; branch if not upper case alpha
009985  1               
009985  1  09 20              ORA   #$20              ; convert upper to lower case
009987  1               NoUcase
009987  1  91 83              STA   (Sutill),Y        ; save byte back to string
009989  1  98                 TYA                     ; test index
00998A  1  D0 F1              BNE   LC_loop           ; loop if not all done
00998C  1               
00998C  1  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
00998E  1               
00998E  1               ; perform UCASE$()
00998E  1               
00998E  1               LAB_UCASE
00998E  1  20 97 98           JSR   LAB_EVST          ; evaluate string
009991  1  85 AC              STA   str_ln            ; set string length
009993  1  A8                 TAY                     ; copy length to Y
009994  1  F0 17              BEQ   NoString          ; branch if null string
009996  1               
009996  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long A=length,
009999  1                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009999  1  86 AD              STX   str_pl            ; save string pointer low byte
00999B  1  84 AE              STY   str_ph            ; save string pointer high byte
00999D  1  A8                 TAY                     ; get string length back
00999E  1               
00999E  1               UC_loop
00999E  1  88                 DEY                     ; decrement index
00999F  1  B1 71              LDA   (ut1_pl),Y        ; get byte from string
0099A1  1  20 6D 93           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
0099A4  1  90 02              BCC   NoLcase           ; branch if not alpha
0099A6  1               
0099A6  1  29 DF              AND   #$DF              ; convert lower to upper case
0099A8  1               NoLcase
0099A8  1  91 83              STA   (Sutill),Y        ; save byte back to string
0099AA  1  98                 TYA                     ; test index
0099AB  1  D0 F1              BNE   UC_loop           ; loop if not all done
0099AD  1               
0099AD  1               NoString
0099AD  1  4C E1 96           JMP   LAB_RTST          ; check for space on descriptor stack then put string
0099B0  1                                             ; address and length on descriptor stack and update stack
0099B0  1                                             ; pointers
0099B0  1               
0099B0  1               ; perform SADD()
0099B0  1               
0099B0  1               LAB_SADD
0099B0  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0099B3  1  20 F9 92           JSR   LAB_GVAR          ; get var address
0099B6  1               
0099B6  1  20 3E 91           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
0099B9  1  20 21 90           JSR   LAB_CTST          ; check if source is string, else do type mismatch
0099BC  1               
0099BC  1  A0 02              LDY   #$02              ; index to string pointer high byte
0099BE  1  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
0099C0  1  AA                 TAX                     ; copy string pointer high byte to X
0099C1  1  88                 DEY                     ; index to string pointer low byte
0099C2  1  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
0099C4  1  A8                 TAY                     ; copy string pointer low byte to Y
0099C5  1  8A                 TXA                     ; copy string pointer high byte to A
0099C6  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0099C9  1               
0099C9  1               ; perform LEN()
0099C9  1               
0099C9  1               LAB_LENS
0099C9  1  20 CF 99           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
0099CC  1  4C C1 95           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
0099CF  1               
0099CF  1               ; evaluate string, get length in Y
0099CF  1               
0099CF  1               LAB_ESGL
0099CF  1  20 97 98           JSR   LAB_EVST          ; evaluate string
0099D2  1  A8                 TAY                     ; copy length to Y
0099D3  1  60                 RTS
0099D4  1               
0099D4  1               ; perform ASC()
0099D4  1               
0099D4  1               LAB_ASC
0099D4  1  20 CF 99           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
0099D7  1  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
0099D9  1               
0099D9  1  A0 00              LDY   #$00              ; set index to first character
0099DB  1  B1 71              LDA   (ut1_pl),Y        ; get byte
0099DD  1  A8                 TAY                     ; copy to Y
0099DE  1  4C C1 95           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
0099E1  1               
0099E1  1               ; do function call error then warm start
0099E1  1               
0099E1  1               LAB_23A8
0099E1  1  4C 78 94           JMP   LAB_FCER          ; do function call error then warm start
0099E4  1               
0099E4  1               ; scan and get byte parameter
0099E4  1               
0099E4  1               LAB_SGBY
0099E4  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0099E7  1               
0099E7  1               ; get byte parameter
0099E7  1               
0099E7  1               LAB_GTBY
0099E7  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0099EA  1                                             ; else do type mismatch
0099EA  1               
0099EA  1               ; evaluate byte expression, result in X
0099EA  1               
0099EA  1               LAB_EVBY
0099EA  1  20 F1 93           JSR   LAB_EVPI          ; evaluate integer expression (no check)
0099ED  1               
0099ED  1  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
0099EF  1  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
0099F1  1               
0099F1  1  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
0099F3  1  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
0099F6  1               
0099F6  1               ; perform VAL()
0099F6  1               
0099F6  1               LAB_VAL
0099F6  1  20 CF 99           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
0099F9  1  D0 03              BNE   LAB_23C5          ; branch if not null string
0099FB  1               
0099FB  1                                             ; string was null so set result = $00
0099FB  1  4C AB 9B           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
0099FE  1               
0099FE  1               LAB_23C5
0099FE  1  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
009A00  1  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
009A02  1  86 BA              STX   Btmpl             ; save BASIC execute pointer low byte
009A04  1  84 BB              STY   Btmph             ; save BASIC execute pointer high byte
009A06  1  A6 71              LDX   ut1_pl            ; get string pointer low byte
009A08  1  86 C3              STX   Bpntrl            ; save as BASIC execute pointer low byte
009A0A  1  18                 CLC                     ; clear carry
009A0B  1  65 71              ADC   ut1_pl            ; add string length
009A0D  1  85 73              STA   ut2_pl            ; save string end low byte
009A0F  1  A5 72              LDA   ut1_ph            ; get string pointer high byte
009A11  1  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
009A13  1  69 00              ADC   #$00              ; add carry to high byte
009A15  1  85 74              STA   ut2_ph            ; save string end high byte
009A17  1  A0 00              LDY   #$00              ; set index to $00
009A19  1  B1 73              LDA   (ut2_pl),Y        ; get string end +1 byte
009A1B  1  48                 PHA                     ; push it
009A1C  1  98                 TYA                     ; clear A
009A1D  1  91 73              STA   (ut2_pl),Y        ; terminate string with $00
009A1F  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
009A22  1  20 01 9F           JSR   LAB_2887          ; get FAC1 from string
009A25  1  68                 PLA                     ; restore string end +1 byte
009A26  1  A0 00              LDY   #$00              ; set index to zero
009A28  1  91 73              STA   (ut2_pl),Y        ; put string end byte back
009A2A  1               
009A2A  1               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
009A2A  1               
009A2A  1               LAB_23F3
009A2A  1  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
009A2C  1  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
009A2E  1  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
009A30  1  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
009A32  1  60                 RTS
009A33  1               
009A33  1               ; get two parameters for POKE or WAIT
009A33  1               
009A33  1               LAB_GADB
009A33  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009A36  1                                             ; else do type mismatch
009A36  1  20 4C 9A           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
009A39  1               
009A39  1               ; scan for "," and get byte, else do Syntax error then warm start
009A39  1               
009A39  1               LAB_SCGB
009A39  1  20 4D 91           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
009A3C  1  A5 12              LDA   Itemph            ; save temporary integer high byte
009A3E  1  48                 PHA                     ; on stack
009A3F  1  A5 11              LDA   Itempl            ; save temporary integer low byte
009A41  1  48                 PHA                     ; on stack
009A42  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter
009A45  1  68                 PLA                     ; pull low byte
009A46  1  85 11              STA   Itempl            ; restore temporary integer low byte
009A48  1  68                 PLA                     ; pull high byte
009A49  1  85 12              STA   Itemph            ; restore temporary integer high byte
009A4B  1  60                 RTS
009A4C  1               
009A4C  1               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
009A4C  1               ; -ve and converts it into a right truncated integer in Itempl and Itemph
009A4C  1               
009A4C  1               ; save unsigned 16 bit integer part of FAC1 in temporary integer
009A4C  1               
009A4C  1               LAB_F2FX
009A4C  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009A4E  1  C9 98              CMP   #$98              ; compare with exponent = 2^24
009A50  1  B0 8F              BCS   LAB_23A8          ; if >= do function call error then warm start
009A52  1               
009A52  1               LAB_F2FU
009A52  1  20 AB 9E           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
009A55  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009A57  1  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
009A59  1  84 11              STY   Itempl            ; save temporary integer low byte
009A5B  1  85 12              STA   Itemph            ; save temporary integer high byte
009A5D  1  60                 RTS
009A5E  1               
009A5E  1               ; perform PEEK()
009A5E  1               
009A5E  1               LAB_PEEK
009A5E  1  20 4C 9A           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
009A61  1  A2 00              LDX   #$00              ; clear index
009A63  1  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
009A65  1  A8                 TAY                     ; copy byte to Y
009A66  1  4C C1 95           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
009A69  1               
009A69  1               ; perform POKE
009A69  1               
009A69  1               LAB_POKE
009A69  1  20 33 9A           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
009A6C  1  8A                 TXA                     ; copy byte argument to A
009A6D  1  A2 00              LDX   #$00              ; clear index
009A6F  1  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
009A71  1  60                 RTS
009A72  1               
009A72  1               ; perform DEEK()
009A72  1               
009A72  1               LAB_DEEK
009A72  1  20 4C 9A           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
009A75  1  A2 00              LDX   #$00              ; clear index
009A77  1  A1 11              LDA   (Itempl,X)        ; PEEK low byte
009A79  1  A8                 TAY                     ; copy to Y
009A7A  1  E6 11              INC   Itempl            ; increment pointer low byte
009A7C  1  D0 02              BNE   Deekh             ; skip high increment if no rollover
009A7E  1               
009A7E  1  E6 12              INC   Itemph            ; increment pointer high byte
009A80  1               Deekh
009A80  1  A1 11              LDA   (Itempl,X)        ; PEEK high byte
009A82  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009A85  1               
009A85  1               ; perform DOKE
009A85  1               
009A85  1               LAB_DOKE
009A85  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009A88  1                                             ; else do type mismatch
009A88  1  20 4C 9A           JSR   LAB_F2FX          ; convert floating-to-fixed
009A8B  1               
009A8B  1  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
009A8D  1  85 98              STA   Frnxth            ; save pointer high byte
009A8F  1               
009A8F  1  20 4D 91           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
009A92  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009A95  1                                             ; else do type mismatch
009A95  1  20 4C 9A           JSR   LAB_F2FX          ; convert floating-to-fixed
009A98  1               
009A98  1  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
009A99  1  A2 00              LDX   #$00              ; clear index
009A9B  1  81 97              STA   (Frnxtl,X)        ; POKE low byte
009A9D  1  E6 97              INC   Frnxtl            ; increment pointer low byte
009A9F  1  D0 02              BNE   Dokeh             ; skip high increment if no rollover
009AA1  1               
009AA1  1  E6 98              INC   Frnxth            ; increment pointer high byte
009AA3  1               Dokeh
009AA3  1  A5 12              LDA   Itemph            ; get value high byte
009AA5  1  81 97              STA   (Frnxtl,X)        ; POKE high byte
009AA7  1  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
009AAA  1               
009AAA  1               ; perform SWAP
009AAA  1               
009AAA  1               LAB_SWAP
009AAA  1  20 F9 92           JSR   LAB_GVAR          ; get var1 address
009AAD  1  85 97              STA   Lvarpl            ; save var1 address low byte
009AAF  1  84 98              STY   Lvarph            ; save var1 address high byte
009AB1  1  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
009AB3  1  48                 PHA                     ; save data type flag
009AB4  1               
009AB4  1  20 4D 91           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
009AB7  1  20 F9 92           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
009ABA  1  68                 PLA                     ; pull var1 data type flag
009ABB  1  45 5F              EOR   Dtypef            ; compare with var2 data type
009ABD  1  10 10              BPL   SwapErr           ; exit if not both the same type
009ABF  1               
009ABF  1  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
009AC1  1               SwapLp
009AC1  1  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
009AC3  1  AA                 TAX                     ; save var1 byte
009AC4  1  B1 95              LDA   (Cvaral),Y        ; get byte from var2
009AC6  1  91 97              STA   (Lvarpl),Y        ; save byte to var1
009AC8  1  8A                 TXA                     ; restore var1 byte
009AC9  1  91 95              STA   (Cvaral),Y        ; save byte to var2
009ACB  1  88                 DEY                     ; decrement index
009ACC  1  10 F3              BPL   SwapLp            ; loop until done
009ACE  1               
009ACE  1  60                 RTS
009ACF  1               
009ACF  1               SwapErr
009ACF  1  4C 2B 90           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
009AD2  1               
009AD2  1               ; perform CALL
009AD2  1               
009AD2  1               LAB_CALL
009AD2  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009AD5  1                                             ; else do type mismatch
009AD5  1  20 4C 9A           JSR   LAB_F2FX          ; convert floating-to-fixed
009AD8  1  A9 9A              LDA   #>CallExit        ; set return address high byte
009ADA  1  48                 PHA                     ; put on stack
009ADB  1  A9 E0              LDA   #<CallExit-1      ; set return address low byte
009ADD  1  48                 PHA                     ; put on stack
009ADE  1  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
009AE1  1               
009AE1  1               ; if the called routine exits correctly then it will return to here. this will then get
009AE1  1               ; the next byte for the interpreter and return
009AE1  1               
009AE1  1               CallExit
009AE1  1  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
009AE4  1               
009AE4  1               ; perform WAIT
009AE4  1               
009AE4  1               LAB_WAIT
009AE4  1  20 33 9A           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
009AE7  1  86 97              STX   Frnxtl            ; save byte
009AE9  1  A2 00              LDX   #$00              ; clear mask
009AEB  1  20 C2 00           JSR   LAB_GBYT          ; scan memory
009AEE  1  F0 03              BEQ   LAB_2441          ; skip if no third argument
009AF0  1               
009AF0  1  20 39 9A           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
009AF3  1               LAB_2441
009AF3  1  86 98              STX   Frnxth            ; save EOR argument
009AF5  1               LAB_2445
009AF5  1  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
009AF7  1  45 98              EOR   Frnxth            ; EOR with second argument (mask)
009AF9  1  25 97              AND   Frnxtl            ; AND with first argument (byte)
009AFB  1  F0 F8              BEQ   LAB_2445          ; loop if result is zero
009AFD  1               
009AFD  1               LAB_244D
009AFD  1  60                 RTS
009AFE  1               
009AFE  1               ; perform subtraction, FAC1 from (AY)
009AFE  1               
009AFE  1               LAB_2455
009AFE  1  20 E6 9C           JSR   LAB_264D          ; unpack memory (AY) into FAC2
009B01  1               
009B01  1               ; perform subtraction, FAC1 from FAC2
009B01  1               
009B01  1               LAB_SUBTRACT
009B01  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009B03  1  49 FF              EOR   #$FF              ; complement it
009B05  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
009B07  1  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
009B09  1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009B0B  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009B0D  1  4C 1C 9B           JMP   LAB_ADD           ; go add FAC2 to FAC1
009B10  1               
009B10  1               ; perform addition
009B10  1               
009B10  1               LAB_2467
009B10  1  20 35 9C           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
009B13  1  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
009B15  1               
009B15  1               ; add 0.5 to FAC1
009B15  1               
009B15  1               LAB_244E
009B15  1  A9 3B              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
009B17  1  A0 B4              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
009B19  1               
009B19  1               ; add (AY) to FAC1
009B19  1               
009B19  1               LAB_246C
009B19  1  20 E6 9C           JSR   LAB_264D          ; unpack memory (AY) into FAC2
009B1C  1               
009B1C  1               ; add FAC2 to FAC1
009B1C  1               
009B1C  1               LAB_ADD
009B1C  1  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
009B1E  1               
009B1E  1               ; copy FAC2 to FAC1
009B1E  1               
009B1E  1               LAB_279B
009B1E  1  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
009B20  1               
009B20  1               ; save FAC1 sign and copy ABS(FAC2) to FAC1
009B20  1               
009B20  1               LAB_279D
009B20  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
009B22  1  A2 04              LDX   #$04              ; 4 bytes to copy
009B24  1               LAB_27A1
009B24  1  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
009B26  1  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
009B28  1  CA                 DEX                     ; decrement count
009B29  1  D0 F9              BNE   LAB_27A1          ; loop if not all done
009B2B  1               
009B2B  1  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
009B2D  1  60                 RTS
009B2E  1               
009B2E  1                                             ; FAC1 is non zero
009B2E  1               LAB_2474
009B2E  1  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
009B30  1  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
009B32  1  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
009B34  1  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
009B36  1               LAB_247C
009B36  1  A8                 TAY                     ; copy exponent
009B37  1  F0 C4              BEQ   LAB_244D          ; exit if zero
009B39  1               
009B39  1  38                 SEC                     ; set carry for subtract
009B3A  1  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
009B3C  1  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
009B3E  1               
009B3E  1  90 12              BCC   LAB_2498          ; branch if <
009B40  1               
009B40  1                                             ; FAC2>FAC1
009B40  1  84 AC              STY   FAC1_e            ; save FAC1 exponent
009B42  1  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
009B44  1  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
009B46  1  49 FF              EOR   #$FF              ; complement A
009B48  1  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
009B4A  1  A0 00              LDY   #$00              ; clear Y
009B4C  1  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
009B4E  1  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
009B50  1  D0 04              BNE   LAB_249C          ; branch always
009B52  1               
009B52  1               LAB_2498
009B52  1  A0 00              LDY   #$00              ; clear Y
009B54  1  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
009B56  1               LAB_249C
009B56  1  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
009B58  1  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
009B5A  1               
009B5A  1  A8                 TAY                     ; copy exponent difference to Y
009B5B  1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
009B5D  1  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
009B5F  1  20 4C 9C           JSR   LAB_2592          ; shift FACX Y times right
009B62  1               
009B62  1                                             ; exponents are equal now do mantissa subtract
009B62  1               LAB_24A8
009B62  1  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
009B64  1  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
009B66  1               
009B66  1  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
009B68  1  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
009B6A  1  F0 02              BEQ   LAB_24B4          ; branch if =
009B6C  1               
009B6C  1  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
009B6E  1               
009B6E  1                                             ; subtract smaller from bigger (take sign of bigger)
009B6E  1               LAB_24B4
009B6E  1  38                 SEC                     ; set carry for subtract
009B6F  1  49 FF              EOR   #$FF              ; ones complement A
009B71  1  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
009B73  1  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
009B75  1  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
009B78  1  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
009B7A  1  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
009B7C  1  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
009B7F  1  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
009B81  1  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
009B83  1  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
009B86  1  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
009B88  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009B8A  1               
009B8A  1               ; do ABS and normalise FAC1
009B8A  1               
009B8A  1               LAB_24D0
009B8A  1  B0 03              BCS   LAB_24D5          ; branch if number is +ve
009B8C  1               
009B8C  1  20 F1 9B           JSR   LAB_2537          ; negate FAC1
009B8F  1               
009B8F  1               ; normalise FAC1
009B8F  1               
009B8F  1               LAB_24D5
009B8F  1  A0 00              LDY   #$00              ; clear Y
009B91  1  98                 TYA                     ; clear A
009B92  1  18                 CLC                     ; clear carry for add
009B93  1               LAB_24D9
009B93  1  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
009B95  1  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
009B97  1               
009B97  1  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
009B99  1  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
009B9B  1  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
009B9D  1  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
009B9F  1  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
009BA1  1  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
009BA3  1  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
009BA5  1  69 08              ADC   #$08              ; add x to exponent offset
009BA7  1  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
009BA9  1  D0 E8              BNE   LAB_24D9          ; loop if not max
009BAB  1               
009BAB  1               ; clear FAC1 exponent and sign
009BAB  1               
009BAB  1               LAB_24F1
009BAB  1  A9 00              LDA   #$00              ; clear A
009BAD  1               LAB_24F3
009BAD  1  85 AC              STA   FAC1_e            ; set FAC1 exponent
009BAF  1               
009BAF  1               ; save FAC1 sign
009BAF  1               
009BAF  1               LAB_24F5
009BAF  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
009BB1  1  60                 RTS
009BB2  1               
009BB2  1               ; add FAC2 mantissa to FAC1 mantissa
009BB2  1               
009BB2  1               LAB_24F8
009BB2  1  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
009BB4  1  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
009BB6  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
009BB8  1  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
009BBA  1  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
009BBC  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009BBE  1  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
009BC0  1  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
009BC2  1  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
009BC4  1  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
009BC6  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009BC8  1  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
009BCA  1               
009BCA  1  60                 RTS                     ; else just exit
009BCB  1               
009BCB  1               LAB_2511
009BCB  1  69 01              ADC   #$01              ; add 1 to exponent offset
009BCD  1  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
009BCF  1  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
009BD1  1  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
009BD3  1  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
009BD5  1               
009BD5  1               ; normalise FAC1
009BD5  1               
009BD5  1               LAB_251B
009BD5  1  10 F4              BPL   LAB_2511          ; loop if not normalised
009BD7  1               
009BD7  1  38                 SEC                     ; set carry for subtract
009BD8  1  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
009BDA  1  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
009BDC  1               
009BDC  1  49 FF              EOR   #$FF              ; complement exponent
009BDE  1  69 01              ADC   #$01              ; +1 (twos complement)
009BE0  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
009BE2  1               
009BE2  1               ; test and normalise FAC1 for C=0/1
009BE2  1               
009BE2  1               LAB_2528
009BE2  1  90 0C              BCC   LAB_2536          ; exit if no overflow
009BE4  1               
009BE4  1               ; normalise FAC1 for C=1
009BE4  1               
009BE4  1               LAB_252A
009BE4  1  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
009BE6  1  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
009BE8  1               
009BE8  1  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
009BEA  1  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
009BEC  1  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
009BEE  1  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
009BF0  1               LAB_2536
009BF0  1  60                 RTS
009BF1  1               
009BF1  1               ; negate FAC1
009BF1  1               
009BF1  1               LAB_2537
009BF1  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009BF3  1  49 FF              EOR   #$FF              ; complement it
009BF5  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
009BF7  1               
009BF7  1               ; twos complement FAC1 mantissa
009BF7  1               
009BF7  1               LAB_253D
009BF7  1  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
009BF9  1  49 FF              EOR   #$FF              ; complement it
009BFB  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009BFD  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009BFF  1  49 FF              EOR   #$FF              ; complement it
009C01  1  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
009C03  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
009C05  1  49 FF              EOR   #$FF              ; complement it
009C07  1  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
009C09  1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
009C0B  1  49 FF              EOR   #$FF              ; complement it
009C0D  1  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
009C0F  1  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
009C11  1  D0 0A              BNE   LAB_2563          ; exit if no overflow
009C13  1               
009C13  1               ; increment FAC1 mantissa
009C13  1               
009C13  1               LAB_2559
009C13  1  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
009C15  1  D0 06              BNE   LAB_2563          ; finished if no rollover
009C17  1               
009C17  1  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
009C19  1  D0 02              BNE   LAB_2563          ; finished if no rollover
009C1B  1               
009C1B  1  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
009C1D  1               LAB_2563
009C1D  1  60                 RTS
009C1E  1               
009C1E  1               ; do overflow error (overflow exit)
009C1E  1               
009C1E  1               LAB_2564
009C1E  1  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
009C20  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
009C23  1               
009C23  1               ; shift FCAtemp << A+8 times
009C23  1               
009C23  1               LAB_2569
009C23  1  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
009C25  1               LAB_256B
009C25  1  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
009C27  1  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
009C29  1  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
009C2B  1  94 03              STY   PLUS_3,X          ; save FACX mantissa3
009C2D  1  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
009C2F  1  94 02              STY   PLUS_2,X          ; save FACX mantissa2
009C31  1  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
009C33  1  94 01              STY   PLUS_1,X          ; save FACX mantissa1
009C35  1               
009C35  1               ; shift FACX -A times right (> 8 shifts)
009C35  1               
009C35  1               LAB_257B
009C35  1  69 08              ADC   #$08              ; add 8 to shift count
009C37  1  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
009C39  1               
009C39  1  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
009C3B  1               
009C3B  1  E9 08              SBC   #$08              ; else subtract 8 again
009C3D  1  A8                 TAY                     ; save count to Y
009C3E  1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
009C40  1  B0 12              BCS   LAB_259A          ;.
009C42  1               
009C42  1               LAB_2588
009C42  1  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
009C44  1  90 02              BCC   LAB_258E          ; branch if +ve
009C46  1               
009C46  1  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
009C48  1               LAB_258E
009C48  1  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
009C4A  1  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
009C4C  1               
009C4C  1               ; shift FACX Y times right
009C4C  1               
009C4C  1               LAB_2592
009C4C  1  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
009C4E  1  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
009C50  1  6A                 ROR                     ; shift FACX rounding byte
009C51  1  C8                 INY                     ; increment exponent diff
009C52  1  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
009C54  1               
009C54  1               LAB_259A
009C54  1  18                 CLC                     ; just clear it
009C55  1  60                 RTS
009C56  1               
009C56  1               ; perform LOG()
009C56  1               
009C56  1               LAB_LOG
009C56  1  20 44 9E           JSR   LAB_27CA          ; test sign and zero
009C59  1  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
009C5B  1               
009C5B  1  10 03              BPL   LAB_25C7          ; skip error if +ve
009C5D  1               
009C5D  1               LAB_25C4
009C5D  1  4C 78 94           JMP   LAB_FCER          ; do function call error then warm start (-ve)
009C60  1               
009C60  1               LAB_25C7
009C60  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009C62  1  E9 7F              SBC   #$7F              ; normalise it
009C64  1  48                 PHA                     ; save it
009C65  1  A9 80              LDA   #$80              ; set exponent to zero
009C67  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
009C69  1  A9 BB              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
009C6B  1  A0 B3              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
009C6D  1  20 19 9B           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
009C70  1  A9 BF              LDA   #<LAB_25B1        ; set root2 pointer low byte
009C72  1  A0 B3              LDY   #>LAB_25B1        ; set root2 pointer high byte
009C74  1  20 5C 9D           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
009C77  1  A9 32              LDA   #<LAB_259C        ; set 1 pointer low byte
009C79  1  A0 B4              LDY   #>LAB_259C        ; set 1 pointer high byte
009C7B  1  20 FE 9A           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
009C7E  1  A9 AE              LDA   #<LAB_25A0        ; set pointer low byte to counter
009C80  1  A0 B3              LDY   #>LAB_25A0        ; set pointer high byte to counter
009C82  1  20 AC A1           JSR   LAB_2B6E          ; ^2 then series evaluation
009C85  1  A9 C3              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
009C87  1  A0 B3              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
009C89  1  20 19 9B           JSR   LAB_246C          ; add (AY) to FAC1
009C8C  1  68                 PLA                     ; restore FAC1 exponent
009C8D  1  20 A0 9F           JSR   LAB_2912          ; evaluate new ASCII digit
009C90  1  A9 C7              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
009C92  1  A0 B3              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
009C94  1               
009C94  1               ; do convert AY, FCA1*(AY)
009C94  1               
009C94  1               LAB_25FB
009C94  1  20 E6 9C           JSR   LAB_264D          ; unpack memory (AY) into FAC2
009C97  1               LAB_MULTIPLY
009C97  1  F0 4C              BEQ   LAB_264C          ; exit if zero
009C99  1               
009C99  1  20 0C 9D           JSR   LAB_2673          ; test and adjust accumulators
009C9C  1  A9 00              LDA   #$00              ; clear A
009C9E  1  85 75              STA   FACt_1            ; clear temp mantissa1
009CA0  1  85 76              STA   FACt_2            ; clear temp mantissa2
009CA2  1  85 77              STA   FACt_3            ; clear temp mantissa3
009CA4  1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
009CA6  1  20 BB 9C           JSR   LAB_2622          ; go do shift/add FAC2
009CA9  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
009CAB  1  20 BB 9C           JSR   LAB_2622          ; go do shift/add FAC2
009CAE  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009CB0  1  20 BB 9C           JSR   LAB_2622          ; go do shift/add FAC2
009CB3  1  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
009CB5  1  20 C0 9C           JSR   LAB_2627          ; go do shift/add FAC2
009CB8  1  4C C9 9D           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
009CBB  1               
009CBB  1               LAB_2622
009CBB  1  D0 03              BNE   LAB_2627          ; branch if byte <> zero
009CBD  1               
009CBD  1  4C 23 9C           JMP   LAB_2569          ; shift FCAtemp << A+8 times
009CC0  1               
009CC0  1                                             ; else do shift and add
009CC0  1               LAB_2627
009CC0  1  4A                 LSR                     ; shift byte
009CC1  1  09 80              ORA   #$80              ; set top bit (mark for 8 times)
009CC3  1               LAB_262A
009CC3  1  A8                 TAY                     ; copy result
009CC4  1  90 13              BCC   LAB_2640          ; skip next if bit was zero
009CC6  1               
009CC6  1  18                 CLC                     ; clear carry for add
009CC7  1  A5 77              LDA   FACt_3            ; get temp mantissa3
009CC9  1  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
009CCB  1  85 77              STA   FACt_3            ; save temp mantissa3
009CCD  1  A5 76              LDA   FACt_2            ; get temp mantissa2
009CCF  1  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
009CD1  1  85 76              STA   FACt_2            ; save temp mantissa2
009CD3  1  A5 75              LDA   FACt_1            ; get temp mantissa1
009CD5  1  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
009CD7  1  85 75              STA   FACt_1            ; save temp mantissa1
009CD9  1               LAB_2640
009CD9  1  66 75              ROR   FACt_1            ; shift temp mantissa1
009CDB  1  66 76              ROR   FACt_2            ; shift temp mantissa2
009CDD  1  66 77              ROR   FACt_3            ; shift temp mantissa3
009CDF  1  66 B9              ROR   FAC1_r            ; shift temp rounding byte
009CE1  1  98                 TYA                     ; get byte back
009CE2  1  4A                 LSR                     ; shift byte
009CE3  1  D0 DE              BNE   LAB_262A          ; loop if all bits not done
009CE5  1               
009CE5  1               LAB_264C
009CE5  1  60                 RTS
009CE6  1               
009CE6  1               ; unpack memory (AY) into FAC2
009CE6  1               
009CE6  1               LAB_264D
009CE6  1  85 71              STA   ut1_pl            ; save pointer low byte
009CE8  1  84 72              STY   ut1_ph            ; save pointer high byte
009CEA  1  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
009CEC  1  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
009CEE  1  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
009CF0  1  88                 DEY                     ; decrement index
009CF1  1  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
009CF3  1  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
009CF5  1  88                 DEY                     ; decrement index
009CF6  1  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
009CF8  1  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
009CFA  1  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
009CFC  1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009CFE  1  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
009D00  1  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
009D02  1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
009D04  1  88                 DEY                     ; decrement index
009D05  1  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
009D07  1  85 B3              STA   FAC2_e            ; save FAC2 exponent
009D09  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009D0B  1  60                 RTS
009D0C  1               
009D0C  1               ; test and adjust accumulators
009D0C  1               
009D0C  1               LAB_2673
009D0C  1  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
009D0E  1               LAB_2675
009D0E  1  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
009D10  1               
009D10  1  18                 CLC                     ; clear carry for add
009D11  1  65 AC              ADC   FAC1_e            ; add FAC1 exponent
009D13  1  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
009D15  1               
009D15  1  30 31              BMI   LAB_269B          ; do overflow error
009D17  1               
009D17  1  18                 CLC                     ; clear carry for the add
009D18  1  2C                 .byte $2C               ; makes next line BIT $1410
009D19  1               LAB_2680
009D19  1  10 12              BPL   LAB_2696          ; if +ve go handle underflow
009D1B  1               
009D1B  1  69 80              ADC   #$80              ; adjust exponent
009D1D  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
009D1F  1  D0 03              BNE   LAB_268B          ; branch if not zero
009D21  1               
009D21  1  4C AF 9B           JMP   LAB_24F5          ; save FAC1 sign and return
009D24  1               
009D24  1               LAB_268B
009D24  1  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
009D26  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
009D28  1               LAB_268F
009D28  1  60                 RTS
009D29  1               
009D29  1               ; handle overflow and underflow
009D29  1               
009D29  1               LAB_2690
009D29  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009D2B  1  10 1B              BPL   LAB_269B          ; do overflow error
009D2D  1               
009D2D  1                                             ; handle underflow
009D2D  1               LAB_2696
009D2D  1  68                 PLA                     ; pop return address low byte
009D2E  1  68                 PLA                     ; pop return address high byte
009D2F  1  4C AB 9B           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
009D32  1               
009D32  1               ; multiply by 10
009D32  1               
009D32  1               LAB_269E
009D32  1  20 25 9E           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009D35  1  AA                 TAX                     ; copy exponent (set the flags)
009D36  1  F0 F0              BEQ   LAB_268F          ; exit if zero
009D38  1               
009D38  1  18                 CLC                     ; clear carry for add
009D39  1  69 02              ADC   #$02              ; add two to exponent (*4)
009D3B  1  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
009D3D  1               
009D3D  1  A2 00              LDX   #$00              ; clear byte
009D3F  1  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
009D41  1  20 36 9B           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
009D44  1  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
009D46  1  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
009D48  1               
009D48  1               LAB_269B
009D48  1  4C 1E 9C           JMP   LAB_2564          ; do overflow error and warm start
009D4B  1               
009D4B  1               ; divide by 10
009D4B  1               
009D4B  1               LAB_26B9
009D4B  1  20 25 9E           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009D4E  1  A9 43              LDA   #<LAB_26B5        ; set pointer to 10d low addr
009D50  1  A0 B4              LDY   #>LAB_26B5        ; set pointer to 10d high addr
009D52  1  A2 00              LDX   #$00              ; clear sign
009D54  1               
009D54  1               ; divide by (AY) (X=sign)
009D54  1               
009D54  1               LAB_26C2
009D54  1  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009D56  1  20 D8 9D           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
009D59  1  4C 5F 9D           JMP   LAB_DIVIDE        ; do FAC2/FAC1
009D5C  1               
009D5C  1                                             ; Perform divide-by
009D5C  1               ; convert AY and do (AY)/FAC1
009D5C  1               
009D5C  1               LAB_26CA
009D5C  1  20 E6 9C           JSR   LAB_264D          ; unpack memory (AY) into FAC2
009D5F  1               
009D5F  1                                             ; Perform divide-into
009D5F  1               LAB_DIVIDE
009D5F  1  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
009D61  1               
009D61  1  20 34 9E           JSR   LAB_27BA          ; round FAC1
009D64  1  A9 00              LDA   #$00              ; clear A
009D66  1  38                 SEC                     ; set carry for subtract
009D67  1  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
009D69  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
009D6B  1  20 0C 9D           JSR   LAB_2673          ; test and adjust accumulators
009D6E  1  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
009D70  1  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
009D72  1               
009D72  1  A2 FF              LDX   #$FF              ; set index for pre increment
009D74  1  A9 01              LDA   #$01              ; set bit to flag byte save
009D76  1               LAB_26E4
009D76  1  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
009D78  1  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
009D7A  1  D0 0A              BNE   LAB_26F4          ; branch if <>
009D7C  1               
009D7C  1  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
009D7E  1  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
009D80  1  D0 04              BNE   LAB_26F4          ; branch if <>
009D82  1               
009D82  1  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
009D84  1  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
009D86  1               LAB_26F4
009D86  1  08                 PHP                     ; save FAC2-FAC1 compare status
009D87  1  2A                 ROL                     ; shift the result byte
009D88  1  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
009D8A  1               
009D8A  1  A0 01              LDY   #$01              ; set bit to flag byte save
009D8C  1  E8                 INX                     ; else increment the index to FACt
009D8D  1  E0 02              CPX   #$02              ; compare with the index to FACt_3
009D8F  1  30 04              BMI   LAB_2701          ; if not last byte just go save it
009D91  1               
009D91  1  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
009D93  1                                             ; return
009D93  1               
009D93  1  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
009D95  1               LAB_2701
009D95  1  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
009D97  1  98                 TYA                     ; copy the next save byte flag
009D98  1               LAB_2702
009D98  1  28                 PLP                     ; restore FAC2-FAC1 compare status
009D99  1  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
009D9B  1               
009D9B  1  A8                 TAY                     ; save FAC2-FAC1 compare status
009D9C  1  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
009D9E  1  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
009DA0  1  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
009DA2  1  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
009DA4  1  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
009DA6  1  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
009DA8  1  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
009DAA  1  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
009DAC  1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
009DAE  1  98                 TYA                     ; restore FAC2-FAC1 compare status
009DAF  1               
009DAF  1                                             ; FAC2 = FAC2*2
009DAF  1               LAB_2704
009DAF  1  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
009DB1  1  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
009DB3  1  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
009DB5  1  B0 CF              BCS   LAB_26F4          ; loop with no compare
009DB7  1               
009DB7  1  30 BD              BMI   LAB_26E4          ; loop with compare
009DB9  1               
009DB9  1  10 CB              BPL   LAB_26F4          ; loop always with no compare
009DBB  1               
009DBB  1               ; do A<<6, save as FAC1 rounding byte, normalise and return
009DBB  1               
009DBB  1               LAB_272B
009DBB  1  4A                 LSR                     ; shift b1 - b0 ..
009DBC  1  6A                 ROR                     ; ..
009DBD  1  6A                 ROR                     ; .. to b7 - b6
009DBE  1  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
009DC0  1  28                 PLP                     ; dump FAC2-FAC1 compare status
009DC1  1  4C C9 9D           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
009DC4  1               
009DC4  1               ; do "Divide by zero" error
009DC4  1               
009DC4  1               LAB_2737
009DC4  1  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
009DC6  1  4C 38 85           JMP   LAB_XERR          ; do error #X, then warm start
009DC9  1               
009DC9  1               ; copy temp to FAC1 and normalise
009DC9  1               
009DC9  1               LAB_273C
009DC9  1  A5 75              LDA   FACt_1            ; get temp mantissa1
009DCB  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009DCD  1  A5 76              LDA   FACt_2            ; get temp mantissa2
009DCF  1  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
009DD1  1  A5 77              LDA   FACt_3            ; get temp mantissa3
009DD3  1  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
009DD5  1  4C 8F 9B           JMP   LAB_24D5          ; normalise FAC1 and return
009DD8  1               
009DD8  1               ; unpack memory (AY) into FAC1
009DD8  1               
009DD8  1               LAB_UFAC
009DD8  1  85 71              STA   ut1_pl            ; save pointer low byte
009DDA  1  84 72              STY   ut1_ph            ; save pointer high byte
009DDC  1  A0 03              LDY   #$03              ; 4 bytes to do
009DDE  1  B1 71              LDA   (ut1_pl),Y        ; get last byte
009DE0  1  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
009DE2  1  88                 DEY                     ; decrement index
009DE3  1  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
009DE5  1  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
009DE7  1  88                 DEY                     ; decrement index
009DE8  1  B1 71              LDA   (ut1_pl),Y        ; get second byte
009DEA  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
009DEC  1  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
009DEE  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009DF0  1  88                 DEY                     ; decrement index
009DF1  1  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
009DF3  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
009DF5  1  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
009DF7  1  60                 RTS
009DF8  1               
009DF8  1               ; pack FAC1 into Adatal
009DF8  1               
009DF8  1               LAB_276E
009DF8  1  A2 A4              LDX   #<Adatal          ; set pointer low byte
009DFA  1               LAB_2770
009DFA  1  A0 00              LDY   #>Adatal          ; set pointer high byte
009DFC  1  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
009DFE  1               
009DFE  1               ; pack FAC1 into (Lvarpl)
009DFE  1               
009DFE  1               LAB_PFAC
009DFE  1  A6 97              LDX   Lvarpl            ; get destination pointer low byte
009E00  1  A4 98              LDY   Lvarph            ; get destination pointer high byte
009E02  1               
009E02  1               ; pack FAC1 into (XY)
009E02  1               
009E02  1               LAB_2778
009E02  1  20 34 9E           JSR   LAB_27BA          ; round FAC1
009E05  1  86 71              STX   ut1_pl            ; save pointer low byte
009E07  1  84 72              STY   ut1_ph            ; save pointer high byte
009E09  1  A0 03              LDY   #$03              ; set index
009E0B  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
009E0D  1  91 71              STA   (ut1_pl),Y        ; store in destination
009E0F  1  88                 DEY                     ; decrement index
009E10  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
009E12  1  91 71              STA   (ut1_pl),Y        ; store in destination
009E14  1  88                 DEY                     ; decrement index
009E15  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009E17  1  09 7F              ORA   #$7F              ; set bits x111 1111
009E19  1  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
009E1B  1  91 71              STA   (ut1_pl),Y        ; store in destination
009E1D  1  88                 DEY                     ; decrement index
009E1E  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009E20  1  91 71              STA   (ut1_pl),Y        ; store in destination
009E22  1  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
009E24  1  60                 RTS
009E25  1               
009E25  1               ; round and copy FAC1 to FAC2
009E25  1               
009E25  1               LAB_27AB
009E25  1  20 34 9E           JSR   LAB_27BA          ; round FAC1
009E28  1               
009E28  1               ; copy FAC1 to FAC2
009E28  1               
009E28  1               LAB_27AE
009E28  1  A2 05              LDX   #$05              ; 5 bytes to copy
009E2A  1               LAB_27B0
009E2A  1  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
009E2C  1  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
009E2E  1  CA                 DEX                     ; decrement count
009E2F  1  D0 F9              BNE   LAB_27B0          ; loop if not all done
009E31  1               
009E31  1  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
009E33  1               LAB_27B9
009E33  1  60                 RTS
009E34  1               
009E34  1               ; round FAC1
009E34  1               
009E34  1               LAB_27BA
009E34  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009E36  1  F0 FB              BEQ   LAB_27B9          ; exit if zero
009E38  1               
009E38  1  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
009E3A  1  90 F7              BCC   LAB_27B9          ; exit if no overflow
009E3C  1               
009E3C  1               ; round FAC1 (no check)
009E3C  1               
009E3C  1               LAB_27C2
009E3C  1  20 13 9C           JSR   LAB_2559          ; increment FAC1 mantissa
009E3F  1  D0 F2              BNE   LAB_27B9          ; branch if no overflow
009E41  1               
009E41  1  4C E4 9B           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
009E44  1               
009E44  1               ; get FAC1 sign
009E44  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
009E44  1               
009E44  1               LAB_27CA
009E44  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009E46  1  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
009E48  1               
009E48  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
009E48  1               ; no = 0 check
009E48  1               
009E48  1               LAB_27CE
009E48  1  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
009E4A  1               
009E4A  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
009E4A  1               ; no = 0 check, sign in A
009E4A  1               
009E4A  1               LAB_27D0
009E4A  1  2A                 ROL                     ; move sign bit to carry
009E4B  1  A9 FF              LDA   #$FF              ; set byte for -ve result
009E4D  1  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
009E4F  1               
009E4F  1  A9 01              LDA   #$01              ; else set byte for +ve result
009E51  1               LAB_27D7
009E51  1  60                 RTS
009E52  1               
009E52  1               ; perform SGN()
009E52  1               
009E52  1               LAB_SGN
009E52  1  20 44 9E           JSR   LAB_27CA          ; get FAC1 sign
009E55  1                                             ; return A=$FF/-ve A=$01/+ve
009E55  1               ; save A as integer byte
009E55  1               
009E55  1               LAB_27DB
009E55  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009E57  1  A9 00              LDA   #$00              ; clear A
009E59  1  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
009E5B  1  A2 88              LDX   #$88              ; set exponent
009E5D  1               
009E5D  1               ; set exp=X, clearFAC1 mantissa3 and normalise
009E5D  1               
009E5D  1               LAB_27E3
009E5D  1  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
009E5F  1  49 FF              EOR   #$FF              ; complement it
009E61  1  2A                 ROL                     ; sign bit into carry
009E62  1               
009E62  1               ; set exp=X, clearFAC1 mantissa3 and normalise
009E62  1               
009E62  1               LAB_STFA
009E62  1  A9 00              LDA   #$00              ; clear A
009E64  1  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
009E66  1  86 AC              STX   FAC1_e            ; set FAC1 exponent
009E68  1  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
009E6A  1  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
009E6C  1  4C 8A 9B           JMP   LAB_24D0          ; do ABS and normalise FAC1
009E6F  1               
009E6F  1               ; perform ABS()
009E6F  1               
009E6F  1               LAB_ABS
009E6F  1  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
009E71  1  60                 RTS
009E72  1               
009E72  1               ; compare FAC1 with (AY)
009E72  1               ; returns A=$00 if FAC1 = (AY)
009E72  1               ; returns A=$01 if FAC1 > (AY)
009E72  1               ; returns A=$FF if FAC1 < (AY)
009E72  1               
009E72  1               LAB_27F8
009E72  1  85 73              STA   ut2_pl            ; save pointer low byte
009E74  1               LAB_27FA
009E74  1  84 74              STY   ut2_ph            ; save pointer high byte
009E76  1  A0 00              LDY   #$00              ; clear index
009E78  1  B1 73              LDA   (ut2_pl),Y        ; get exponent
009E7A  1  C8                 INY                     ; increment index
009E7B  1  AA                 TAX                     ; copy (AY) exponent to X
009E7C  1  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
009E7E  1                                             ; A=FF,C=1/-ve A=01,C=0/+ve
009E7E  1               
009E7E  1  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
009E80  1  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
009E82  1  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
009E84  1                                             ; A=01,C=0/+ve and return
009E84  1               
009E84  1  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
009E86  1  D0 1A              BNE   LAB_2828          ; branch if different
009E88  1               
009E88  1  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
009E8A  1  09 80              ORA   #$80              ; normalise top bit
009E8C  1  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
009E8E  1  D0 12              BNE   LAB_2828          ; branch if different
009E90  1               
009E90  1  C8                 INY                     ; increment index
009E91  1  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
009E93  1  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
009E95  1  D0 0B              BNE   LAB_2828          ; branch if different
009E97  1               
009E97  1  C8                 INY                     ; increment index
009E98  1  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
009E9A  1  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
009E9C  1  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
009E9E  1  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
009EA0  1  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
009EA2  1               
009EA2  1               ; gets here if number <> FAC1
009EA2  1               
009EA2  1               LAB_2828
009EA2  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009EA4  1  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
009EA6  1               
009EA6  1  49 FF              EOR   #$FF              ; else toggle FAC1 sign
009EA8  1               LAB_282E
009EA8  1  4C 4A 9E           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
009EAB  1               
009EAB  1               ; convert FAC1 floating-to-fixed
009EAB  1               
009EAB  1               LAB_2831
009EAB  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009EAD  1  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
009EAF  1               
009EAF  1  38                 SEC                     ; set carry for subtract
009EB0  1  E9 98              SBC   #$98              ; subtract maximum integer range exponent
009EB2  1  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
009EB4  1  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
009EB6  1               
009EB6  1                                             ; FAC1 was -ve
009EB6  1  AA                 TAX                     ; copy subtracted exponent
009EB7  1  A9 FF              LDA   #$FF              ; overflow for -ve number
009EB9  1  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
009EBB  1  20 F7 9B           JSR   LAB_253D          ; twos complement FAC1 mantissa
009EBE  1  8A                 TXA                     ; restore subtracted exponent
009EBF  1               LAB_2845
009EBF  1  A2 AC              LDX   #FAC1_e           ; set index to FAC1
009EC1  1  C9 F9              CMP   #$F9              ; compare exponent result
009EC3  1  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
009EC5  1               
009EC5  1  20 35 9C           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
009EC8  1  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
009ECA  1               LAB_2850
009ECA  1  60                 RTS
009ECB  1               
009ECB  1               ; shift FAC1 A times right
009ECB  1               
009ECB  1               LAB_2851
009ECB  1  A8                 TAY                     ; copy shift count
009ECC  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009ECE  1  29 80              AND   #$80              ; mask sign bit only (x000 0000)
009ED0  1  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
009ED2  1  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
009ED4  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
009ED6  1  20 4C 9C           JSR   LAB_2592          ; shift FAC1 Y times right
009ED9  1  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
009EDB  1  60                 RTS
009EDC  1               
009EDC  1               ; perform INT()
009EDC  1               
009EDC  1               LAB_INT
009EDC  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
009EDE  1  C9 98              CMP   #$98              ; compare with max int
009EE0  1  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
009EE2  1               
009EE2  1  20 AB 9E           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
009EE5  1  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
009EE7  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
009EE9  1  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
009EEB  1  49 80              EOR   #$80              ; toggle FAC1 sign
009EED  1  2A                 ROL                     ; shift into carry
009EEE  1  A9 98              LDA   #$98              ; set new exponent
009EF0  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
009EF2  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
009EF4  1  85 5B              STA   Temp3             ; save for EXP() function
009EF6  1  4C 8A 9B           JMP   LAB_24D0          ; do ABS and normalise FAC1
009EF9  1               
009EF9  1               ; clear FAC1 and return
009EF9  1               
009EF9  1               LAB_287F
009EF9  1  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
009EFB  1  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
009EFD  1  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
009EFF  1  A8                 TAY                     ; clear Y
009F00  1               LAB_2886
009F00  1  60                 RTS
009F01  1               
009F01  1               ; get FAC1 from string
009F01  1               ; this routine now handles hex and binary values from strings
009F01  1               ; starting with "$" and "%" respectively
009F01  1               
009F01  1               LAB_2887
009F01  1  A0 00              LDY   #$00              ; clear Y
009F03  1  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
009F05  1  A2 09              LDX   #$09              ; set index
009F07  1               LAB_288B
009F07  1  94 A8              STY   numexp,X          ; clear byte
009F09  1  CA                 DEX                     ; decrement index
009F0A  1  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
009F0C  1               
009F0C  1  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
009F0E  1               
009F0E  1               ; get FAC1 from string .. first character wasn't numeric
009F0E  1               
009F0E  1  C9 2D              CMP   #'-'              ; else compare with "-"
009F10  1  D0 04              BNE   LAB_289A          ; branch if not "-"
009F12  1               
009F12  1  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
009F14  1  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
009F16  1               
009F16  1               ; get FAC1 from string .. first character wasn't numeric or -
009F16  1               
009F16  1               LAB_289A
009F16  1  C9 2B              CMP   #'+'              ; else compare with "+"
009F18  1  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
009F1A  1               
009F1A  1               ; was "+" or "-" to start, so get next character
009F1A  1               
009F1A  1               LAB_289C
009F1A  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
009F1D  1  90 6E              BCC   LAB_28FE          ; branch if numeric character
009F1F  1               
009F1F  1               ; code here for hex and binary numbers
009F1F  1               
009F1F  1               LAB_289D
009F1F  1  C9 24              CMP   #'$'              ; else compare with "$"
009F21  1  D0 03              BNE   LAB_NHEX          ; branch if not "$"
009F23  1               
009F23  1  4C CB A3           JMP   LAB_CHEX          ; branch if "$"
009F26  1               
009F26  1               LAB_NHEX
009F26  1  C9 25              CMP   #'%'              ; else compare with "%"
009F28  1  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
009F2A  1               
009F2A  1  4C F9 A3           JMP   LAB_CBIN          ; branch if "%"
009F2D  1               
009F2D  1               LAB_289E
009F2D  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
009F30  1               LAB_28A1
009F30  1  90 5B              BCC   LAB_28FE          ; branch if numeric character
009F32  1               
009F32  1               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
009F32  1               
009F32  1               LAB_28A3
009F32  1  C9 2E              CMP   #'.'              ; else compare with "."
009F34  1  F0 2E              BEQ   LAB_28D5          ; branch if "."
009F36  1               
009F36  1               ; get FAC1 from string .. character wasn't numeric, -, + or .
009F36  1               
009F36  1  C9 45              CMP   #'E'              ; else compare with "E"
009F38  1  D0 30              BNE   LAB_28DB          ; branch if not "E"
009F3A  1               
009F3A  1                                             ; was "E" so evaluate exponential part
009F3A  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
009F3D  1  90 17              BCC   LAB_28C7          ; branch if numeric character
009F3F  1               
009F3F  1  C9 C3              CMP   #TK_MINUS         ; else compare with token for -
009F41  1  F0 0E              BEQ   LAB_28C2          ; branch if token for -
009F43  1               
009F43  1  C9 2D              CMP   #'-'              ; else compare with "-"
009F45  1  F0 0A              BEQ   LAB_28C2          ; branch if "-"
009F47  1               
009F47  1  C9 C2              CMP   #TK_PLUS          ; else compare with token for +
009F49  1  F0 08              BEQ   LAB_28C4          ; branch if token for +
009F4B  1               
009F4B  1  C9 2B              CMP   #'+'              ; else compare with "+"
009F4D  1  F0 04              BEQ   LAB_28C4          ; branch if "+"
009F4F  1               
009F4F  1  D0 07              BNE   LAB_28C9          ; branch always
009F51  1               
009F51  1               LAB_28C2
009F51  1  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
009F53  1               LAB_28C4
009F53  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
009F56  1               LAB_28C7
009F56  1  90 5B              BCC   LAB_2925          ; branch if numeric character
009F58  1               
009F58  1               LAB_28C9
009F58  1  24 AB              BIT   expneg            ; test exponent -ve flag
009F5A  1  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
009F5C  1               
009F5C  1                                             ; else do exponent = -exponent
009F5C  1  A9 00              LDA   #$00              ; clear result
009F5E  1  38                 SEC                     ; set carry for subtract
009F5F  1  E5 A9              SBC   expcnt            ; subtract exponent byte
009F61  1  4C 6C 9F           JMP   LAB_28DD          ; go evaluate exponent
009F64  1               
009F64  1               LAB_28D5
009F64  1  66 AA              ROR   numdpf            ; set decimal point flag
009F66  1  24 AA              BIT   numdpf            ; test decimal point flag
009F68  1  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
009F6A  1               
009F6A  1                                             ; evaluate exponent
009F6A  1               LAB_28DB
009F6A  1  A5 A9              LDA   expcnt            ; get exponent count byte
009F6C  1               LAB_28DD
009F6C  1  38                 SEC                     ; set carry for subtract
009F6D  1  E5 A8              SBC   numexp            ; subtract numerator exponent
009F6F  1  85 A9              STA   expcnt            ; save exponent count byte
009F71  1  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
009F73  1               
009F73  1  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
009F75  1               
009F75  1                                             ; else go do FAC1/10^(0-expcnt)
009F75  1               LAB_28E6
009F75  1  20 4B 9D           JSR   LAB_26B9          ; divide by 10
009F78  1  E6 A9              INC   expcnt            ; increment exponent count byte
009F7A  1  D0 F9              BNE   LAB_28E6          ; loop until all done
009F7C  1               
009F7C  1  F0 07              BEQ   LAB_28F6          ; branch always
009F7E  1               
009F7E  1               LAB_28EF
009F7E  1  20 32 9D           JSR   LAB_269E          ; multiply by 10
009F81  1  C6 A9              DEC   expcnt            ; decrement exponent count byte
009F83  1  D0 F9              BNE   LAB_28EF          ; loop until all done
009F85  1               
009F85  1               LAB_28F6
009F85  1  A5 B1              LDA   negnum            ; get -ve flag
009F87  1  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
009F89  1               
009F89  1  60                 RTS
009F8A  1               
009F8A  1               ; do - FAC1 and return
009F8A  1               
009F8A  1               LAB_28FB
009F8A  1  4C 4F A1           JMP   LAB_GTHAN         ; do - FAC1 and return
009F8D  1               
009F8D  1               ; do unsigned FAC1*10+number
009F8D  1               
009F8D  1               LAB_28FE
009F8D  1  48                 PHA                     ; save character
009F8E  1  24 AA              BIT   numdpf            ; test decimal point flag
009F90  1  10 02              BPL   LAB_2905          ; skip exponent increment if not set
009F92  1               
009F92  1  E6 A8              INC   numexp            ; else increment number exponent
009F94  1               LAB_2905
009F94  1  20 32 9D           JSR   LAB_269E          ; multiply FAC1 by 10
009F97  1  68                 PLA                     ; restore character
009F98  1  29 0F              AND   #$0F              ; convert to binary
009F9A  1  20 A0 9F           JSR   LAB_2912          ; evaluate new ASCII digit
009F9D  1  4C 2D 9F           JMP   LAB_289E          ; go do next character
009FA0  1               
009FA0  1               ; evaluate new ASCII digit
009FA0  1               
009FA0  1               LAB_2912
009FA0  1  48                 PHA                     ; save digit
009FA1  1  20 25 9E           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009FA4  1  68                 PLA                     ; restore digit
009FA5  1  20 55 9E           JSR   LAB_27DB          ; save A as integer byte
009FA8  1  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
009FAA  1  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
009FAC  1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009FAE  1  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
009FB0  1  4C 1C 9B           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
009FB3  1               
009FB3  1               ; evaluate next character of exponential part of number
009FB3  1               
009FB3  1               LAB_2925
009FB3  1  A5 A9              LDA   expcnt            ; get exponent count byte
009FB5  1  C9 0A              CMP   #$0A              ; compare with 10 decimal
009FB7  1  90 09              BCC   LAB_2934          ; branch if less
009FB9  1               
009FB9  1  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
009FBB  1  24 AB              BIT   expneg            ; test exponent -ve flag
009FBD  1  30 0E              BMI   LAB_2942          ; branch if -ve
009FBF  1               
009FBF  1  4C 1E 9C           JMP   LAB_2564          ; else do overflow error
009FC2  1               
009FC2  1               LAB_2934
009FC2  1  0A                 ASL                     ; * 2
009FC3  1  0A                 ASL                     ; * 4
009FC4  1  65 A9              ADC   expcnt            ; * 5
009FC6  1  0A                 ASL                     ; * 10
009FC7  1  A0 00              LDY   #$00              ; set index
009FC9  1  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
009FCB  1  E9 2F              SBC   #'0'-1            ; convert character to binary
009FCD  1               LAB_2942
009FCD  1  85 A9              STA   expcnt            ; save exponent count byte
009FCF  1  4C 53 9F           JMP   LAB_28C4          ; go get next character
009FD2  1               
009FD2  1               ; print " in line [LINE #]"
009FD2  1               
009FD2  1               LAB_2953
009FD2  1  A9 FB              LDA   #<LAB_LMSG        ; point to " in line " message low byte
009FD4  1  A0 BC              LDY   #>LAB_LMSG        ; point to " in line " message high byte
009FD6  1  20 18 8E           JSR   LAB_18C3          ; print null terminated string from memory
009FD9  1               
009FD9  1                                             ; print Basic line #
009FD9  1  A5 88              LDA   Clineh            ; get current line high byte
009FDB  1  A6 87              LDX   Clinel            ; get current line low byte
009FDD  1               
009FDD  1               ; print XA as unsigned integer
009FDD  1               
009FDD  1               LAB_295E
009FDD  1  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
009FDF  1  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
009FE1  1  A2 90              LDX   #$90              ; set exponent to 16d bits
009FE3  1  38                 SEC                     ; set integer is +ve flag
009FE4  1  20 62 9E           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
009FE7  1  A0 00              LDY   #$00              ; clear index
009FE9  1  98                 TYA                     ; clear A
009FEA  1  20 FD 9F           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
009FED  1  4C 18 8E           JMP   LAB_18C3          ; print null terminated string from memory and return
009FF0  1               
009FF0  1               ; convert FAC1 to ASCII string result in (AY)
009FF0  1               ; not any more, moved scratchpad to page 0
009FF0  1               
009FF0  1               LAB_296E
009FF0  1  A0 01              LDY   #$01              ; set index = 1
009FF2  1  A9 20              LDA   #$20              ; character = " " (assume +ve)
009FF4  1  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
009FF6  1  10 02              BPL   LAB_2978          ; branch if +ve
009FF8  1               
009FF8  1  A9 2D              LDA   #$2D              ; else character = "-"
009FFA  1               LAB_2978
009FFA  1  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
009FFD  1               LAB_297B
009FFD  1  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
009FFF  1  84 BA              STY   Sendl             ; save index
00A001  1  C8                 INY                     ; increment index
00A002  1  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
00A004  1  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
00A006  1               
00A006  1                                             ; exponent was $00 so FAC1 is 0
00A006  1  A9 30              LDA   #'0'              ; set character = "0"
00A008  1  4C 09 A1           JMP   LAB_2A89          ; save last character, [EOT] and exit
00A00B  1               
00A00B  1                                             ; FAC1 is some non zero value
00A00B  1               LAB_2989
00A00B  1  A9 00              LDA   #$00              ; clear (number exponent count)
00A00D  1  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
00A00F  1               
00A00F  1  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
00A011  1               
00A011  1                                             ; FAC1<1
00A011  1  A9 D3              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
00A013  1  A0 B3              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
00A015  1  20 94 9C           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00A018  1  A9 FA              LDA   #$FA              ; set number exponent count (-6)
00A01A  1               LAB_299A
00A01A  1  85 A8              STA   numexp            ; save number exponent count
00A01C  1               LAB_299C
00A01C  1  A9 CF              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
00A01E  1  A0 B3              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
00A020  1  20 72 9E           JSR   LAB_27F8          ; compare FAC1 with (AY)
00A023  1  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
00A025  1               
00A025  1  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
00A027  1               
00A027  1                                             ; FAC1 < (AY)
00A027  1               LAB_29A7
00A027  1  A9 CB              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
00A029  1  A0 B3              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
00A02B  1  20 72 9E           JSR   LAB_27F8          ; compare FAC1 with (AY)
00A02E  1  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
00A030  1               
00A030  1  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
00A032  1               
00A032  1                                             ; FAC1 <= (AY)
00A032  1               LAB_29B2
00A032  1  20 32 9D           JSR   LAB_269E          ; multiply by 10
00A035  1  C6 A8              DEC   numexp            ; decrement number exponent count
00A037  1  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
00A039  1               
00A039  1               LAB_29B9
00A039  1  20 4B 9D           JSR   LAB_26B9          ; divide by 10
00A03C  1  E6 A8              INC   numexp            ; increment number exponent count
00A03E  1  D0 DC              BNE   LAB_299C          ; go test again (branch always)
00A040  1               
00A040  1               ; now we have just the digits to do
00A040  1               
00A040  1               LAB_29C0
00A040  1  20 15 9B           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
00A043  1               LAB_29C3
00A043  1  20 AB 9E           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00A046  1  A2 01              LDX   #$01              ; set default digits before dp = 1
00A048  1  A5 A8              LDA   numexp            ; get number exponent count
00A04A  1  18                 CLC                     ; clear carry for add
00A04B  1  69 07              ADC   #$07              ; up to 6 digits before point
00A04D  1  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
00A04F  1               
00A04F  1  C9 08              CMP   #$08              ; A>=8 if n>=1E6
00A051  1  B0 06              BCS   LAB_29D9          ; branch if >= $08
00A053  1               
00A053  1                                             ; carry is clear
00A053  1  69 FF              ADC   #$FF              ; take 1 from digit count
00A055  1  AA                 TAX                     ; copy to A
00A056  1  A9 02              LDA   #$02              ;.set exponent adjust
00A058  1               LAB_29D8
00A058  1  38                 SEC                     ; set carry for subtract
00A059  1               LAB_29D9
00A059  1  E9 02              SBC   #$02              ; -2
00A05B  1  85 A9              STA   expcnt            ;.save exponent adjust
00A05D  1  86 A8              STX   numexp            ; save digits before dp count
00A05F  1  8A                 TXA                     ; copy to A
00A060  1  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
00A062  1               
00A062  1  10 13              BPL   LAB_29F7          ; branch if digits before dp
00A064  1               
00A064  1               LAB_29E4
00A064  1  A4 BA              LDY   Sendl             ; get output string index
00A066  1  A9 2E              LDA   #$2E              ; character "."
00A068  1  C8                 INY                     ; increment index
00A069  1  99 EF 00           STA   Decss,Y           ; save to output string
00A06C  1  8A                 TXA                     ;.
00A06D  1  F0 06              BEQ   LAB_29F5          ;.
00A06F  1               
00A06F  1  A9 30              LDA   #'0'              ; character "0"
00A071  1  C8                 INY                     ; increment index
00A072  1  99 EF 00           STA   Decss,Y           ; save to output string
00A075  1               LAB_29F5
00A075  1  84 BA              STY   Sendl             ; save output string index
00A077  1               LAB_29F7
00A077  1  A0 00              LDY   #$00              ; clear index (point to 100,000)
00A079  1  A2 80              LDX   #$80              ;
00A07B  1               LAB_29FB
00A07B  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00A07D  1  18                 CLC                     ; clear carry for add
00A07E  1  79 49 B4           ADC   LAB_2A9C,Y        ; add -ve LSB
00A081  1  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00A083  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00A085  1  79 48 B4           ADC   LAB_2A9B,Y        ; add -ve NMSB
00A088  1  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00A08A  1  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00A08C  1  79 47 B4           ADC   LAB_2A9A,Y        ; add -ve MSB
00A08F  1  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00A091  1  E8                 INX                     ;
00A092  1  B0 04              BCS   LAB_2A18          ;
00A094  1               
00A094  1  10 E5              BPL   LAB_29FB          ; not -ve so try again
00A096  1               
00A096  1  30 02              BMI   LAB_2A1A          ;
00A098  1               
00A098  1               LAB_2A18
00A098  1  30 E1              BMI   LAB_29FB          ;
00A09A  1               
00A09A  1               LAB_2A1A
00A09A  1  8A                 TXA                     ;
00A09B  1  90 04              BCC   LAB_2A21          ;
00A09D  1               
00A09D  1  49 FF              EOR   #$FF              ;
00A09F  1  69 0A              ADC   #$0A              ;
00A0A1  1               LAB_2A21
00A0A1  1  69 2F              ADC   #'0'-1            ; add "0"-1 to result
00A0A3  1  C8                 INY                     ; increment index ..
00A0A4  1  C8                 INY                     ; .. to next less ..
00A0A5  1  C8                 INY                     ; .. power of ten
00A0A6  1  84 95              STY   Cvaral            ; save as current var address low byte
00A0A8  1  A4 BA              LDY   Sendl             ; get output string index
00A0AA  1  C8                 INY                     ; increment output string index
00A0AB  1  AA                 TAX                     ; copy character to X
00A0AC  1  29 7F              AND   #$7F              ; mask out top bit
00A0AE  1  99 EF 00           STA   Decss,Y           ; save to output string
00A0B1  1  C6 A8              DEC   numexp            ; decrement # of characters before the dp
00A0B3  1  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
00A0B5  1               
00A0B5  1                                             ; else output the point
00A0B5  1  A9 2E              LDA   #$2E              ; character "."
00A0B7  1  C8                 INY                     ; increment output string index
00A0B8  1  99 EF 00           STA   Decss,Y           ; save to output string
00A0BB  1               LAB_2A3B
00A0BB  1  84 BA              STY   Sendl             ; save output string index
00A0BD  1  A4 95              LDY   Cvaral            ; get current var address low byte
00A0BF  1  8A                 TXA                     ; get character back
00A0C0  1  49 FF              EOR   #$FF              ;
00A0C2  1  29 80              AND   #$80              ;
00A0C4  1  AA                 TAX                     ;
00A0C5  1  C0 12              CPY   #$12              ; compare index with max
00A0C7  1  D0 B2              BNE   LAB_29FB          ; loop if not max
00A0C9  1               
00A0C9  1                                             ; now remove trailing zeroes
00A0C9  1  A4 BA              LDY   Sendl             ; get output string index
00A0CB  1               LAB_2A4B
00A0CB  1  B9 EF 00           LDA   Decss,Y           ; get character from output string
00A0CE  1  88                 DEY                     ; decrement output string index
00A0CF  1  C9 30              CMP   #'0'              ; compare with "0"
00A0D1  1  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
00A0D3  1               
00A0D3  1  C9 2E              CMP   #'.'              ; compare with "."
00A0D5  1  F0 01              BEQ   LAB_2A58          ; branch if was dp
00A0D7  1               
00A0D7  1                                             ; restore last character
00A0D7  1  C8                 INY                     ; increment output string index
00A0D8  1               LAB_2A58
00A0D8  1  A9 2B              LDA   #$2B              ; character "+"
00A0DA  1  A6 A9              LDX   expcnt            ; get exponent count
00A0DC  1  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
00A0DE  1               
00A0DE  1                                             ; exponent isn't zero so write exponent
00A0DE  1  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
00A0E0  1               
00A0E0  1  A9 00              LDA   #$00              ; clear A
00A0E2  1  38                 SEC                     ; set carry for subtract
00A0E3  1  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
00A0E5  1  AA                 TAX                     ; copy exponent count to X
00A0E6  1  A9 2D              LDA   #'-'              ; character "-"
00A0E8  1               LAB_2A68
00A0E8  1  99 F1 00           STA   Decss+2,Y         ; save to output string
00A0EB  1  A9 45              LDA   #$45              ; character "E"
00A0ED  1  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
00A0F0  1  8A                 TXA                     ; get exponent count back
00A0F1  1  A2 2F              LDX   #'0'-1            ; one less than "0" character
00A0F3  1  38                 SEC                     ; set carry for subtract
00A0F4  1               LAB_2A74
00A0F4  1  E8                 INX                     ; increment 10's character
00A0F5  1  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
00A0F7  1  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
00A0F9  1               
00A0F9  1  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
00A0FB  1  99 F3 00           STA   Decss+4,Y         ; save to output string
00A0FE  1  8A                 TXA                     ; copy 10's character
00A0FF  1  99 F2 00           STA   Decss+3,Y         ; save to output string
00A102  1  A9 00              LDA   #$00              ; set null terminator
00A104  1  99 F4 00           STA   Decss+5,Y         ; save to output string
00A107  1  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
00A109  1               
00A109  1                                             ; save last character, [EOT] and exit
00A109  1               LAB_2A89
00A109  1  99 EF 00           STA   Decss,Y           ; save last character to output string
00A10C  1               
00A10C  1                                             ; set null terminator and exit
00A10C  1               LAB_2A8C
00A10C  1  A9 00              LDA   #$00              ; set null terminator
00A10E  1  99 F0 00           STA   Decss+1,Y         ; save after last character
00A111  1               
00A111  1                                             ; set string pointer (AY) and exit
00A111  1               LAB_2A91
00A111  1  A9 F0              LDA   #<Decssp1         ; set result string low pointer
00A113  1  A0 00              LDY   #>Decssp1         ; set result string high pointer
00A115  1  60                 RTS
00A116  1               
00A116  1               ; perform power function
00A116  1               
00A116  1               LAB_POWER
00A116  1  F0 42              BEQ   LAB_EXP           ; go do  EXP()
00A118  1               
00A118  1  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00A11A  1  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
00A11C  1               
00A11C  1  4C AD 9B           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
00A11F  1               
00A11F  1               LAB_2ABF
00A11F  1  A2 9C              LDX   #<func_l          ; set destination pointer low byte
00A121  1  A0 00              LDY   #>func_l          ; set destination pointer high byte
00A123  1  20 02 9E           JSR   LAB_2778          ; pack FAC1 into (XY)
00A126  1  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00A128  1  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
00A12A  1               
00A12A  1                                             ; else FAC2 is -ve and can only be raised to an
00A12A  1                                             ; integer power which gives an x +j0 result
00A12A  1  20 DC 9E           JSR   LAB_INT           ; perform INT
00A12D  1  A9 9C              LDA   #<func_l          ; set source pointer low byte
00A12F  1  A0 00              LDY   #>func_l          ; set source pointer high byte
00A131  1  20 72 9E           JSR   LAB_27F8          ; compare FAC1 with (AY)
00A134  1  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
00A136  1                                             ; this will leave FAC1 -ve and cause a Function Call
00A136  1                                             ; error when LOG() is called
00A136  1               
00A136  1  98                 TYA                     ; clear sign b7
00A137  1  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
00A139  1                                             ; for possible later negation, b0
00A139  1               LAB_2AD9
00A139  1  20 20 9B           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
00A13C  1  98                 TYA                     ; copy sign back ..
00A13D  1  48                 PHA                     ; .. and save it
00A13E  1  20 56 9C           JSR   LAB_LOG           ; do LOG(n)
00A141  1  A9 9C              LDA   #<garb_l          ; set pointer low byte
00A143  1  A0 00              LDY   #>garb_l          ; set pointer high byte
00A145  1  20 94 9C           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
00A148  1  20 5A A1           JSR   LAB_EXP           ; go do EXP(n)
00A14B  1  68                 PLA                     ; pull sign from stack
00A14C  1  4A                 LSR                     ; b0 is to be tested, shift to Cb
00A14D  1  90 0A              BCC   LAB_2AF9          ; if no bit then exit
00A14F  1               
00A14F  1                                             ; Perform negation
00A14F  1               ; do - FAC1
00A14F  1               
00A14F  1               LAB_GTHAN
00A14F  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A151  1  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
00A153  1               
00A153  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00A155  1  49 FF              EOR   #$FF              ; complement it
00A157  1  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00A159  1               LAB_2AF9
00A159  1  60                 RTS
00A15A  1               
00A15A  1               ; perform EXP()   (x^e)
00A15A  1               
00A15A  1               LAB_EXP
00A15A  1  A9 D7              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
00A15C  1  A0 B3              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
00A15E  1  20 94 9C           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00A161  1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00A163  1  69 50              ADC   #$50              ; +$50/$100
00A165  1  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
00A167  1               
00A167  1  20 3C 9E           JSR   LAB_27C2          ; round FAC1 (no check)
00A16A  1               LAB_2B2B
00A16A  1  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
00A16C  1  20 28 9E           JSR   LAB_27AE          ; copy FAC1 to FAC2
00A16F  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A171  1  C9 88              CMP   #$88              ; compare with EXP limit (256d)
00A173  1  90 03              BCC   LAB_2B39          ; branch if less
00A175  1               
00A175  1               LAB_2B36
00A175  1  20 29 9D           JSR   LAB_2690          ; handle overflow and underflow
00A178  1               LAB_2B39
00A178  1  20 DC 9E           JSR   LAB_INT           ; perform INT
00A17B  1  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
00A17D  1  18                 CLC                     ; clear carry for add
00A17E  1  69 81              ADC   #$81              ; normalise +1
00A180  1  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
00A182  1               
00A182  1  38                 SEC                     ; set carry for subtract
00A183  1  E9 01              SBC   #$01              ; now correct for exponent
00A185  1  48                 PHA                     ; save FAC2 exponent
00A186  1               
00A186  1                                             ; swap FAC1 and FAC2
00A186  1  A2 04              LDX   #$04              ; 4 bytes to do
00A188  1               LAB_2B49
00A188  1  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
00A18A  1  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
00A18C  1  95 AC              STA   FAC1_e,X          ; save FAC1,X
00A18E  1  94 B3              STY   FAC2_e,X          ; save FAC2,X
00A190  1  CA                 DEX                     ; decrement count/index
00A191  1  10 F5              BPL   LAB_2B49          ; loop if not all done
00A193  1               
00A193  1  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
00A195  1  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
00A197  1  20 01 9B           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
00A19A  1  20 4F A1           JSR   LAB_GTHAN         ; do - FAC1
00A19D  1  A9 DB              LDA   #<LAB_2AFE        ; set counter pointer low byte
00A19F  1  A0 B3              LDY   #>LAB_2AFE        ; set counter pointer high byte
00A1A1  1  20 C2 A1           JSR   LAB_2B84          ; go do series evaluation
00A1A4  1  A9 00              LDA   #$00              ; clear A
00A1A6  1  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00A1A8  1  68                 PLA                     ;.get saved FAC2 exponent
00A1A9  1  4C 0E 9D           JMP   LAB_2675          ; test and adjust accumulators and return
00A1AC  1               
00A1AC  1               ; ^2 then series evaluation
00A1AC  1               
00A1AC  1               LAB_2B6E
00A1AC  1  85 BA              STA   Cptrl             ; save count pointer low byte
00A1AE  1  84 BB              STY   Cptrh             ; save count pointer high byte
00A1B0  1  20 F8 9D           JSR   LAB_276E          ; pack FAC1 into Adatal
00A1B3  1  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
00A1B5  1  20 94 9C           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00A1B8  1  20 C6 A1           JSR   LAB_2B88          ; go do series evaluation
00A1BB  1  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
00A1BD  1  A0 00              LDY   #>Adatal          ; pointer to original # high byte
00A1BF  1  4C 94 9C           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
00A1C2  1               
00A1C2  1               ; series evaluation
00A1C2  1               
00A1C2  1               LAB_2B84
00A1C2  1  85 BA              STA   Cptrl             ; save count pointer low byte
00A1C4  1  84 BB              STY   Cptrh             ; save count pointer high byte
00A1C6  1               LAB_2B88
00A1C6  1  A2 A8              LDX   #<numexp          ; set pointer low byte
00A1C8  1  20 FA 9D           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
00A1CB  1  B1 BA              LDA   (Cptrl),Y         ; get constants count
00A1CD  1  85 B1              STA   numcon            ; save constants count
00A1CF  1  A4 BA              LDY   Cptrl             ; get count pointer low byte
00A1D1  1  C8                 INY                     ; increment it (now constants pointer)
00A1D2  1  98                 TYA                     ; copy it
00A1D3  1  D0 02              BNE   LAB_2B97          ; skip next if no overflow
00A1D5  1               
00A1D5  1  E6 BB              INC   Cptrh             ; else increment high byte
00A1D7  1               LAB_2B97
00A1D7  1  85 BA              STA   Cptrl             ; save low byte
00A1D9  1  A4 BB              LDY   Cptrh             ; get high byte
00A1DB  1               LAB_2B9B
00A1DB  1  20 94 9C           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00A1DE  1  A5 BA              LDA   Cptrl             ; get constants pointer low byte
00A1E0  1  A4 BB              LDY   Cptrh             ; get constants pointer high byte
00A1E2  1  18                 CLC                     ; clear carry for add
00A1E3  1  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
00A1E5  1  90 01              BCC   LAB_2BA8          ; skip next if no overflow
00A1E7  1               
00A1E7  1  C8                 INY                     ; increment high byte
00A1E8  1               LAB_2BA8
00A1E8  1  85 BA              STA   Cptrl             ; save pointer low byte
00A1EA  1  84 BB              STY   Cptrh             ; save pointer high byte
00A1EC  1  20 19 9B           JSR   LAB_246C          ; add (AY) to FAC1
00A1EF  1  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
00A1F1  1  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
00A1F3  1  C6 B1              DEC   numcon            ; decrement constants count
00A1F5  1  D0 E4              BNE   LAB_2B9B          ; loop until all done
00A1F7  1               
00A1F7  1  60                 RTS
00A1F8  1               
00A1F8  1               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
00A1F8  1               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
00A1F8  1               ; the Galois method and a sample of 65536 bytes produced gives the following values.
00A1F8  1               
00A1F8  1               ; Entropy = 7.997442 bits per byte
00A1F8  1               ; Optimum compression would reduce these 65536 bytes by 0 percent
00A1F8  1               
00A1F8  1               ; Chi square distribution for 65536 samples is 232.01, and
00A1F8  1               ; randomly would exceed this value 75.00 percent of the time
00A1F8  1               
00A1F8  1               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00A1F8  1               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00A1F8  1               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00A1F8  1               
00A1F8  1               LAB_RND
00A1F8  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A1FA  1  F0 07              BEQ   NextPRN           ; do next random # if zero
00A1FC  1               
00A1FC  1                                             ; else get seed into random number store
00A1FC  1  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
00A1FE  1  A0 00              LDY   #$00              ; set PRNG pointer high byte
00A200  1  20 02 9E           JSR   LAB_2778          ; pack FAC1 into (XY)
00A203  1               NextPRN
00A203  1  A2 AF              LDX   #$AF              ; set EOR byte
00A205  1  A0 13              LDY   #$13              ; do this nineteen times
00A207  1               LoopPRN
00A207  1  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
00A209  1  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
00A20B  1  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
00A20D  1  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
00A20F  1  90 05              BCC   Ninc1             ; branch if bit 32 clear
00A211  1               
00A211  1  8A                 TXA                     ; set EOR byte
00A212  1  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
00A214  1  85 D9              STA   Rbyte1            ; save new PRNG extra byte
00A216  1               Ninc1
00A216  1  88                 DEY                     ; decrement loop count
00A217  1  D0 EE              BNE   LoopPRN           ; loop if not all done
00A219  1               
00A219  1  A2 02              LDX   #$02              ; three bytes to copy
00A21B  1               CopyPRNG
00A21B  1  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
00A21D  1  95 AD              STA   FAC1_1,X          ; save FAC1 byte
00A21F  1  CA                 DEX
00A220  1  10 F9              BPL   CopyPRNG          ; loop if not complete
00A222  1               
00A222  1  A9 80              LDA   #$80              ; set the exponent
00A224  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
00A226  1               
00A226  1  0A                 ASL                     ; clear A
00A227  1  85 B0              STA   FAC1_s            ; save FAC1 sign
00A229  1               
00A229  1  4C 8F 9B           JMP   LAB_24D5          ; normalise FAC1 and return
00A22C  1               
00A22C  1               ; perform COS()
00A22C  1               
00A22C  1               LAB_COS
00A22C  1  A9 F8              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
00A22E  1  A0 B3              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
00A230  1  20 19 9B           JSR   LAB_246C          ; add (AY) to FAC1
00A233  1               
00A233  1               ; perform SIN()
00A233  1               
00A233  1               LAB_SIN
00A233  1  20 25 9E           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00A236  1  A9 0D              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00A238  1  A0 B4              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00A23A  1  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
00A23C  1  20 54 9D           JSR   LAB_26C2          ; divide by (AY) (X=sign)
00A23F  1  20 25 9E           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00A242  1  20 DC 9E           JSR   LAB_INT           ; perform INT
00A245  1  A9 00              LDA   #$00              ; clear byte
00A247  1  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00A249  1  20 01 9B           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
00A24C  1  A9 3F              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
00A24E  1  A0 B4              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
00A250  1  20 FE 9A           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
00A253  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00A255  1  48                 PHA                     ; save FAC1 sign
00A256  1  10 0D              BPL   LAB_2C35          ; branch if +ve
00A258  1               
00A258  1                                             ; FAC1 sign was -ve
00A258  1  20 15 9B           JSR   LAB_244E          ; add 0.5 to FAC1
00A25B  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00A25D  1  30 09              BMI   LAB_2C38          ; branch if -ve
00A25F  1               
00A25F  1  A5 63              LDA   Cflag             ; get comparison evaluation flag
00A261  1  49 FF              EOR   #$FF              ; toggle flag
00A263  1  85 63              STA   Cflag             ; save comparison evaluation flag
00A265  1               LAB_2C35
00A265  1  20 4F A1           JSR   LAB_GTHAN         ; do - FAC1
00A268  1               LAB_2C38
00A268  1  A9 3F              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
00A26A  1  A0 B4              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
00A26C  1  20 19 9B           JSR   LAB_246C          ; add (AY) to FAC1
00A26F  1  68                 PLA                     ; restore FAC1 sign
00A270  1  10 03              BPL   LAB_2C45          ; branch if was +ve
00A272  1               
00A272  1                                             ; else correct FAC1
00A272  1  20 4F A1           JSR   LAB_GTHAN         ; do - FAC1
00A275  1               LAB_2C45
00A275  1  A9 FC              LDA   #<LAB_2C84        ; set pointer low byte to counter
00A277  1  A0 B3              LDY   #>LAB_2C84        ; set pointer high byte to counter
00A279  1  4C AC A1           JMP   LAB_2B6E          ; ^2 then series evaluation and return
00A27C  1               
00A27C  1               ; perform TAN()
00A27C  1               
00A27C  1               LAB_TAN
00A27C  1  20 F8 9D           JSR   LAB_276E          ; pack FAC1 into Adatal
00A27F  1  A9 00              LDA   #$00              ; clear byte
00A281  1  85 63              STA   Cflag             ; clear comparison evaluation flag
00A283  1  20 33 A2           JSR   LAB_SIN           ; go do SIN(n)
00A286  1  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
00A288  1  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
00A28A  1  20 02 9E           JSR   LAB_2778          ; pack FAC1 into (XY)
00A28D  1  A9 A4              LDA   #<Adatal          ; set n pointer low addr
00A28F  1  A0 00              LDY   #>Adatal          ; set n pointer high addr
00A291  1  20 D8 9D           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00A294  1  A9 00              LDA   #$00              ; clear byte
00A296  1  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00A298  1  A5 63              LDA   Cflag             ; get comparison evaluation flag
00A29A  1  20 A4 A2           JSR   LAB_2C74          ; save flag and go do series evaluation
00A29D  1               
00A29D  1  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
00A29F  1  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
00A2A1  1  4C 5C 9D           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
00A2A4  1               
00A2A4  1               LAB_2C74
00A2A4  1  48                 PHA                     ; save comparison evaluation flag
00A2A5  1  4C 65 A2           JMP   LAB_2C35          ; go do series evaluation
00A2A8  1               
00A2A8  1               ; perform USR()
00A2A8  1               
00A2A8  1               LAB_USR
00A2A8  1  20 0A 00           JSR   Usrjmp            ; call user code
00A2AB  1  4C 3E 91           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00A2AE  1               
00A2AE  1               ; perform ATN()
00A2AE  1               
00A2AE  1               LAB_ATN
00A2AE  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00A2B0  1  48                 PHA                     ; save sign
00A2B1  1  10 03              BPL   LAB_2CA1          ; branch if +ve
00A2B3  1               
00A2B3  1  20 4F A1           JSR   LAB_GTHAN         ; else do - FAC1
00A2B6  1               LAB_2CA1
00A2B6  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A2B8  1  48                 PHA                     ; push exponent
00A2B9  1  C9 81              CMP   #$81              ; compare with 1
00A2BB  1  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
00A2BD  1               
00A2BD  1  A9 32              LDA   #<LAB_259C        ; set 1 pointer low byte
00A2BF  1  A0 B4              LDY   #>LAB_259C        ; set 1 pointer high byte
00A2C1  1  20 5C 9D           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
00A2C4  1               LAB_2CAF
00A2C4  1  A9 11              LDA   #<LAB_2CC9        ; set pointer low byte to counter
00A2C6  1  A0 B4              LDY   #>LAB_2CC9        ; set pointer high byte to counter
00A2C8  1  20 AC A1           JSR   LAB_2B6E          ; ^2 then series evaluation
00A2CB  1  68                 PLA                     ; restore old FAC1 exponent
00A2CC  1  C9 81              CMP   #$81              ; compare with 1
00A2CE  1  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
00A2D0  1               
00A2D0  1  A9 F8              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
00A2D2  1  A0 B3              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
00A2D4  1  20 FE 9A           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
00A2D7  1               LAB_2CC2
00A2D7  1  68                 PLA                     ; restore FAC1 sign
00A2D8  1  10 16              BPL   LAB_2D04          ; exit if was +ve
00A2DA  1               
00A2DA  1  4C 4F A1           JMP   LAB_GTHAN         ; else do - FAC1 and return
00A2DD  1               
00A2DD  1               ; perform BITSET
00A2DD  1               
00A2DD  1               LAB_BITSET
00A2DD  1  20 33 9A           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00A2E0  1  E0 08              CPX   #$08              ; only 0 to 7 are allowed
00A2E2  1  B0 20              BCS   FCError           ; branch if > 7
00A2E4  1               
00A2E4  1  A9 00              LDA   #$00              ; clear A
00A2E6  1  38                 SEC                     ; set the carry
00A2E7  1               S_Bits
00A2E7  1  2A                 ROL                     ; shift bit
00A2E8  1  CA                 DEX                     ; decrement bit number
00A2E9  1  10 FC              BPL   S_Bits            ; loop if still +ve
00A2EB  1               
00A2EB  1  E8                 INX                     ; make X = $00
00A2EC  1  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
00A2EE  1  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
00A2F0  1               LAB_2D04
00A2F0  1  60                 RTS
00A2F1  1               
00A2F1  1               ; perform BITCLR
00A2F1  1               
00A2F1  1               LAB_BITCLR
00A2F1  1  20 33 9A           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00A2F4  1  E0 08              CPX   #$08              ; only 0 to 7 are allowed
00A2F6  1  B0 0C              BCS   FCError           ; branch if > 7
00A2F8  1               
00A2F8  1  A9 FF              LDA   #$FF              ; set A
00A2FA  1               S_Bitc
00A2FA  1  2A                 ROL                     ; shift bit
00A2FB  1  CA                 DEX                     ; decrement bit number
00A2FC  1  10 FC              BPL   S_Bitc            ; loop if still +ve
00A2FE  1               
00A2FE  1  E8                 INX                     ; make X = $00
00A2FF  1  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
00A301  1  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
00A303  1  60                 RTS
00A304  1               
00A304  1               FCError
00A304  1  4C 78 94           JMP   LAB_FCER          ; do function call error then warm start
00A307  1               
00A307  1               ; perform BITTST()
00A307  1               
00A307  1               LAB_BTST
00A307  1  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
00A30A  1  20 33 9A           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00A30D  1  E0 08              CPX   #$08              ; only 0 to 7 are allowed
00A30F  1  B0 F3              BCS   FCError           ; branch if > 7
00A311  1               
00A311  1  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00A314  1  C9 29              CMP   #')'              ; is next character ")"
00A316  1  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
00A318  1               
00A318  1  4C 51 91           JMP   LAB_SNER          ; do syntax error then warm start
00A31B  1               
00A31B  1               TST_OK
00A31B  1  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
00A31E  1  A9 00              LDA   #$00              ; clear A
00A320  1  38                 SEC                     ; set the carry
00A321  1               T_Bits
00A321  1  2A                 ROL                     ; shift bit
00A322  1  CA                 DEX                     ; decrement bit number
00A323  1  10 FC              BPL   T_Bits            ; loop if still +ve
00A325  1               
00A325  1  E8                 INX                     ; make X = $00
00A326  1  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
00A328  1  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
00A32A  1               
00A32A  1  A9 FF              LDA   #$FF              ; set for -1 result
00A32C  1               LAB_NOTT
00A32C  1  4C 55 9E           JMP   LAB_27DB          ; go do SGN tail
00A32F  1               
00A32F  1               ; perform BIN$()
00A32F  1               
00A32F  1               LAB_BINS
00A32F  1  E0 19              CPX   #$19              ; max + 1
00A331  1  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
00A333  1               
00A333  1  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
00A335  1  A9 18              LDA   #$18              ; need A byte long space
00A337  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long
00A33A  1  A0 17              LDY   #$17              ; set index
00A33C  1  A2 18              LDX   #$18              ; character count
00A33E  1               NextB1
00A33E  1  46 11              LSR   nums_1            ; shift highest byte
00A340  1  66 12              ROR   nums_2            ; shift middle byte
00A342  1  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
00A344  1  8A                 TXA                     ; load with "0"/2
00A345  1  2A                 ROL                     ; shift in carry
00A346  1  91 AD              STA   (str_pl),Y        ; save to temp string + index
00A348  1  88                 DEY                     ; decrement index
00A349  1  10 F3              BPL   NextB1            ; loop if not done
00A34B  1               
00A34B  1  A5 78              LDA   TempB             ; get # of characters
00A34D  1  F0 0A              BEQ   EndBHS            ; branch if truncate
00A34F  1               
00A34F  1  AA                 TAX                     ; copy length to X
00A350  1  38                 SEC                     ; set carry for add !
00A351  1  49 FF              EOR   #$FF              ; 1's complement
00A353  1  69 18              ADC   #$18              ; add 24d
00A355  1  F0 1C              BEQ   GoPr2             ; if zero print whole string
00A357  1               
00A357  1  D0 0F              BNE   GoPr1             ; else go make output string
00A359  1               
00A359  1               ; this is the exit code and is also used by HEX$()
00A359  1               ; truncate string to remove leading "0"s
00A359  1               
00A359  1               EndBHS
00A359  1  A8                 TAY                     ; clear index (A=0, X=length here)
00A35A  1               NextB2
00A35A  1  B1 AD              LDA   (str_pl),Y        ; get character from string
00A35C  1  C9 30              CMP   #'0'              ; compare with "0"
00A35E  1  D0 07              BNE   GoPr              ; if not "0" then go print string from here
00A360  1               
00A360  1  CA                 DEX                     ; decrement character count
00A361  1  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
00A363  1               
00A363  1  C8                 INY                     ; else increment index
00A364  1  10 F4              BPL   NextB2            ; loop always
00A366  1               
00A366  1               ; make fixed length output string - ignore overflows!
00A366  1               
00A366  1               GoPr3
00A366  1  E8                 INX                     ; need at least 1 character
00A367  1               GoPr
00A367  1  98                 TYA                     ; copy result
00A368  1               GoPr1
00A368  1  18                 CLC                     ; clear carry for add
00A369  1  65 AD              ADC   str_pl            ; add low address
00A36B  1  85 AD              STA   str_pl            ; save low address
00A36D  1  A9 00              LDA   #$00              ; do high byte
00A36F  1  65 AE              ADC   str_ph            ; add high address
00A371  1  85 AE              STA   str_ph            ; save high address
00A373  1               GoPr2
00A373  1  86 AC              STX   str_ln            ; X holds string length
00A375  1  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
00A378  1  4C E1 96           JMP   LAB_RTST          ; check for space on descriptor stack then put address
00A37B  1                                             ; and length on descriptor stack and update stack pointers
00A37B  1               
00A37B  1               BinFErr
00A37B  1  4C 78 94           JMP   LAB_FCER          ; do function call error then warm start
00A37E  1               
00A37E  1               ; perform HEX$()
00A37E  1               
00A37E  1               LAB_HEXS
00A37E  1  E0 07              CPX   #$07              ; max + 1
00A380  1  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
00A382  1               
00A382  1  86 78              STX   TempB             ; save # of characters
00A384  1               
00A384  1  A9 06              LDA   #$06              ; need 6 bytes for string
00A386  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long
00A389  1  A0 05              LDY   #$05              ; set string index
00A38B  1               
00A38B  1               ; *** disable decimal mode patch - comment next line ***
00A38B  1               ;      SED                     ; need decimal mode for nibble convert
00A38B  1  A5 13              LDA   nums_3            ; get lowest byte
00A38D  1  20 AA A3           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00A390  1  A5 12              LDA   nums_2            ; get middle byte
00A392  1  20 AA A3           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00A395  1  A5 11              LDA   nums_1            ; get highest byte
00A397  1  20 AA A3           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00A39A  1               ; *** disable decimal mode patch - comment next line ***
00A39A  1               ;      CLD                     ; back to binary
00A39A  1               
00A39A  1  A2 06              LDX   #$06              ; character count
00A39C  1  A5 78              LDA   TempB             ; get # of characters
00A39E  1  F0 B9              BEQ   EndBHS            ; branch if truncate
00A3A0  1               
00A3A0  1  AA                 TAX                     ; copy length to X
00A3A1  1  38                 SEC                     ; set carry for add !
00A3A2  1  49 FF              EOR   #$FF              ; 1's complement
00A3A4  1  69 06              ADC   #$06              ; add 6d
00A3A6  1  F0 CB              BEQ   GoPr2             ; if zero print whole string
00A3A8  1               
00A3A8  1  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
00A3AA  1               
00A3AA  1               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00A3AA  1               
00A3AA  1               LAB_A2HX
00A3AA  1  AA                 TAX                     ; save byte
00A3AB  1  29 0F              AND   #$0F              ; mask off top bits
00A3AD  1  20 B5 A3           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
00A3B0  1  8A                 TXA                     ; get byte back
00A3B1  1  4A                 LSR                     ; /2  shift high nibble to low nibble
00A3B2  1  4A                 LSR                     ; /4
00A3B3  1  4A                 LSR                     ; /8
00A3B4  1  4A                 LSR                     ; /16
00A3B5  1               LAB_AL2X
00A3B5  1  C9 0A              CMP   #$0A              ; set carry for +1 if >9
00A3B7  1               ; *** begin disable decimal mode patch ***
00A3B7  1               ; *** insert
00A3B7  1  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
00A3B9  1  69 06              ADC   #$06              ; adjust for A to F
00A3BB  1               LAB_AL20
00A3BB  1               ; *** end   disable decimal mode patch ***
00A3BB  1  69 30              ADC   #'0'              ; add ASCII "0"
00A3BD  1  91 AD              STA   (str_pl),Y        ; save to temp string
00A3BF  1  88                 DEY                     ; decrement counter
00A3C0  1  60                 RTS
00A3C1  1               
00A3C1  1               LAB_NLTO
00A3C1  1  85 AC              STA   FAC1_e            ; save FAC1 exponent
00A3C3  1  A9 00              LDA   #$00              ; clear sign compare
00A3C5  1               LAB_MLTE
00A3C5  1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00A3C7  1  8A                 TXA                     ; restore character
00A3C8  1  20 A0 9F           JSR   LAB_2912          ; evaluate new ASCII digit
00A3CB  1               
00A3CB  1               ; gets here if the first character was "$" for hex
00A3CB  1               ; get hex number
00A3CB  1               
00A3CB  1               LAB_CHEX
00A3CB  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00A3CE  1  90 0A              BCC   LAB_ISHN          ; branch if numeric character
00A3D0  1               
00A3D0  1  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
00A3D2  1  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
00A3D4  1  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
00A3D6  1  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
00A3D8  1               
00A3D8  1  69 0A              ADC   #$0A              ; convert to nibble
00A3DA  1               LAB_ISHN
00A3DA  1  29 0F              AND   #$0F              ; convert to binary
00A3DC  1  AA                 TAX                     ; save nibble
00A3DD  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A3DF  1  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
00A3E1  1               
00A3E1  1  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
00A3E3  1  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
00A3E5  1               
00A3E5  1               LAB_MLTO
00A3E5  1  4C 1E 9C           JMP   LAB_2564          ; do overflow error and warm start
00A3E8  1               
00A3E8  1               LAB_NXCH
00A3E8  1  AA                 TAX                     ; save bit
00A3E9  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A3EB  1  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
00A3ED  1               
00A3ED  1  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
00A3EF  1  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
00A3F1  1               
00A3F1  1  A9 00              LDA   #$00              ; clear sign compare
00A3F3  1               LAB_MLBT
00A3F3  1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00A3F5  1  8A                 TXA                     ; restore bit
00A3F6  1  20 A0 9F           JSR   LAB_2912          ; evaluate new ASCII digit
00A3F9  1               
00A3F9  1               ; gets here if the first character was  "%" for binary
00A3F9  1               ; get binary number
00A3F9  1               
00A3F9  1               LAB_CBIN
00A3F9  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00A3FC  1  49 30              EOR   #'0'              ; convert "0" to 0 etc.
00A3FE  1  C9 02              CMP   #$02              ; compare with max+1
00A400  1  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
00A402  1               
00A402  1               LAB_EXCH
00A402  1  4C 85 9F           JMP   LAB_28F6          ; evaluate -ve flag and return
00A405  1               
00A405  1               .ifdef APPLE2
00A405  1               ; wait for a keypress
00A405  1               LAB_PAUS
00A405  1  20 14 AF           JSR   V_INPT
00A408  1  90 FB              BCC   LAB_PAUS
00A40A  1  60                 RTS
00A40B  1               .endif
00A40B  1               
00A40B  1               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
00A40B  1               ; now also the code that checks to see if an interrupt has occurred
00A40B  1               
00A40B  1               CTRLC
00A40B  1  AD rr rr           LDA   ccflag            ; get [CTRL-C] check flag
00A40E  1  D0 2A              BNE   LAB_FBA2          ; exit if inhibited
00A410  1               
00A410  1               .ifdef APPLE2
00A410  1                     ; this defeats the one-byte buffer, but is more like AppleSoft
00A410  1  5A                 PHY
00A411  1  DA                 PHX
00A412  1  20 36 B0           JSR   DO_VEC_IN_STATUS  ; see if input device has char waiting
00A415  1  FA                 PLX
00A416  1  7A                 PLY
00A417  1  90 21              BCC   LAB_FBA2          ; and exit if nothing there
00A419  1               .endif
00A419  1               
00A419  1  20 14 AF           JSR   V_INPT            ; scan input device
00A41C  1  90 14              BCC   LAB_FBA0          ; exit if buffer empty
00A41E  1               
00A41E  1               .ifdef APPLE2
00A41E  1                     ; note that if CTRL-C is inhibited, so is CTRL-S
00A41E  1  C9 13              CMP   #$13              ; [CTRL-S]
00A420  1  D0 05              BNE   :+
00A422  1  20 05 A4           JSR   LAB_PAUS          ; wait for keypress
00A425  1  B0 0B              BCS   LAB_FBA0          ; eat returned keystroke from PAUSE
00A427  1               :
00A427  1               .endif
00A427  1               
00A427  1  8D rr rr           STA   ccbyte            ; save received byte
00A42A  1  A2 20              LDX   #$20              ; "life" timer for bytes
00A42C  1  8E rr rr           STX   ccnull            ; set countdown
00A42F  1  4C 43 8A           JMP   LAB_1636          ; return to BASIC
00A432  1               
00A432  1               LAB_FBA0
00A432  1  AE rr rr           LDX   ccnull            ; get countdown byte
00A435  1  F0 03              BEQ   LAB_FBA2          ; exit if finished
00A437  1               
00A437  1  CE rr rr           DEC   ccnull            ; else decrement countdown
00A43A  1               LAB_FBA2
00A43A  1               .ifndef NO_INT
00A43A  1                     LDX   #NmiBase          ; set pointer to NMI values
00A43A  1                     JSR   LAB_CKIN          ; go check interrupt
00A43A  1                     LDX   #IrqBase          ; set pointer to IRQ values
00A43A  1                     JSR   LAB_CKIN          ; go check interrupt
00A43A  1               .endif
00A43A  1               LAB_CRTS
00A43A  1  60                 RTS
00A43B  1               
00A43B  1               ; check whichever interrupt is indexed by X
00A43B  1               .ifndef NO_INT
00A43B  1               LAB_CKIN
00A43B  1                     LDA   PLUS_0,X          ; get interrupt flag byte
00A43B  1                     BPL   LAB_CRTS          ; branch if interrupt not enabled
00A43B  1               
00A43B  1               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
00A43B  1               ; automatically enable the interrupt when we exit
00A43B  1               
00A43B  1                     ASL                     ; move happened bit to setup bit
00A43B  1                     AND   #$40              ; mask happened bits
00A43B  1                     BEQ   LAB_CRTS          ; if no interrupt then exit
00A43B  1               
00A43B  1                     STA   PLUS_0,X          ; save interrupt flag byte
00A43B  1               
00A43B  1                     TXA                     ; copy index ..
00A43B  1                     TAY                     ; .. to Y
00A43B  1               
00A43B  1                     PLA                     ; dump return address low byte, call from CTRL-C
00A43B  1                     PLA                     ; dump return address high byte
00A43B  1               
00A43B  1                     LDA   #$05              ; need 5 bytes for GOSUB
00A43B  1                     JSR   LAB_1212          ; check room on stack for A bytes
00A43B  1                     LDA   Bpntrh            ; get BASIC execute pointer high byte
00A43B  1                     PHA                     ; push on stack
00A43B  1                     LDA   Bpntrl            ; get BASIC execute pointer low byte
00A43B  1                     PHA                     ; push on stack
00A43B  1                     LDA   Clineh            ; get current line high byte
00A43B  1                     PHA                     ; push on stack
00A43B  1                     LDA   Clinel            ; get current line low byte
00A43B  1                     PHA                     ; push on stack
00A43B  1                     LDA   #TK_GOSUB         ; token for GOSUB
00A43B  1                     PHA                     ; push on stack
00A43B  1               
00A43B  1                     LDA   PLUS_1,Y          ; get interrupt code pointer low byte
00A43B  1                     STA   Bpntrl            ; save as BASIC execute pointer low byte
00A43B  1                     LDA   PLUS_2,Y          ; get interrupt code pointer high byte
00A43B  1                     STA   Bpntrh            ; save as BASIC execute pointer high byte
00A43B  1               
00A43B  1                     JMP   LAB_15C2          ; go do interpreter inner loop
00A43B  1                                             ; can't RTS, we used the stack! the RTS from the ctrl-c
00A43B  1                                             ; check will be taken when the RETIRQ/RETNMI/RETURN is
00A43B  1                                             ; executed at the end of the subroutine
00A43B  1               .endif ; NO_INT
00A43B  1               
00A43B  1               ; get byte from input device, no waiting
00A43B  1               ; returns with carry set if byte in A
00A43B  1               
00A43B  1               INGET
00A43B  1  20 14 AF           JSR   V_INPT            ; call scan input device
00A43E  1  B0 09              BCS   LAB_FB95          ; if byte go reset timer
00A440  1               
00A440  1  AD rr rr           LDA   ccnull            ; get countdown
00A443  1  F0 09              BEQ   LAB_FB96          ; exit if empty
00A445  1               
00A445  1  AD rr rr           LDA   ccbyte            ; get last received byte
00A448  1  38                 SEC                     ; flag we got a byte
00A449  1               LAB_FB95
00A449  1  A2 00              LDX   #$00              ; clear X
00A44B  1  8E rr rr           STX   ccnull            ; clear timer because we got a byte
00A44E  1               LAB_FB96
00A44E  1  60                 RTS
00A44F  1               
00A44F  1               .ifndef NO_INT
00A44F  1               ; these routines only enable the interrupts if the set-up flag is set
00A44F  1               ; if not they have no effect
00A44F  1               
00A44F  1               ; perform IRQ {ON|OFF|CLEAR}
00A44F  1               
00A44F  1               LAB_IRQ
00A44F  1                     LDX   #IrqBase          ; set pointer to IRQ values
00A44F  1                     .byte $2C               ; make next line BIT abs.
00A44F  1               
00A44F  1               ; perform NMI {ON|OFF|CLEAR}
00A44F  1               
00A44F  1               LAB_NMI
00A44F  1                     LDX   #NmiBase          ; set pointer to NMI values
00A44F  1                     CMP   #TK_ON            ; compare with token for ON
00A44F  1                     BEQ   LAB_INON          ; go turn on interrupt
00A44F  1               
00A44F  1                     CMP   #TK_OFF           ; compare with token for OFF
00A44F  1                     BEQ   LAB_IOFF          ; go turn off interrupt
00A44F  1               
00A44F  1                     EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
00A44F  1                     BEQ   LAB_INEX          ; go clear interrupt flags and return
00A44F  1               
00A44F  1                     JMP   LAB_SNER          ; do syntax error then warm start
00A44F  1               
00A44F  1               LAB_IOFF
00A44F  1                     LDA   #$7F              ; clear A
00A44F  1                     AND   PLUS_0,X          ; AND with interrupt setup flag
00A44F  1                     BPL   LAB_INEX          ; go clear interrupt enabled flag and return
00A44F  1               
00A44F  1               LAB_INON
00A44F  1                     LDA   PLUS_0,X          ; get interrupt setup flag
00A44F  1                     ASL                     ; Shift bit to enabled flag
00A44F  1                     ORA   PLUS_0,X          ; OR with flag byte
00A44F  1               LAB_INEX
00A44F  1                     STA   PLUS_0,X          ; save interrupt flag byte
00A44F  1                     JMP   LAB_IGBY          ; update BASIC execute pointer and return
00A44F  1               
00A44F  1               ; these routines set up the pointers and flags for the interrupt routines
00A44F  1               ; note that the interrupts are also enabled by these commands
00A44F  1               
00A44F  1               ; perform ON IRQ
00A44F  1               
00A44F  1               LAB_SIRQ
00A44F  1                     CLI                     ; enable interrupts
00A44F  1                     LDX   #IrqBase          ; set pointer to IRQ values
00A44F  1                     .byte $2C               ; make next line BIT abs.
00A44F  1               
00A44F  1               ; perform ON NMI
00A44F  1               
00A44F  1               LAB_SNMI
00A44F  1                     LDX   #NmiBase          ; set pointer to NMI values
00A44F  1               
00A44F  1                     STX   TempB             ; save interrupt pointer
00A44F  1                     JSR   LAB_IGBY          ; increment and scan memory (past token)
00A44F  1                     JSR   LAB_GFPN          ; get fixed-point number into temp integer
00A44F  1                     LDA   Smeml             ; get start of mem low byte
00A44F  1                     LDX   Smemh             ; get start of mem high byte
00A44F  1                     JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00A44F  1                     BCS   LAB_LFND          ; if carry set go set-up interrupt
00A44F  1               
00A44F  1                     JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
00A44F  1               
00A44F  1               LAB_LFND
00A44F  1                     LDX   TempB             ; get interrupt pointer
00A44F  1                     LDA   Baslnl            ; get pointer low byte
00A44F  1                     SBC   #$01              ; -1 (carry already set for subtract)
00A44F  1                     STA   PLUS_1,X          ; save as interrupt pointer low byte
00A44F  1                     LDA   Baslnh            ; get pointer high byte
00A44F  1                     SBC   #$00              ; subtract carry
00A44F  1                     STA   PLUS_2,X          ; save as interrupt pointer high byte
00A44F  1               
00A44F  1                     LDA   #$C0              ; set interrupt enabled/setup bits
00A44F  1                     STA   PLUS_0,X          ; set interrupt flags
00A44F  1               LAB_IRTS
00A44F  1                     RTS
00A44F  1               
00A44F  1               ; return from IRQ service, restores the enabled flag.
00A44F  1               
00A44F  1               ; perform RETIRQ
00A44F  1               
00A44F  1               LAB_RETIRQ
00A44F  1                     BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
00A44F  1               
00A44F  1                     LDA   IrqBase           ; get interrupt flags
00A44F  1                     ASL                     ; copy setup to enabled (b7)
00A44F  1                     ORA   IrqBase           ; OR in setup flag
00A44F  1                     STA   IrqBase           ; save enabled flag
00A44F  1                     JMP   LAB_16E8          ; go do rest of RETURN
00A44F  1               
00A44F  1               ; return from NMI service, restores the enabled flag.
00A44F  1               
00A44F  1               ; perform RETNMI
00A44F  1               
00A44F  1               LAB_RETNMI
00A44F  1                     BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
00A44F  1               
00A44F  1                     LDA   NmiBase           ; get set-up flag
00A44F  1                     ASL                     ; copy setup to enabled (b7)
00A44F  1                     ORA   NmiBase           ; OR in setup flag
00A44F  1                     STA   NmiBase           ; save enabled flag
00A44F  1                     JMP   LAB_16E8          ; go do rest of RETURN
00A44F  1               .endif ; NO_INT
00A44F  1               
00A44F  1               ; MAX() MIN() pre process
00A44F  1               
00A44F  1               LAB_MMPP
00A44F  1  20 38 90           JSR   LAB_EVEZ          ; process expression
00A452  1  4C 1F 90           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
00A455  1               
00A455  1               ; perform MAX()
00A455  1               
00A455  1               LAB_MAX
00A455  1  20 83 A4           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
00A458  1                                             ; pull FAC2 and compare with FAC1
00A458  1  10 FB              BPL   LAB_MAX           ; branch if no swap to do
00A45A  1               
00A45A  1  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00A45C  1  09 80              ORA   #$80              ; set top bit (clear sign from compare)
00A45E  1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00A460  1  20 1E 9B           JSR   LAB_279B          ; copy FAC2 to FAC1
00A463  1  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
00A465  1               
00A465  1               ; perform MIN()
00A465  1               
00A465  1               LAB_MIN
00A465  1  20 83 A4           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
00A468  1                                             ; pull FAC2 and compare with FAC1
00A468  1  30 FB              BMI   LAB_MIN           ; branch if no swap to do
00A46A  1               
00A46A  1  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
00A46C  1               
00A46C  1  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00A46E  1  09 80              ORA   #$80              ; set top bit (clear sign from compare)
00A470  1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00A472  1  20 1E 9B           JSR   LAB_279B          ; copy FAC2 to FAC1
00A475  1  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
00A477  1               
00A477  1               ; exit routine. don't bother returning to the loop code
00A477  1               ; check for correct exit, else so syntax error
00A477  1               
00A477  1               LAB_MMEC
00A477  1  C9 29              CMP   #')'              ; is it end of function?
00A479  1  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
00A47B  1               
00A47B  1  68                 PLA                     ; dump return address low byte
00A47C  1  68                 PLA                     ; dump return address high byte
00A47D  1  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
00A480  1               
00A480  1               LAB_MMSE
00A480  1  4C 51 91           JMP   LAB_SNER          ; do syntax error then warm start
00A483  1               
00A483  1               ; check for next, evaluate and return or exit
00A483  1               ; this is the routine that does most of the work
00A483  1               
00A483  1               LAB_PHFA
00A483  1  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00A486  1  C9 2C              CMP   #','              ; is there more ?
00A488  1  D0 ED              BNE   LAB_MMEC          ; if not go do end check
00A48A  1               
00A48A  1                                             ; push FAC1
00A48A  1  20 34 9E           JSR   LAB_27BA          ; round FAC1
00A48D  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00A48F  1  09 7F              ORA   #$7F              ; set all non sign bits
00A491  1  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
00A493  1  48                 PHA                     ; push on stack
00A494  1  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00A496  1  48                 PHA                     ; push on stack
00A497  1  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00A499  1  48                 PHA                     ; push on stack
00A49A  1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00A49C  1  48                 PHA                     ; push on stack
00A49D  1               
00A49D  1  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
00A4A0  1  20 1C 90           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00A4A3  1                                             ; else do type mismatch
00A4A3  1               
00A4A3  1                                             ; pop FAC2 (MAX/MIN expression so far)
00A4A3  1  68                 PLA                     ; pop exponent
00A4A4  1  85 B3              STA   FAC2_e            ; save FAC2 exponent
00A4A6  1  68                 PLA                     ; pop mantissa3
00A4A7  1  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00A4A9  1  68                 PLA                     ; pop mantissa1
00A4AA  1  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00A4AC  1  68                 PLA                     ; pop sign/mantissa1
00A4AD  1  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
00A4AF  1  85 B7              STA   FAC2_s            ; save FAC2 sign
00A4B1  1               
00A4B1  1                                             ; compare FAC1 with (packed) FAC2
00A4B1  1  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
00A4B3  1  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
00A4B5  1  4C 72 9E           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
00A4B8  1                                             ; returns A=$00 if FAC1 = (AY)
00A4B8  1                                             ; returns A=$01 if FAC1 > (AY)
00A4B8  1                                             ; returns A=$FF if FAC1 < (AY)
00A4B8  1               
00A4B8  1               ; perform WIDTH
00A4B8  1               
00A4B8  1               LAB_WDTH
00A4B8  1  C9 2C              CMP   #','              ; is next byte ","
00A4BA  1  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
00A4BC  1               
00A4BC  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter
00A4BF  1  8A                 TXA                     ; copy width to A
00A4C0  1  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
00A4C2  1               
00A4C2  1  E0 10              CPX   #$10              ; else make min width = 16d
00A4C4  1  90 45              BCC   TabErr            ; if less do function call error and exit
00A4C6  1               
00A4C6  1               ; this next compare ensures that we can't exit WIDTH via an error leaving the
00A4C6  1               ; tab size greater than the line length.
00A4C6  1               
00A4C6  1  E4 64              CPX   TabSiz            ; compare with tab size
00A4C8  1  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
00A4CA  1               
00A4CA  1  86 64              STX   TabSiz            ; else make tab size = terminal width
00A4CC  1               LAB_NSTT
00A4CC  1  86 0F              STX   TWidth            ; set the terminal width
00A4CE  1  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
00A4D1  1  F0 1A              BEQ   WExit             ; exit if no following
00A4D3  1               
00A4D3  1  C9 2C              CMP   #','              ; else is it ","
00A4D5  1  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
00A4D7  1               
00A4D7  1               LAB_TBSZ
00A4D7  1  20 E4 99           JSR   LAB_SGBY          ; scan and get byte parameter
00A4DA  1  8A                 TXA                     ; copy TAB size
00A4DB  1  30 2E              BMI   TabErr            ; if >127 do function call error and exit
00A4DD  1               
00A4DD  1  E0 01              CPX   #$01              ; compare with min-1
00A4DF  1  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
00A4E1  1               
00A4E1  1  A5 0F              LDA   TWidth            ; set flags for width
00A4E3  1  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
00A4E5  1               
00A4E5  1  E4 0F              CPX   TWidth            ; compare TAB with width
00A4E7  1  F0 02              BEQ   LAB_SVTB          ; ok if =
00A4E9  1               
00A4E9  1  B0 20              BCS   TabErr            ; branch if too big
00A4EB  1               
00A4EB  1               LAB_SVTB
00A4EB  1  86 64              STX   TabSiz            ; save TAB size
00A4ED  1               
00A4ED  1               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00A4ED  1               ; position on a line that still has at least one whole tab width between it
00A4ED  1               ; and the end of the line.
00A4ED  1               
00A4ED  1               WExit
00A4ED  1  A5 0F              LDA   TWidth            ; get width
00A4EF  1  F0 06              BEQ   LAB_SULP          ; branch if infinite line
00A4F1  1               
00A4F1  1  C5 64              CMP   TabSiz            ; compare with tab size
00A4F3  1  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
00A4F5  1               
00A4F5  1  85 64              STA   TabSiz            ; else make tab size = terminal width
00A4F7  1               LAB_SULP
00A4F7  1  38                 SEC                     ; set carry for subtract
00A4F8  1               LAB_WDLP
00A4F8  1  E5 64              SBC   TabSiz            ; subtract tab size
00A4FA  1  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
00A4FC  1               
00A4FC  1  65 64              ADC   TabSiz            ; add tab size back
00A4FE  1  18                 CLC                     ; clear carry for add
00A4FF  1  65 64              ADC   TabSiz            ; add tab size back again
00A501  1  85 10              STA   Iclim             ; save for now
00A503  1  A5 0F              LDA   TWidth            ; get width back
00A505  1  38                 SEC                     ; set carry for subtract
00A506  1  E5 10              SBC   Iclim             ; subtract remainder
00A508  1  85 10              STA   Iclim             ; save tab column limit
00A50A  1               LAB_NOSQ
00A50A  1  60                 RTS
00A50B  1               
00A50B  1               TabErr
00A50B  1  4C 78 94           JMP   LAB_FCER          ; do function call error then warm start
00A50E  1               
00A50E  1               ; perform SQR()
00A50E  1               
00A50E  1               LAB_SQR
00A50E  1  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00A510  1  30 F9              BMI   TabErr            ; if -ve do function call error
00A512  1               
00A512  1  A5 AC              LDA   FAC1_e            ; get exponent
00A514  1  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
00A516  1               
00A516  1                                             ; else do root
00A516  1  20 25 9E           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00A519  1  A9 00              LDA   #$00              ; clear A
00A51B  1               
00A51B  1  85 77              STA   FACt_3            ; clear remainder
00A51D  1  85 76              STA   FACt_2            ; ..
00A51F  1  85 75              STA   FACt_1            ; ..
00A521  1  85 78              STA   TempB             ; ..
00A523  1               
00A523  1  85 AF              STA   FAC1_3            ; clear root
00A525  1  85 AE              STA   FAC1_2            ; ..
00A527  1  85 AD              STA   FAC1_1            ; ..
00A529  1               
00A529  1  A2 18              LDX   #$18              ; 24 pairs of bits to do
00A52B  1  A5 B3              LDA   FAC2_e            ; get exponent
00A52D  1  4A                 LSR                     ; check odd/even
00A52E  1  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
00A530  1               
00A530  1               LAB_SQE1
00A530  1  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00A532  1  26 B5              ROL   FAC2_2            ; ..
00A534  1  26 B4              ROL   FAC2_1            ; ..
00A536  1  26 77              ROL   FACt_3            ; .. into remainder
00A538  1  26 76              ROL   FACt_2            ; ..
00A53A  1  26 75              ROL   FACt_1            ; ..
00A53C  1  26 78              ROL   TempB             ; .. never overflows
00A53E  1               LAB_SQE2
00A53E  1  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00A540  1  26 B5              ROL   FAC2_2            ; ..
00A542  1  26 B4              ROL   FAC2_1            ; ..
00A544  1  26 77              ROL   FACt_3            ; .. into remainder
00A546  1  26 76              ROL   FACt_2            ; ..
00A548  1  26 75              ROL   FACt_1            ; ..
00A54A  1  26 78              ROL   TempB             ; .. never overflows
00A54C  1               
00A54C  1  06 AF              ASL   FAC1_3            ; root = root * 2
00A54E  1  26 AE              ROL   FAC1_2            ; ..
00A550  1  26 AD              ROL   FAC1_1            ; .. never overflows
00A552  1               
00A552  1  A5 AF              LDA   FAC1_3            ; get root low byte
00A554  1  2A                 ROL                     ; *2
00A555  1  85 5B              STA   Temp3             ; save partial low byte
00A557  1  A5 AE              LDA   FAC1_2            ; get root low mid byte
00A559  1  2A                 ROL                     ; *2
00A55A  1  85 5C              STA   Temp3+1           ; save partial low mid byte
00A55C  1  A5 AD              LDA   FAC1_1            ; get root high mid byte
00A55E  1  2A                 ROL                     ; *2
00A55F  1  85 5D              STA   Temp3+2           ; save partial high mid byte
00A561  1  A9 00              LDA   #$00              ; get root high byte (always $00)
00A563  1  2A                 ROL                     ; *2
00A564  1  85 5E              STA   Temp3+3           ; save partial high byte
00A566  1               
00A566  1                                             ; carry clear for subtract +1
00A566  1  A5 77              LDA   FACt_3            ; get remainder low byte
00A568  1  E5 5B              SBC   Temp3             ; subtract partial low byte
00A56A  1  85 5B              STA   Temp3             ; save partial low byte
00A56C  1               
00A56C  1  A5 76              LDA   FACt_2            ; get remainder low mid byte
00A56E  1  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
00A570  1  85 5C              STA   Temp3+1           ; save partial low mid byte
00A572  1               
00A572  1  A5 75              LDA   FACt_1            ; get remainder high mid byte
00A574  1  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
00A576  1  A8                 TAY                     ; copy partial high mid byte
00A577  1               
00A577  1  A5 78              LDA   TempB             ; get remainder high byte
00A579  1  E5 5E              SBC   Temp3+3           ; subtract partial high byte
00A57B  1  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
00A57D  1               
00A57D  1  85 78              STA   TempB             ; save remainder high byte
00A57F  1               
00A57F  1  84 75              STY   FACt_1            ; save remainder high mid byte
00A581  1               
00A581  1  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
00A583  1  85 76              STA   FACt_2            ; save remainder low mid byte
00A585  1               
00A585  1  A5 5B              LDA   Temp3             ; get partial low byte
00A587  1  85 77              STA   FACt_3            ; save remainder low byte
00A589  1               
00A589  1  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
00A58B  1               LAB_SQNS
00A58B  1  CA                 DEX                     ; decrement bit pair count
00A58C  1  D0 A2              BNE   LAB_SQE1          ; loop if not all done
00A58E  1               
00A58E  1  38                 SEC                     ; set carry for subtract
00A58F  1  A5 B3              LDA   FAC2_e            ; get exponent
00A591  1  E9 80              SBC   #$80              ; normalise
00A593  1  6A                 ROR                     ; /2 and re-bias to $80
00A594  1  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
00A596  1  85 AC              STA   FAC1_e            ; save it
00A598  1  4C 8F 9B           JMP   LAB_24D5          ; normalise FAC1 and return
00A59B  1               
00A59B  1               ; perform VARPTR()
00A59B  1               
00A59B  1               LAB_VARPTR
00A59B  1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00A59E  1  20 F9 92           JSR   LAB_GVAR          ; get var address
00A5A1  1  20 3E 91           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00A5A4  1  A4 95              LDY   Cvaral            ; get var address low byte
00A5A6  1  A5 96              LDA   Cvarah            ; get var address high byte
00A5A8  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00A5AB  1               
00A5AB  1               ; perform PI
00A5AB  1               
00A5AB  1               LAB_PI
00A5AB  1  A9 0D              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00A5AD  1  A0 B4              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00A5AF  1  20 D8 9D           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00A5B2  1  C6 AC              DEC   FAC1_e            ; make result = PI
00A5B4  1  60                 RTS
00A5B5  1               
00A5B5  1               ; perform TWOPI
00A5B5  1               
00A5B5  1               LAB_TWOPI
00A5B5  1  A9 0D              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00A5B7  1  A0 B4              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00A5B9  1  4C D8 9D           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
00A5BC  1               
00A5BC  1               .ifdef APPLE2
00A5BC  1               ; Apple II Additional Command implementation and supporting routines
00A5BC  1               LAB_HOME
00A5BC  1  A9 0C              LDA   #$0C              ; CTRL-L
00A5BE  1  4C 58 AF           JMP   V_OUTP            ; clear screen
00A5C1  1               
00A5C1  1               LAB_BYE
00A5C1  1  20 00 BF           JSR   P8_MLI
00A5C4  1  65                 .byte $65               ; QUIT code
00A5C5  1  C8 A5              .addr BYEPARMS
00A5C7  1  00                 BRK
00A5C8  1               BYEPARMS
00A5C8  1  04                 .byte 4
00A5C9  1  00                 .byte 0
00A5CA  1  00 00              .addr 0
00A5CC  1  00                 .byte 0
00A5CD  1  00 00              .addr 0
00A5CF  1               
00A5CF  1               ; *************************************
00A5CF  1               ; Screen and Graphics Commands
00A5CF  1               ; *************************************
00A5CF  1               
00A5CF  1               ; ZP_SCREEN = %00000000                   For Applesoft compatibility
00A5CF  1               ;           =        00 = Full page 1     "HGR0","TEXT0",etc.
00A5CF  1               ;           =        01 = Mixed page 1    "HGR1",etc. default
00A5CF  1               ;           =        10 = Full page 2     "HGR2",etc.
00A5CF  1               ;           =        11 = Mixed Page 2    "HGR3"
00A5CF  1               ;           =      00   = Text
00A5CF  1               ;           =      01   = Low Res
00A5CF  1               ;           =      10   = Hi res
00A5CF  1               ;           =      11   = Dbl Hires (unsupported in 64K version)
00A5CF  1               ;           =     100   = Super Hires (unsupported at all for now)
00A5CF  1               ; So:  0 = Text Page 1,         1 = Text Page 1 (since the mixed switch
00A5CF  1               ;      2 = Text Page 2,         3 = Text Page 2  has no meaning)
00A5CF  1               ;      4 = Lo-res page 1 full,  5 = Lo-res page 1 mixed
00A5CF  1               ;      6 = Lo-res page 2 full,  7 = Lo-res page 2 mixed
00A5CF  1               ;      8 = Hi-res page 1 full,  9 = Hi-res page 1 mixed
00A5CF  1               ;     10 = Hi-res page 2 full, 11 = Hi-res page 2 mixed
00A5CF  1               
00A5CF  1               LAB_CLS
00A5CF  1  A5 E3              LDA   ZP_SCREEN
00A5D1  1  29 0C              AND   #%1100
00A5D3  1  4A                 LSR
00A5D4  1  AA                 TAX
00A5D5  1  7C D8 A5           JMP   (CLSTAB,X)
00A5D8  1               CLSTAB:
00A5D8  1  BC A5              .addr LAB_HOME
00A5DA  1  32 F8              .addr F8_CLRSCR
00A5DC  1  F6 F3              .addr F0_BKGND
00A5DE  1  32 85              .addr LAB_XCER
00A5E0  1               
00A5E0  1               ; SCREEN mode[,flag] - display a text or graphics screen
00A5E0  1               ; See modes table above.  If flag is present, sets which page is
00A5E0  1               ; used for hi-res commands, 1 or 2
00A5E0  1               LAB_SCREEN
00A5E0  1  20 8B 8C           JSR   LAB_GFPN
00A5E3  1  A5 11              LDA   Itempl
00A5E5  1  C9 0C              CMP   #12
00A5E7  1  90 03              BCC   :+
00A5E9  1  4C 9E A6           JMP   LAB_IAER
00A5EC  1  85 E3        :     STA   ZP_SCREEN
00A5EE  1  29 0C              AND   #%1100
00A5F0  1  4A                 LSR
00A5F1  1  AA                 TAX
00A5F2  1  7C F5 A5           JMP   (SCRTAB,X)
00A5F5  1               SCRTAB:
00A5F5  1  FB A5              .addr LAB_SCREEN_00_03
00A5F7  1  00 A6              .addr LAB_SCREEN_04_07
00A5F9  1  08 A6              .addr LAB_SCREEN_08_11
00A5FB  1               ;     .addr LAB_XCER          ; not needed for now
00A5FB  1               LAB_SCREEN_00_03
00A5FB  1  2C 51 C0           BIT   TXTSET
00A5FE  1  80 4A              BRA   LAB_SCREEN2
00A600  1               LAB_SCREEN_04_07
00A600  1  2C 50 C0           BIT   TXTCLR
00A603  1  2C 56 C0           BIT   LORES
00A606  1  80 42              BRA   LAB_SCREEN2
00A608  1               LAB_SCREEN_08_11
00A608  1  2C 50 C0           BIT   TXTCLR
00A60B  1  2C 57 C0           BIT   HIRES
00A60E  1  20 13 A6           JSR   LAB_HGR_DRAWSCRN_GET
00A611  1  80 37              BRA   LAB_SCREEN2
00A613  1               
00A613  1               ; set HGR drawing page by BASIC statement ,X
00A613  1               ; if not specified, set to whatever is in ZP_SCREEN
00A613  1               LAB_HGR_DRAWSCRN_GET
00A613  1  20 C2 00           JSR   LAB_GBYT
00A616  1  C9 2C              CMP   #','
00A618  1  F0 09              BEQ   :+
00A61A  1  A5 E3              LDA   ZP_SCREEN
00A61C  1  4A                 LSR
00A61D  1  29 01              AND   #$01
00A61F  1  AA                 TAX
00A620  1  E8                 INX
00A621  1  80 06              BRA   LAB_HGR_DRAWSCRN
00A623  1  20 BC 00     :     JSR   LAB_IGBY          ; skip comma
00A626  1  20 E7 99           JSR   LAB_GTBY          ; get arg in X
00A629  1               LAB_HGR_DRAWSCRN              ; set HGR drawing page by number in X
00A629  1  A9 20              LDA   #$20              ; anticipate page 1
00A62B  1  E0 02              CPX   #$02
00A62D  1  90 01              BCC   :+                ; 0 or 1 gets us page 1, 2+ page 2
00A62F  1  0A                 ASL
00A630  1  85 E6        :     STA   ZP_HGRPAGE
00A632  1  60                 RTS
00A633  1               
00A633  1               
00A633  1               LAB_SMODE_GET
00A633  1  F0 08              BEQ   :+
00A635  1  20 8B 8C           JSR   LAB_GFPN
00A638  1  A5 11              LDA   Itempl
00A63A  1  29 03              AND   #$03
00A63C  1  2C                 .byte $2c               ; BIT Abs
00A63D  1  A9 01        :     LDA   #$01              ; Default = TEXT1, GR1, HGR1 etc.
00A63F  1  60                 RTS
00A640  1               
00A640  1               LAB_GR
00A640  1  20 33 A6           JSR   LAB_SMODE_GET
00A643  1  09 04              ORA   #%0100
00A645  1  85 E3              STA   ZP_SCREEN
00A647  1  20 90 F3           JSR   F0_GR
00A64A  1               LAB_SCREEN2
00A64A  1  A5 E3              LDA   ZP_SCREEN
00A64C  1  29 03              AND   #$03
00A64E  1  4A                 LSR
00A64F  1  A8                 TAY
00A650  1  A9 00              LDA   #$00
00A652  1  2A                 ROL
00A653  1  AA                 TAX
00A654  1  BD 52 C0           LDA   MIXCLR,X
00A657  1  B9 54 C0           LDA   TXTPAGE1,Y
00A65A  1  60                 RTS
00A65B  1               
00A65B  1               LAB_TEXT
00A65B  1  20 33 A6           JSR   LAB_SMODE_GET
00A65E  1  85 E3              STA   ZP_SCREEN
00A660  1  20 99 F3           JSR   F0_TEXT
00A663  1  80 E5              BRA   LAB_SCREEN2
00A665  1               
00A665  1               LAB_HGR
00A665  1  20 33 A6           JSR   LAB_SMODE_GET
00A668  1  09 08              ORA   #%1000
00A66A  1  85 E3              STA   ZP_SCREEN
00A66C  1  4A                 LSR
00A66D  1  4A                 LSR
00A66E  1  B0 05              BCS   :+                ; to HGR2
00A670  1  20 E2 F3           JSR   F0_HGR
00A673  1  80 03              BRA   :++
00A675  1  20 D8 F3     :     JSR   F0_HGR2
00A678  1  80 D0        :     BRA   LAB_SCREEN2
00A67A  1               
00A67A  1               LAB_COLOR
00A67A  1  20 8B 8C           JSR   LAB_GFPN
00A67D  1  A5 11              LDA   Itempl
00A67F  1  29 0F              AND   #$0F
00A681  1  85 30              STA   ZP_COLOR
00A683  1  0A                 ASL
00A684  1  0A                 ASL
00A685  1  0A                 ASL
00A686  1  0A                 ASL
00A687  1  05 30              ORA   ZP_COLOR
00A689  1  85 30              STA   ZP_COLOR
00A68B  1  60                 RTS
00A68C  1               
00A68C  1               ; Scan for CHR$(A) or comma, else syntax error and warm start
00A68C  1               LAB_COMMA_OR_A
00A68C  1  A0 00              LDY   #$00
00A68E  1  D1 C3              CMP   (Bpntrl),Y
00A690  1  F0 09              BEQ   :+
00A692  1  A9 2C              LDA   #','
00A694  1  D1 C3              CMP   (Bpntrl),Y
00A696  1  F0 03              BEQ   :+
00A698  1  4C 51 91           JMP   LAB_SNER
00A69B  1  4C BC 00     :     JMP   LAB_IGBY
00A69E  1               
00A69E  1               LAB_IAER
00A69E  1  A2 2A              LDX   #$2A
00A6A0  1  4C 38 85           JMP   LAB_XERR
00A6A3  1               
00A6A3  1               LAB_GET_LORES_XY              ; get X,Y pair into Y,A
00A6A3  1  20 33 9A           JSR   LAB_GADB          ; X=2nd arg 0-255, Itempl,Itemph = 1st arg
00A6A6  1  E0 30              CPX   #48
00A6A8  1  B0 F4              BCS   LAB_IAER
00A6AA  1  8A                 TXA
00A6AB  1  A4 11              LDY   Itempl
00A6AD  1  C0 28              CPY   #40
00A6AF  1  B0 ED              BCS   LAB_IAER
00A6B1  1  60                 RTS
00A6B2  1               
00A6B2  1               LAB_GET_LORES_3ARG            ; "M1,M2 AT N" = A,Y AT X
00A6B2  1  20 33 9A           JSR   LAB_GADB
00A6B5  1  DA                 PHX                     ; push M2
00A6B6  1  A5 11              LDA   Itempl
00A6B8  1  48                 PHA                     ; push M1
00A6B9  1  A9 C1              LDA   #TK_AT
00A6BB  1  20 8C A6           JSR   LAB_COMMA_OR_A    ; allow "M1,M2,N" or standard syntax
00A6BE  1  20 E7 99           JSR   LAB_GTBY          ; get N (a byte) in X
00A6C1  1  68                 PLA                     ; M1 in A
00A6C2  1  7A                 PLY                     ; M2 in Y
00A6C3  1  60                 RTS
00A6C4  1               
00A6C4  1               LAB_PLOT_NEXT
00A6C4  1  20 BC 00           JSR   LAB_IGBY          ; skip comma and get next byte
00A6C7  1               LAB_PLOT
00A6C7  1  20 A3 A6           JSR   LAB_GET_LORES_XY
00A6CA  1  20 00 F8           JSR   F8_PLOT
00A6CD  1  20 C2 00           JSR   LAB_GBYT
00A6D0  1  C9 2C              CMP   #','              ; extended syntax, more X,Y pairs
00A6D2  1  F0 F0              BEQ   LAB_PLOT_NEXT
00A6D4  1  60                 RTS
00A6D5  1               
00A6D5  1               
00A6D5  1               LAB_HLIN
00A6D5  1  20 B2 A6           JSR   LAB_GET_LORES_3ARG  ; "A,Y at X" = H1,H2 at V
00A6D8  1  C9 28              CMP   #40
00A6DA  1  B0 C2              BCS   LAB_IAER
00A6DC  1  C0 28              CPY   #40
00A6DE  1  B0 BE              BCS   LAB_IAER
00A6E0  1  E0 30              CPX   #48
00A6E2  1  B0 BA              BCS   LAB_IAER
00A6E4  1  84 2C              STY   ZP_H2             ; ending column to H2
00A6E6  1  A8                 TAY
00A6E7  1  8A                 TXA
00A6E8  1  4C 19 F8           JMP   F8_HLINE          ; plot from (Y=H1,A=V) to (H2,A=V)
00A6EB  1               
00A6EB  1               LAB_VLIN
00A6EB  1  20 B2 A6           JSR   LAB_GET_LORES_3ARG  ; "A,Y at X" = V1,V2 at H
00A6EE  1  C9 30              CMP   #48
00A6F0  1  B0 AC              BCS   LAB_IAER
00A6F2  1  C0 30              CPY   #48
00A6F4  1  B0 A8              BCS   LAB_IAER
00A6F6  1  E0 28              CPX   #40
00A6F8  1  B0 A4              BCS   LAB_IAER
00A6FA  1  84 2D              STY   ZP_V2             ; ending row to V2
00A6FC  1  DA                 PHX
00A6FD  1  7A                 PLY
00A6FE  1  4C 28 F8           JMP   F8_VLINE          ; plot from (Y=H,A=V1) to (Y=H,V2)
00A701  1               
00A701  1               LAB_HCOLOR
00A701  1  20 E7 99           JSR   LAB_GTBY          ; get byte arg in x
00A704  1  E0 08              CPX   #8
00A706  1  B0 96              BCS   LAB_IAER
00A708  1  BD 0E A7           LDA   HCOLORTAB,X
00A70B  1  85 E4              STA   ZP_HCOLOR
00A70D  1  60                 RTS
00A70E  1               HCOLORTAB
00A70E  1  00 2A 55 7F        .byte $00,$2A,$55,$7F,$80,$AA,$D5,$FF
00A712  1  80 AA D5 FF  
00A716  1               
00A716  1               ; This is annoyingly complicated and slowed by the fact that the Applesoft ROM
00A716  1               ; hi-res line routines overwrite the end of the EhBASIC IGBY/GBYT routine
00A716  1               LAB_HPLOT_NEXT
00A716  1  20 C2 00           JSR   LAB_GBYT          ; get current program stream byte
00A719  1  D0 01              BNE   :++
00A71B  1  60           :     RTS
00A71C  1  C9 3A        :     CMP   #':'
00A71E  1  F0 FB              BEQ   :--
00A720  1               LAB_HPLOT
00A720  1  C9 B8              CMP   #TK_TO
00A722  1  F0 18              BEQ   LAB_HGLINE
00A724  1  C9 81              CMP   #TK_FOR           ; relative
00A726  1  F0 1C              BEQ   LAB_HGLINE_REL
00A728  1  C9 2C              CMP   #','
00A72A  1  D0 03              BNE   LAB_HPLOT1
00A72C  1  20 BC 00           JSR   LAB_IGBY          ; another coord pair, skip comma
00A72F  1               LAB_HPLOT1
00A72F  1  20 33 9A           JSR   LAB_GADB          ; do HPLOT, X=Arg 2, Itempl,Itemph = Arg 1
00A732  1  8A                 TXA
00A733  1  A6 11              LDX   Itempl
00A735  1  A4 12              LDY   Itemph
00A737  1  20 57 F4           JSR   F0_HPLOT0
00A73A  1  80 DA              BRA   LAB_HPLOT_NEXT
00A73C  1               LAB_HGLINE
00A73C  1  20 58 A7           JSR   LAB_HGLINE_PARMS
00A73F  1  20 3A F5           JSR   F0_HGLIN          ; wrecks ZP $D0-$D5, need to fixup
00A742  1  80 06              BRA   LAB_HGLINE_FIXUP
00A744  1               LAB_HGLINE_REL                ; doesn't work as advertised
00A744  1  20 58 A7           JSR   LAB_HGLINE_PARMS
00A747  1  20 30 F5           JSR   F0_HLINRL
00A74A  1               LAB_HGLINE_FIXUP
00A74A  1  A2 1C              LDX   #StrTab-LAB_2CEE
00A74C  1  BD 62 B3     :     LDA   LAB_2CEE-1,X      ; get byte from table
00A74F  1  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00A751  1  CA                 DEX                     ; decrement count
00A752  1  E0 14              CPX   #StrTab-LAB_2CEE-8 ; fix last 8 bytes
00A754  1  D0 F6              BNE   :-
00A756  1  80 BE              BRA   LAB_HPLOT_NEXT
00A758  1               LAB_HGLINE_PARMS
00A758  1  20 BC 00           JSR   LAB_IGBY          ; skip TO or FOR
00A75B  1  20 33 9A           JSR   LAB_GADB          ; X=Arg 2, Itempl,Itemph = Arg 1
00A75E  1  8A                 TXA
00A75F  1  A8                 TAY
00A760  1  A6 12              LDX   Itemph
00A762  1  A5 11              LDA   Itempl
00A764  1  60                 RTS
00A765  1               
00A765  1               ; *************************************
00A765  1               ; Sound, Text, and Joystick
00A765  1               ; *************************************
00A765  1               LAB_PDL
00A765  1  20 4C 9A           JSR   LAB_F2FX          ; convert FAC1 to integer in Itempl/h
00A768  1  A6 11              LDX   Itempl
00A76A  1  20 1E FB           JSR   F8_PREAD          ; returns value to Y reg
00A76D  1  4C C1 95           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00A770  1               
00A770  1               LAB_BTN
00A770  1  20 4C 9A           JSR   LAB_F2FX
00A773  1  A5 11              LDA   Itempl
00A775  1  1A                 INC   A                 ; Because button 0=$C061
00A776  1  29 03              AND   #%00000011        ; also IIc 80/40 sw at $C060, allow BUTN(3)
00A778  1  AA                 TAX
00A779  1  A9 00              LDA   #$00              ; anticipate not pressed
00A77B  1  3C 60 C0           BIT   BUTN3,X
00A77E  1  30 03              BMI   :++
00A780  1  4C 55 9E     :     JMP   LAB_27DB          ; sign extend A and return as integer
00A783  1  A9 FF        :     LDA   #$FF
00A785  1  80 F9              BRA   :--
00A787  1               
00A787  1               LAB_BEEP
00A787  1  D0 03              BNE   :+
00A789  1  4C DD FB           JMP   F8_BELL1
00A78C  1  20 E7 99     :     JSR   LAB_GTBY          ; get N (a byte) in X
00A78F  1  DA                 PHX
00A790  1  A9 81              LDA   #TK_FOR           ; allow BEEP m FOR n or BEEP m,n
00A792  1  20 8C A6           JSR   LAB_COMMA_OR_A
00A795  1  20 E7 99           JSR   LAB_GTBY          ; X has duration, overwrites FAC2 (hence OSptr)
00A798  1  7A                 PLY
00A799  1  84 B4              STY   OSptr
00A79B  1  A4 B4        :     LDY   OSptr
00A79D  1  AD 30 C0           LDA   SPKR
00A7A0  1  A9 05        :     LDA   #$05
00A7A2  1  3A           :     DEC   A
00A7A3  1  D0 FD              BNE   :-
00A7A5  1  88                 DEY
00A7A6  1  D0 F8              BNE   :--
00A7A8  1  CA                 DEX
00A7A9  1  D0 F0              BNE   :---
00A7AB  1  60                 RTS
00A7AC  1               
00A7AC  1               LAB_INVERSE
00A7AC  1  A9 0F              LDA   #$0F
00A7AE  1  2C                 .byte $2C               ; BIT ABS
00A7AF  1               LAB_NORMAL
00A7AF  1  A9 0E              LDA   #$0E
00A7B1  1  20 32 8E           JSR   LAB_PRNA          ; send to video
00A7B4  1  60                 RTS
00A7B5  1               
00A7B5  1               LAB_MTEXT
00A7B5  1  48                 PHA
00A7B6  1  20 BC 00           JSR   LAB_IGBY
00A7B9  1  68                 PLA
00A7BA  1  C9 91              CMP   #TK_ON
00A7BC  1  F0 0A              BEQ   LAB_MTON
00A7BE  1  C9 C0              CMP   #TK_OFF
00A7C0  1  F0 03              BEQ   LAB_MTOFF
00A7C2  1  4C 51 91           JMP   LAB_SNER
00A7C5  1               LAB_MTOFF
00A7C5  1  A9 18              LDA   #24
00A7C7  1  2C                 .byte $2C               ; BIT abs
00A7C8  1               LAB_MTON
00A7C8  1  A9 1B              LDA   #27
00A7CA  1  20 32 8E           JSR   LAB_PRNA          ; preserves a
00A7CD  1  4A                 LSR                     ; of the two values, one is even, the other odd
00A7CE  1  B0 DC              BCS   LAB_INVERSE       ; the even one is on
00A7D0  1  90 DD              BCC   LAB_NORMAL        ; the odd one is off
00A7D2  1               
00A7D2  1               ; *************************************
00A7D2  1               ; Standard I/O (IN#/PR#)
00A7D2  1               ; *************************************
00A7D2  1               ; TODO: allow files in addition to slots
00A7D2  1               
00A7D2  1               ; get slot number in X from the form <#>[!]
00A7D2  1               ; if ! is present, forces device to be re-initialized
00A7D2  1               ; if devices is a $8x type, set last text slot to the number
00A7D2  1               ; and force re-init
00A7D2  1               LAB_GETSLNUM
00A7D2  1  20 E7 99           JSR   LAB_GTBY          ; get byte in X
00A7D5  1  E0 08              CPX   #$08
00A7D7  1  B0 6E              BCS   LAB_IAER2
00A7D9  1  20 C2 00           JSR   LAB_GBYT          ; next token in run stream
00A7DC  1  C9 21              CMP   #'!'              ; is bang?
00A7DE  1  D0 06              BNE   :+
00A7E0  1  20 BC 00           JSR   LAB_IGBY          ; skip bang
00A7E3  1  9E rr rr           STZ   SLOT_STATUS,X     ; force reinit (assuming device there)
00A7E6  1  BD rr rr     :     LDA   SLOT_TYPES,X
00A7E9  1  F0 57              BEQ   LAB_NDER
00A7EB  1  29 F0              AND   #$F0
00A7ED  1  C9 80              CMP   #$80              ; is text display?
00A7EF  1  D0 06              BNE   :+                ; no force reinit if not
00A7F1  1  8E rr rr           STX   IO_TEXT_SLOT
00A7F4  1  9E rr rr           STZ   SLOT_STATUS,X
00A7F7  1  60           :     RTS
00A7F8  1               
00A7F8  1               LAB_PRNUM
00A7F8  1  20 D2 A7           JSR   LAB_GETSLNUM
00A7FB  1               LAB_PRNUM_BOTH
00A7FB  1  8A                 TXA
00A7FC  1  DA                 PHX
00A7FD  1  20 BA AF           JSR   DO_VEC_SETOSLOT
00A800  1                     ; JSR   DO_VEC_PINIT
00A800  1  FA                 PLX
00A801  1  EC rr rr           CPX   IO_TEXT_SLOT
00A804  1  D0 16              BNE   :+
00A806  1  AD rr rr           LDA   IO_SLOT_IN
00A809  1  CD rr rr           CMP   IO_SLOT_OUT
00A80C  1  F0 0E              BEQ   :+                ; slots are same, nothing to do
00A80E  1  4A                 LSR
00A80F  1  4A                 LSR
00A810  1  4A                 LSR
00A811  1  4A                 LSR
00A812  1  A8                 TAY
00A813  1  B9 rr rr           LDA   SLOT_TYPES,Y      ; get input slot type
00A816  1  29 F0              AND   #$F0
00A818  1  C9 80              CMP   #$80              ; text display?
00A81A  1  F0 04              BEQ   LAB_INNUM_BOTH    ; also force input
00A81C  1  60           :     RTS
00A81D  1               
00A81D  1               LAB_INNUM
00A81D  1  20 D2 A7           JSR   LAB_GETSLNUM
00A820  1               LAB_INNUM_BOTH
00A820  1  8A                 TXA
00A821  1  DA                 PHX
00A822  1  20 83 AF           JSR   DO_VEC_SETISLOT
00A825  1                     ; JSR   DO_VEC_PINIT
00A825  1  FA                 PLX
00A826  1  EC rr rr           CPX   IO_TEXT_SLOT
00A829  1  D0 16              BNE   :+
00A82B  1  AD rr rr           LDA   IO_SLOT_OUT
00A82E  1  CD rr rr           CMP   IO_SLOT_IN
00A831  1  F0 0E              BEQ   :+                ; slots are same, nothing to do
00A833  1  4A                 LSR
00A834  1  4A                 LSR
00A835  1  4A                 LSR
00A836  1  4A                 LSR
00A837  1  A8                 TAY
00A838  1  B9 rr rr           LDA   SLOT_TYPES,Y      ; get output slot type
00A83B  1  29 F0              AND   #$F0
00A83D  1  C9 80              CMP   #$80              ; text display?
00A83F  1  F0 BA              BEQ   LAB_PRNUM_BOTH    ; Yep, also set output
00A841  1  60           :     RTS
00A842  1               
00A842  1               LAB_NDER
00A842  1  A2 2E              LDX   #$2E
00A844  1  4C 38 85           JMP   LAB_XERR
00A847  1               LAB_IAER2
00A847  1  4C 9E A6           JMP   LAB_IAER
00A84A  1               
00A84A  1               ; *************************************
00A84A  1               ; Pascal <-> BASIC String Conversion
00A84A  1               ; *************************************
00A84A  1               
00A84A  1               ; P2B$(string or addr, mask, shift)
00A84A  1               LAB_P2BS
00A84A  1  20 BC 00           JSR   LAB_IGBY          ; scan run stream
00A84D  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
00A850  1  24 5F              BIT   Dtypef
00A852  1  30 05              BMI   P2BS_STR
00A854  1  20 4C 9A           JSR   LAB_F2FX          ; numeric -> integer at Itempl,Itemph
00A857  1  80 07              BRA   :+
00A859  1               P2BS_STR
00A859  1  20 97 98           JSR   LAB_EVST          ; YX=ptr, A=length
00A85C  1  84 12              STY   Itemph
00A85E  1  86 11              STX   Itempl
00A860  1  A0 00        :     LDY   #$00
00A862  1  B1 11              LDA   (Itempl),y        ; get length of pascal str
00A864  1  48                 PHA                     ; save it
00A865  1  E6 11              INC   Itempl            ; and skip past
00A867  1  D0 02              BNE   :+
00A869  1  E6 12              INC   Itemph
00A86B  1  20 C2 00     :     JSR   LAB_GBYT          ; get next byte
00A86E  1  C9 29              CMP   #')'
00A870  1  F0 21              BEQ   P2BS_COPY
00A872  1  20 4D 91           JSR   LAB_1C01          ; comma or syntax error
00A875  1  20 E7 99           JSR   LAB_GTBY          ; get byte param in x (mask)
00A878  1  86 5B              STX   Temp3             ; save mask
00A87A  1  68                 PLA                     ; get length back
00A87B  1  25 5B              AND   Temp3             ; mask it
00A87D  1  48                 PHA                     ; and save it back to stack
00A87E  1  20 C2 00           JSR   LAB_GBYT
00A881  1  C9 29              CMP   #')'
00A883  1  F0 0E              BEQ   P2BS_COPY
00A885  1  20 4D 91           JSR   LAB_1C01
00A888  1  20 E7 99           JSR   LAB_GTBY          ; get byte param in x (shift)
00A88B  1  68                 PLA
00A88C  1  CA           :     DEX                     ; shift loop
00A88D  1  30 03              BMI   :+
00A88F  1  4A                 LSR
00A890  1  D0 FA              BNE   :-
00A892  1  48           :     PHA
00A893  1               P2BS_COPY
00A893  1  20 C2 00           JSR LAB_GBYT
00A896  1  C9 29              CMP   #')'
00A898  1  F0 03              BEQ   :+
00A89A  1               P2BS_SNER
00A89A  1  4C 51 91           JMP   LAB_SNER
00A89D  1  20 BC 00     :     JSR   LAB_IGBY          ; skip ')'
00A8A0  1  68                 PLA
00A8A1  1  20 95 96           JSR   LAB_MSSP          ; make string space A bytes long, ptr in sutill/h
00A8A4  1  A4 12              LDY   Itemph
00A8A6  1  A6 11              LDX   Itempl
00A8A8  1  20 7B 98           JSR   LAB_2298          ; copy A bytes from YX to (Sutill)
00A8AB  1  4C E1 96           JMP   LAB_RTST          ; return the string
00A8AE  1               
00A8AE  1               ; B2P$(string, shift, or)
00A8AE  1               LAB_B2PS
00A8AE  1  20 BC 00           JSR   LAB_IGBY          ; scan run stream
00A8B1  1  20 30 90           JSR   LAB_EVEX          ; evaluate expression
00A8B4  1  20 97 98           JSR   LAB_EVST          ; YX=ptr, A=length
00A8B7  1  48                 PHA                     ; save len
00A8B8  1  CA                 DEX
00A8B9  1  D0 01              BNE   :+
00A8BB  1  88                 DEY
00A8BC  1  84 12        :     STY   Itemph            ; save src - 1 for now
00A8BE  1  86 11              STX   Itempl
00A8C0  1  1A                 INC   A                 ; destination length + 1
00A8C1  1  D0 05              BNE   :+                ; if not too long
00A8C3  1  A2 1C              LDX   #$1C              ; otherwise string too complex
00A8C5  1  4C 38 85           JMP   LAB_XERR
00A8C8  1  20 95 96     :     JSR   LAB_MSSP          ; make a string A size (str_pl)=(Sutill)
00A8CB  1  A4 12              LDY   Itemph
00A8CD  1  A6 11              LDX   Itempl
00A8CF  1  20 7B 98           JSR   LAB_2298          ; copy A bytes from YX to (Sutill)
00A8D2  1  68                 PLA                     ; original length
00A8D3  1  A0 00              LDY   #$00
00A8D5  1  91 AD              STA   (str_pl),y        ; save length
00A8D7  1  20 C2 00           JSR   LAB_GBYT          ; get next byte
00A8DA  1  C9 29              CMP   #')'
00A8DC  1  F0 32              BEQ   P2BS_DONE
00A8DE  1  20 4D 91           JSR   LAB_1C01          ; comma or syntax error
00A8E1  1  20 E7 99           JSR   LAB_GTBY          ; get byte param in x (mask)
00A8E4  1  86 5B        :     STX   Temp3             ; save mask
00A8E6  1  A0 00              LDY   #$00
00A8E8  1  B1 AD              LDA   (str_pl),y
00A8EA  1  CA                 DEX
00A8EB  1  30 03              BMI   :+
00A8ED  1  0A                 ASL                     ; perform shift of of length byte
00A8EE  1  D0 F4              BNE   :-
00A8F0  1  91 AD        :     STA   (str_pl),y
00A8F2  1  20 C2 00           JSR   LAB_GBYT
00A8F5  1  C9 29              CMP   #')'
00A8F7  1  F0 17              BEQ   P2BS_DONE
00A8F9  1  20 4D 91           JSR   LAB_1C01
00A8FC  1  20 E7 99           JSR   LAB_GTBY          ; get byte param in x (shift)
00A8FF  1  8A                 TXA
00A900  1  A0 00              LDY   #$00
00A902  1  11 AD              ORA   (str_pl),y
00A904  1  91 AD              STA   (str_pl),y
00A906  1  20 C2 00           JSR   LAB_GBYT
00A909  1  C9 29              CMP   #')'
00A90B  1  F0 03              BEQ   P2BS_DONE
00A90D  1  4C 51 91           JMP   LAB_SNER
00A910  1               P2BS_DONE
00A910  1  20 BC 00           JSR   LAB_IGBY          ; skip ')'
00A913  1  4C E1 96           JMP   LAB_RTST          ; return the string
00A916  1               
00A916  1               ; *************************************
00A916  1               ; Error Handling & Globals
00A916  1               ; *************************************
00A916  1               
00A916  1               LAB_ERROR
00A916  1  20 E7 99           JSR   LAB_GTBY          ; get byte parameter in x
00A919  1  8A                 TXA
00A91A  1  D0 01              BNE   :+
00A91C  1  60                 RTS                     ; do nothing if 0
00A91D  1  3A           :     DEC   A
00A91E  1  0A                 ASL
00A91F  1  AA                 TAX
00A920  1  4C 38 85           JMP   LAB_XERR
00A923  1               
00A923  1               ; TRY <statement> [then <statement> [else <statement>]]
00A923  1               LAB_TRY
00A923  1  C9 8B              CMP   #TK_IF            ; not allowed
00A925  1  D0 03              BNE   :+
00A927  1  4C 51 91           JMP   LAB_SNER
00A92A  1  A9 04        :     LDA   #$04              ; require 4 bytes on stack
00A92C  1  20 D1 84           JSR   LAB_1212          ; check room on stack
00A92F  1  9C rr rr           STZ   ERRNO_BASIC       ; clear existing error status
00A932  1  AD rr rr           LDA   TRY_STATUS        ; save existing TRY for nexting
00A935  1  48                 PHA
00A936  1  AD rr rr           LDA   TRY_SP
00A939  1  48                 PHA
00A93A  1  A5 C4              LDA   Bpntrh            ; save current code pointer Bpntrl/h
00A93C  1  48                 PHA
00A93D  1  A5 C3              LDA   Bpntrl
00A93F  1  48                 PHA
00A940  1  38                 SEC
00A941  1  6E rr rr           ROR   TRY_STATUS        ; indicate TRY active
00A944  1  BA                 TSX
00A945  1  8E rr rr           STX   TRY_SP            ; and make sure we can unroll stack
00A948  1  20 C2 00           JSR   LAB_GBYT          ; get current byte from run stream
00A94B  1  20 0E 8A           JSR   LAB_15FF          ; execute code, if error we don't come back
00A94E  1               LAB_TRYCONT                   ; directly
00A94E  1  68                 PLA                     ; get saved Bpntrl/h back
00A94F  1  85 C3              STA   Bpntrl
00A951  1  68                 PLA
00A952  1  85 C4              STA   Bpntrh
00A954  1  68                 PLA                     ; restore previous TRY state
00A955  1  8D rr rr           STA   TRY_SP
00A958  1  68                 PLA
00A959  1  8D rr rr           STA   TRY_STATUS
00A95C  1  64 AC              STZ   FAC1_e            ; Anticipate error
00A95E  1  AD rr rr           LDA   ERRNO_BASIC       ; get saved error code
00A961  1  D0 02              BNE   :+
00A963  1  E6 AC              INC   FAC1_e            ; return true if no error
00A965  1  20 C2 00     :     JSR   LAB_GBYT          ; get current byte in run stream
00A968  1  F0 0C              BEQ   LAB_TRY_EOS       ; either ELSE or end of statement
00A96A  1  C9 BB        :     CMP   #TK_THEN          ; is THEN?
00A96C  1  D0 03              BNE   :+
00A96E  1  4C FE 8B           JMP   LAB_TRYTHEN       ; go do THEN
00A971  1  20 BC 00     :     JSR   LAB_IGBY          ; otherwise fetch next byte in run stream
00A974  1  D0 F4              BNE   :--               ; and keep processing
00A976  1               LAB_TRY_EOS
00A976  1  C9 B7              CMP   #TK_ELSE          ; is ELSE?
00A978  1  F0 01              BEQ   :+                ; yep, go deal with it
00A97A  1  60                 RTS                     ; nope, end of statement reached
00A97B  1  AD rr rr     :     LDA   ERRNO_BASIC       ; check error
00A97E  1  D0 03              BNE   :+
00A980  1  4C CD 8B           JMP   LAB_DATA          ; ignore ELSE clause if no error
00A983  1  20 BC 00     :     JSR   LAB_IGBY          ; otherwise skip ELSE token
00A986  1  4C 5A 8C           JMP   LAB_1754          ; and execute clause
00A989  1               
00A989  1               ; error routine jumps here if try active
00A989  1               LAB_CATCH
00A989  1  AE rr rr           LDX   TRY_SP
00A98C  1  9A                 TXS                     ; unroll stack
00A98D  1  80 BF              BRA   LAB_TRYCONT       ; and continue TRY statement
00A98F  1               
00A98F  1               LAB_ERRNO
00A98F  1  20 4C 9A           JSR   LAB_F2FX          ; convert FAC1 to integer in Itempl/h
00A992  1  A5 11              LDA   Itempl
00A994  1  F0 0F              BEQ   LAB_ERRNO_LINE
00A996  1  C9 04              CMP   #$04
00A998  1  90 03              BCC   :+
00A99A  1  4C 78 94           JMP   LAB_FCER
00A99D  1  3A           :     DEC   A
00A99E  1  AA                 TAX
00A99F  1  BC rr rr           LDY   ERRNO_BASIC,X     ; get error code
00A9A2  1  4C C1 95           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00A9A5  1               LAB_ERRNO_LINE
00A9A5  1  AC rr rr           LDY   ERRNO_LINE
00A9A8  1  AD rr rr           LDA   ERRNO_LINE+1
00A9AB  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00A9AE  1               
00A9AE  1               ; Get address of global page+offset
00A9AE  1               LAB_GLOBAL
00A9AE  1  20 4C 9A           JSR   LAB_F2FX          ; convert FAC1 to integer in Itempl/h
00A9B1  1  A5 11              LDA   Itempl
00A9B3  1  18                 CLC
00A9B4  1  69 rr              ADC   #<GLOBAL_PAGE
00A9B6  1  A8                 TAY
00A9B7  1  A5 12              LDA   Itemph
00A9B9  1  69 rr              ADC   #>GLOBAL_PAGE
00A9BB  1  4C A8 95           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00A9BE  1               
00A9BE  1               ; *************************************
00A9BE  1               ; ProDOS/File Commands (except load/save)
00A9BE  1               ; *************************************
00A9BE  1               
00A9BE  1               ; find a file reference number (or 0 for first unallocated)
00A9BE  1               ; returns carry set &  offset in FILES in x if found
00A9BE  1               ; otherwise carry clear and X destroyed if not found
00A9BE  1               LAB_NEW_FREF
00A9BE  1  A9 00              LDA   #$00
00A9C0  1               LAB_GET_FREF
00A9C0  1  A2 1C              LDX   #7*4              ; max files = 8
00A9C2  1  DD rr rr     :     CMP   FILES,x
00A9C5  1  F0 07              BEQ   :+                ; carry is set by CMP
00A9C7  1  CA                 DEX
00A9C8  1  CA                 DEX
00A9C9  1  CA                 DEX
00A9CA  1  CA                 DEX
00A9CB  1  10 F5              BPL   :-
00A9CD  1  18                 CLC
00A9CE  1  60           :     RTS
00A9CF  1               
00A9CF  1               LAB_FREF_ARGN
00A9CF  1  C9 23              CMP   #'#'
00A9D1  1  F0 03              BEQ   LAB_FREF_ARG
00A9D3  1  4C 51 91           JMP   LAB_SNER
00A9D6  1               ; process an FREF arg
00A9D6  1               LAB_FREF_ARG
00A9D6  1  20 BC 00           JSR   LAB_IGBY          ; skip #
00A9D9  1  20 E7 99           JSR   LAB_GTBY          ; get byte parm in x
00A9DC  1  E4 80              CPX   $80
00A9DE  1  90 03              BCC   :+
00A9E0  1  4C 9E A6           JMP   LAB_IAER          ; if > 127
00A9E3  1  DA           :     PHX                     ; save file number
00A9E4  1  8A                 TXA
00A9E5  1  20 C0 A9           JSR   LAB_GET_FREF      ; see if in use
00A9E8  1  68                 PLA                     ; and get it back into A
00A9E9  1  60                 RTS
00A9EA  1               
00A9EA  1               ; implement OPEN #fnum,file/slot[,<type>] [FOR READ|WRITE|APPEND]
00A9EA  1               LAB_OPEN
00A9EA  1  20 CF A9           JSR   LAB_FREF_ARGN     ; get file arg and see if in use
00A9ED  1  90 05              BCC   :+                ; nope, don't error
00A9EF  1  A9 0C              LDA   #12               ; Re-DIM error
00A9F1  1  4C 38 85           JMP   LAB_XERR
00A9F4  1  48           :     PHA
00A9F5  1  20 BE A9           JSR   LAB_NEW_FREF      ; ge a new file ref
00A9F8  1  68                 PLA
00A9F9  1  B0 03              BCS   :+                ; got one, don't error
00A9FB  1               LAB_OMERF
00A9FB  1  4C 36 85           JMP   LAB_OMER          ; otherwise OOM
00A9FE  1  48           :     PHA
00A9FF  1  DA                 PHX
00AA00  1  20 42 AD           JSR   LAB_GETBUF        ; allocate a buffer
00AA03  1  FA                 PLX
00AA04  1  68                 PLA
00AA05  1  90 F4              BCC   LAB_OMERF         ; error out if no buffer allocated
00AA07  1  9D rr rr           STA   FILES,x           ; mark file slot in use
00AA0A  1  98                 TYA
00AA0B  1  9D rr rr           STA   FILES+2,x         ; save buffer number
00AA0E  1  DA                 PHX                     ; save file num
00AA0F  1  20 4D 91           JSR   LAB_1C01          ; scan for comma
00AA12  1  20 51 B1           JSR   GetPath           ; get path
00AA15  1  20 61 B1           JSR   CopyPath          ; and copy to PathBuf
00AA18  1  20 A8 B2           JSR   P8_Get_File_Info  ; get file info
00AA1B  1  FA                 PLX                     ; anticipate OK
00AA1C  1  90 0F              BCC   :+                ; if no error
00AA1E  1  48                 PHA
00AA1F  1  A9 80              LDA   #$80
00AA21  1  9D rr rr           STA   FILES,x           ; free slot
00AA24  1  BD rr rr           LDA   FILES+2,x         ; get buffer
00AA27  1  20 87 AD           JSR   LAB_FREEBUF       ; free it
00AA2A  1               P8_DoError4
00AA2A  1  4C A3 B2           JMP   P8_DoError        ; and error out
00AA2D  1               :     ;JSR
00AA2D  1  8E 42 B3           STx   PARM_Open+3       ; data buffer l
00AA30  1  8E 43 B3           STx   PARM_Open+4       ; data buffer h
00AA33  1  20 BF B2           JSR   P8_Open           ; open file
00AA36  1               
00AA36  1               
00AA36  1               
00AA36  1               
00AA36  1               LAB_OPEN_SLOT
00AA36  1  4C 32 85           JMP   LAB_XCER          ; not currently supported
00AA39  1               
00AA39  1               LAB_P8CALL
00AA39  1  20 E7 99           JSR   LAB_GTBY          ; get byte in X
00AA3C  1  8E 55 AA           STX   :+                ; put in P8 MLI call
00AA3F  1  20 4D 91           JSR   LAB_1C01          ; scan for "," or syntax error
00AA42  1  20 1C 90           JSR   LAB_EVNM          ; eval numeric expression
00AA45  1  20 4C 9A           JSR   LAB_F2FX          ; convert to temporary integer
00AA48  1  A5 12              LDA   Itemph            ; now get it and put into parameter list addr
00AA4A  1  8D 57 AA           STA   :++ +1
00AA4D  1  A5 11              LDA   Itempl
00AA4F  1  8D 56 AA           STA   :++
00AA52  1  20 00 BF           JSR   P8_MLI            ; call ProDOS!
00AA55  1  00           :     .byte $00
00AA56  1  00 00        :     .word $0000
00AA58  1  20 95 B2           JSR   P8_CheckErrs
00AA5B  1  B0 4E              BCS   P8_DoError3       ; all errors fail
00AA5D  1  60                 RTS
00AA5E  1               
00AA5E  1               LAB_DELETE
00AA5E  1  20 51 B1           JSR   GetPath
00AA61  1  20 61 B1           JSR   CopyPath
00AA64  1  20 19 B3           JSR   P8_Destroy
00AA67  1  B0 42              BCS   P8_DoError3
00AA69  1  60                 RTS
00AA6A  1               
00AA6A  1               LAB_RENAME
00AA6A  1  20 51 B1           JSR   GetPath
00AA6D  1  20 61 B1           JSR   CopyPath
00AA70  1  20 4D 91           JSR   LAB_1C01          ; scan for comma else syntax error
00AA73  1  20 51 B1           JSR   GetPath
00AA76  1  20 86 B1           JSR   CopyPath2         ; path 2 goes into reserved buffer
00AA79  1  20 04 B3           JSR   P8_Rename
00AA7C  1  B0 2D              BCS   P8_DoError3       ; file not found is fatal
00AA7E  1  60                 RTS
00AA7F  1               
00AA7F  1               LAB_PREFIX
00AA7F  1  D0 15              BNE   LAB_PREFIX_SET    ; set prefix if arg given
00AA81  1  20 D4 8D           JSR   LAB_CRLF
00AA84  1  20 EC B2           JSR   P8_Get_Prefix
00AA87  1  AE 80 02           LDX   PathBuf           ; length, always < 64 chars
00AA8A  1  A9 00              LDA   #$00
00AA8C  1  9D 81 02           STA   PathBuf+1,x       ; make zero-terminated string
00AA8F  1  A9 81              LDA   #<(PathBuf+1)
00AA91  1  A0 02              LDY   #>(PathBuf+1)
00AA93  1  4C 18 8E           JMP   LAB_18C3          ; print C string from memory and return
00AA96  1               LAB_PREFIX_SET
00AA96  1  20 30 90           JSR   LAB_EVEX          ; evaluate string
00AA99  1  20 97 98           JSR   LAB_EVST          ; a string?  YX=ptr, A=length
00AA9C  1  C9 41              CMP   #65               ; length OK? (prefix len is limited)
00AA9E  1  90 05              BCC   :+
00AAA0  1  A2 1A              LDX   #$1A              ; "string too long"
00AAA2  1  4C 38 85           JMP   LAB_XERR          ; error out
00AAA5  1  20 61 B1     :     JSR   CopyPath
00AAA8  1  20 F4 B2           JSR   P8_Set_Prefix     ; Set prefix
00AAAB  1               P8_DoError3
00AAAB  1  B0 72              BCS   P8_DoError2       ; FNF is fatal here
00AAAD  1  60                 RTS
00AAAE  1               
00AAAE  1               LAB_ONLINE
00AAAE  1  A9 00              LDA   #$00
00AAB0  1  8D 53 B3           STA   PARM_Online+1     ; $00 = all units
00AAB3  1  AD rr rr           LDA   RES_BUF
00AAB6  1  8D 54 B3           STA   PARM_Online+2
00AAB9  1  85 B4              STA   OSptr
00AABB  1  AD rr rr           LDA   RES_BUF+1
00AABE  1  8D 55 B3           STA   PARM_Online+3
00AAC1  1  85 B5              STA   OSptr+1
00AAC3  1  20 FC B2           JSR   P8_Online         ; Error trapped elsewhere
00AAC6  1               LAB_ONLINE_LP
00AAC6  1  A0 00              LDY   #$00
00AAC8  1  B1 B4              LDA   (OSptr),y
00AACA  1  F0 45              BEQ   LAB_ONLINE_DONE   ; 0 = end of online volumes
00AACC  1  20 24 AD           JSR   LAB_PRUNIT        ; print unit, in davex format for now
00AACF  1  20 15 AB           JSR   LAB_PRSP
00AAD2  1  B1 B4              LDA   (OSptr),y
00AAD4  1  29 0F              AND   #$0F
00AAD6  1  D0 1F              BNE   LAB_ONLINE_PRVOL  ; print volume name if no error
00AAD8  1  C8                 INY
00AAD9  1  B1 B4              LDA   (OSptr),y         ; otherwise get error #
00AADB  1  8D rr rr           STA   ERRNO_PRODOS
00AADE  1  20 08 85           JSR   LAB_GP8E          ; get P8 Error string
00AAE1  1  20 1D 85           JSR   LAB_PP8E          ; print it
00AAE4  1  A0 01              LDY   #$01
00AAE6  1  B1 B4              LDA   (OSptr),y
00AAE8  1  C9 57              CMP   #$57              ; duplicate volume
00AAEA  1  D0 19              BNE   LAB_ONLINE_NEXT
00AAEC  1  20 15 AB           JSR   LAB_PRSP
00AAEF  1  C8                 INY
00AAF0  1  B1 B4              LDA   (OSptr),y         ; unit of duplicate
00AAF2  1  20 24 AD           JSR   LAB_PRUNIT
00AAF5  1  80 0E              BRA   LAB_ONLINE_NEXT
00AAF7  1               LAB_ONLINE_PRVOL
00AAF7  1  48                 PHA
00AAF8  1  A9 2F              LDA   #'/'
00AAFA  1  20 32 8E           JSR   LAB_PRNA
00AAFD  1  68                 PLA
00AAFE  1  64 11              STZ   Itempl            ; Case bits - all as-is
00AB00  1  64 12              STZ   Itemph
00AB02  1  20 37 AC           JSR   CAT_DISP_NAME
00AB05  1               LAB_ONLINE_NEXT
00AB05  1  20 D4 8D           JSR   LAB_CRLF
00AB08  1  A9 10              LDA   #$10
00AB0A  1  20 1A AD           JSR   LAB_ADD_OSPTR
00AB0D  1  A5 B4              LDA   OSptr
00AB0F  1  D0 B5              BNE   LAB_ONLINE_LP
00AB11  1               LAB_ONLINE_DONE
00AB11  1  9C rr rr           STZ   ERRNO_PRODOS      ; clear temp error codes
00AB14  1  60                 RTS
00AB15  1               
00AB15  1               LAB_PRSP
00AB15  1  48                 PHA
00AB16  1  A9 20              LDA   #' '
00AB18  1  20 32 8E           JSR   LAB_PRNA
00AB1B  1  68                 PLA
00AB1C  1  60                 RTS
00AB1D  1               
00AB1D  1               P8_DoPathNotFound
00AB1D  1  A9 44              LDA   #$44
00AB1F  1               P8_DoError2
00AB1F  1  4C A3 B2           JMP   P8_DoError
00AB22  1               
00AB22  1               LAB_CATALOG
00AB22  1  D0 0A              BNE   :+                ; arg given
00AB24  1  20 EC B2           JSR   P8_Get_Prefix
00AB27  1  CE 80 02           DEC   PathBuf           ; remove trailing /
00AB2A  1  30 F1              BMI   P8_DoPathNotFound ; If null path, no guarantee we have a path though
00AB2C  1  10 06              BPL   :++               ; skip string eval
00AB2E  1  20 51 B1     :     JSR   GetPath
00AB31  1  20 61 B1           JSR   CopyPath
00AB34  1  20 A8 B2     :     JSR   P8_Get_File_Info  ; get info
00AB37  1  B0 E6              BCS   P8_DoError2       ; if file not found
00AB39  1  AD 28 B3           LDA   PARM_File_Info+7  ; storage type
00AB3C  1  C9 0F              CMP   #$0F              ; is volume directory?
00AB3E  1  F0 09              BEQ   :+
00AB40  1  C9 0D              CMP   #$0D              ; is directory file?
00AB42  1  F0 05              BEQ   :+
00AB44  1  A2 32              LDX   #$32              ; type mismatch
00AB46  1  4C 38 85           JMP   LAB_XERR
00AB49  1  AD rr rr     :     LDA   RES_BUF
00AB4C  1  8D 42 B3           STA   PARM_Open+3
00AB4F  1  AD rr rr           LDA   RES_BUF+1
00AB52  1  8D 43 B3           STA   PARM_Open+4
00AB55  1  20 BF B2           JSR   P8_Open           ; open directory
00AB58  1  AD 44 B3           LDA   PARM_Open+5       ; ref num
00AB5B  1  8D 46 B3           STA   PARM_ReadWrite+1
00AB5E  1  8D 4E B3           STA   PARM_Close+1
00AB61  1  29 7F              AND   #$7F              ; shouldn't need this but just in case
00AB63  1  20 42 AD           JSR   LAB_GETBUF
00AB66  1  5A                 PHY                     ; save buffer # on stack
00AB67  1  B0 03              BCS   :+
00AB69  1  4C A2 AB           JMP   CAT_NO_BUFFERS    ; ruh roh
00AB6C  1  8E rr rr     :     STX   ASM_BUF           ; save buffer address
00AB6F  1  8D rr rr           STA   ASM_BUF+1
00AB72  1  64 B6              STZ   OSptr2            ; where entry_length will go for now
00AB74  1  A9 00              LDA   #<$0200           ; size of block
00AB76  1  8D 49 B3           STA   PARM_ReadWrite+4
00AB79  1  A9 02              LDA   #>$0200
00AB7B  1  8D 4A B3           STA   PARM_ReadWrite+5
00AB7E  1               CAT_LOOP:
00AB7E  1  AD rr rr           LDA   ASM_BUF
00AB81  1  8D 47 B3           STA   PARM_ReadWrite+2
00AB84  1  85 B4              STA   OSptr
00AB86  1  AD rr rr           LDA   ASM_BUF+1
00AB89  1  8D 48 B3           STA   PARM_ReadWrite+3
00AB8C  1  85 B5              STA   OSptr+1
00AB8E  1  20 CA B2           JSR   P8_Read
00AB91  1  B0 07              BCS   CAT_DONE          ; Failed, probably EOF, close it up
00AB93  1  20 A8 AB           JSR   CAT_DO_BLOCK      ; display block
00AB96  1  A5 B6              LDA   OSptr2            ; get entry_length
00AB98  1  D0 E4              BNE   CAT_LOOP          ; if still zero or becomes zero, bail out
00AB9A  1               CAT_DONE
00AB9A  1  7A                 PLY   ; buffer number
00AB9B  1  20 87 AD           JSR   LAB_FREEBUF
00AB9E  1  20 DA B2           JSR   P8_Close
00ABA1  1  60                 RTS
00ABA2  1               CAT_NO_BUFFERS
00ABA2  1  20 DA B2           JSR   P8_Close
00ABA5  1  4C 36 85           JMP   LAB_OMER
00ABA8  1               
00ABA8  1               CAT_DO_BLOCK
00ABA8  1  A5 B6              LDA   OSptr2
00ABAA  1  F0 2D              BEQ   CAT_HEADER
00ABAC  1  A9 04              LDA   #$04
00ABAE  1  85 B4              STA   OSptr
00ABB0  1  A2 00              LDX   #$00              ; will count entries displayed in the block
00ABB2  1               CAT_DO_BLOCK_LP               ; OSptr is pointing at an entry here
00ABB2  1  A0 1D              LDY   #$1D              ; upper byte of case bits in this entry
00ABB4  1  20 08 AD           JSR   CAT_CASEBITS      ; get the case bits
00ABB7  1  A0 00              LDY   #$00
00ABB9  1  B1 B4              LDA   (OSptr),y
00ABBB  1  29 0F              AND   #$0F
00ABBD  1  F0 0F              BEQ   :+                ; inactive entry
00ABBF  1  DA                 PHX
00ABC0  1  20 2A AC           JSR   CAT_DO_ENTRY      ; display the entry
00ABC3  1  FA                 PLX
00ABC4  1  AD 00 C0           LDA   KBD
00ABC7  1  C9 83              CMP   #$83              ; CTRL-C
00ABC9  1  D0 03              BNE   :+
00ABCB  1  64 B6              STZ   OSptr2            ; make block loop bail out
00ABCD  1  60                 RTS
00ABCE  1  A5 B6        :     LDA   OSptr2            ; entry_length
00ABD0  1  20 1A AD           JSR   LAB_ADD_OSPTR     ; add it
00ABD3  1  E8                 INX
00ABD4  1  E4 B7              CPX   OSptr2+1
00ABD6  1  90 DA              BCC   CAT_DO_BLOCK_LP   ; haven't displayed all the things yet
00ABD8  1  60                 RTS
00ABD9  1               
00ABD9  1               ; Enter with OSptr pointing to the start of the block.
00ABD9  1               CAT_HEADER
00ABD9  1  20 D4 8D           JSR   LAB_CRLF
00ABDC  1  A0 04              LDY   #$04
00ABDE  1  B1 B4              LDA   (OSptr),y
00ABE0  1  29 F0              AND   #$F0
00ABE2  1  C9 F0              CMP   #$F0
00ABE4  1  F0 13              BEQ   CAT_VOL_HEADER    ; found volume header
00ABE6  1  C9 E0              CMP   #$E0              ; directory header
00ABE8  1  F0 01              BEQ   CAT_DIR_HEADER    ; found directory header
00ABEA  1  60                 RTS                     ; something wrong, though, don't do block
00ABEB  1               CAT_DIR_HEADER
00ABEB  1  A0 21              LDY   #$21              ; case bits hi byte in dir header, from 0
00ABED  1  20 08 AD           JSR   CAT_CASEBITS
00ABF0  1  A9 7C              LDA   #<LAB_FOLDER
00ABF2  1  A0 BD              LDY   #>LAB_FOLDER
00ABF4  1  20 18 8E           JSR   LAB_18C3          ; print folder symbol
00ABF7  1  80 0C              BRA   :+
00ABF9  1               CAT_VOL_HEADER
00ABF9  1  A0 1B              LDY   #$1B              ; case bits hi byte in vol header, from 0
00ABFB  1  20 08 AD           JSR   CAT_CASEBITS
00ABFE  1  A9 84              LDA   #<LAB_VOLUME
00AC00  1  A0 BD              LDY   #>LAB_VOLUME
00AC02  1  20 18 8E           JSR   LAB_18C3          ; print apple-space-slash
00AC05  1  A0 04        :     LDY   #$04
00AC07  1  B1 B4              LDA   (OSptr),y
00AC09  1  29 0F              AND   #$0F
00AC0B  1  20 37 AC           JSR   CAT_DISP_NAME
00AC0E  1  A9 0A              LDA   #$0A              ; this works around stupid
00AC10  1  20 32 8E           JSR   LAB_PRNA          ; 80-col bug
00AC13  1  20 D4 8D           JSR   LAB_CRLF
00AC16  1  A0 23              LDY   #$23
00AC18  1  B1 B4              LDA   (OSptr),y         ; entry_length
00AC1A  1  85 B6              STA   OSptr2
00AC1C  1  C8                 INY
00AC1D  1  B1 B4              LDA   (OSptr),y         ; entries_per_block
00AC1F  1  85 B7              STA   OSptr2+1
00AC21  1  A9 2B              LDA   #$2B              ; First entry after header is in fixed position
00AC23  1  85 B4              STA   OSptr
00AC25  1  A2 01              LDX   #$01              ; already did one entry
00AC27  1  4C B2 AB           JMP   CAT_DO_BLOCK_LP   ; get in the middle
00AC2A  1               ; on entry, Y=0, A has length of file name in low nibble, (OSptr) is at entry
00AC2A  1               ; and we can do what we want with any of the regs.
00AC2A  1               CAT_DO_ENTRY
00AC2A  1  20 37 AC           JSR   CAT_DISP_NAME
00AC2D  1  20 5A AC           JSR   CAT_DISP_TYPE
00AC30  1  20 B3 AC           JSR   CAT_DISP_BLOCKS
00AC33  1  20 D4 8D           JSR   LAB_CRLF
00AC36  1  60                 RTS
00AC37  1               ; At entry, (OSptr) points to 1 byte before name, A has length of name
00AC37  1               ; and Y is 0.   Assumes case bits havd been set up in Itempl/Itemph
00AC37  1               CAT_DISP_NAME
00AC37  1  AA                 TAX
00AC38  1  C8           :     INY
00AC39  1  B1 B4              LDA   (OSptr),y
00AC3B  1  26 11              ROL   Itempl            ; rotate case bits
00AC3D  1  26 12              ROL   Itemph
00AC3F  1  24 12              BIT   Itemph            ; Check case bit for current char
00AC41  1  10 06              BPL   :+                ; as-is if case bit not set
00AC43  1  C9 20              CMP   #' '
00AC45  1  90 02              BCC   :+
00AC47  1  09 20              ORA   #$20              ; To lower
00AC49  1  20 32 8E     :     JSR   LAB_PRNA
00AC4C  1  CA                 DEX
00AC4D  1  D0 E9              BNE   :--
00AC4F  1  A9 20              LDA   #' '              ; now fill out to 16th char
00AC51  1  C8           :     INY
00AC52  1  20 32 8E           JSR   LAB_PRNA
00AC55  1  C0 10              CPY   #16
00AC57  1  90 F8              BCC   :-
00AC59  1  60                 RTS
00AC5A  1               ; display type. (OSptr) points to dir entry
00AC5A  1               CAT_DISP_TYPE
00AC5A  1  A9 04              LDA   #$04              ; string length
00AC5C  1  20 95 96           JSR   LAB_MSSP          ; allocate temp string pointed at by str_pl
00AC5F  1  A0 10              LDY   #$10
00AC61  1  A2 FC              LDX   #$FC
00AC63  1  E8           :     INX
00AC64  1  E8                 INX
00AC65  1  E8                 INX
00AC66  1  E8                 INX
00AC67  1  BD 33 BD           LDA   FTYPES,x
00AC6A  1  F0 12              BEQ   :++
00AC6C  1  D1 B4              CMP   (OSptr),y
00AC6E  1  D0 F3              BNE   :-
00AC70  1  A0 03              LDY   #$03
00AC72  1  E8           :     INX
00AC73  1  BD 33 BD           LDA   FTYPES,X
00AC76  1  20 32 8E           JSR   LAB_PRNA
00AC79  1  88                 DEY
00AC7A  1  D0 F6              BNE   :-
00AC7C  1  F0 13              BEQ   CAT_DISP_AUXTYPE
00AC7E  1  A9 24        :     LDA   #'$'
00AC80  1  20 32 8E           JSR   LAB_PRNA
00AC83  1  A0 10              LDY   #$10
00AC85  1  B1 B4              LDA   (OSptr),y
00AC87  1  A0 03              LDY   #$03              ; index into string, A2HX stores backwards!
00AC89  1  20 AA A3           JSR   LAB_A2HX          ; convert to hex
00AC8C  1  A2 02              LDX   #$02
00AC8E  1  20 A9 AC           JSR   :+                ; print 2 chars
00AC91  1               CAT_DISP_AUXTYPE
00AC91  1  A9 20              LDA   #' '
00AC93  1  20 32 8E           JSR   LAB_PRNA
00AC96  1  A0 20              LDY   #$20
00AC98  1  B1 B4              LDA   (OSptr),y
00AC9A  1  48                 PHA
00AC9B  1  88                 DEY
00AC9C  1  B1 B4              LDA   (OSptr),y
00AC9E  1  A0 03              LDY   #$03
00ACA0  1  20 AA A3           JSR   LAB_A2HX
00ACA3  1  68                 PLA
00ACA4  1  20 AA A3           JSR   LAB_A2HX
00ACA7  1  A2 04              LDX   #$04
00ACA9  1  C8           :     INY
00ACAA  1  B1 AD              LDA   (str_pl),y
00ACAC  1  20 32 8E           JSR   LAB_PRNA
00ACAF  1  CA                 DEX
00ACB0  1  D0 F7              BNE   :-
00ACB2  1  60                 RTS
00ACB3  1               CAT_DISP_BLOCKS
00ACB3  1  A2 03              LDX   #$03
00ACB5  1  B5 B4        :     LDA   OSptr,x
00ACB7  1  48                 PHA
00ACB8  1  CA                 DEX
00ACB9  1  10 FA              BPL   :-
00ACBB  1  A0 14              LDY   #$14
00ACBD  1  B1 B4              LDA   (OSptr),y
00ACBF  1  48                 PHA
00ACC0  1  88                 DEY
00ACC1  1  B1 B4              LDA   (OSptr),y
00ACC3  1  A8                 TAY
00ACC4  1  68                 PLA
00ACC5  1  20 A8 95           JSR   LAB_AYFC          ; convert AY to float, overwrites FAC2
00ACC8  1  20 F0 9F           JSR   LAB_296E          ; convert to string at Decssp1
00ACCB  1  A2 00              LDX   #$00
00ACCD  1  68           :     PLA
00ACCE  1  95 B4              STA   OSptr,x
00ACD0  1  E8                 INX
00ACD1  1  E0 04              CPX   #$04
00ACD3  1  90 F8              BCC   :-
00ACD5  1  A2 00              LDX   #$00
00ACD7  1  B5 F0        :     LDA   Decssp1,x         ; figure out
00ACD9  1  F0 03              BEQ   :+
00ACDB  1  E8                 INX
00ACDC  1  D0 F9              BNE   :-
00ACDE  1  E0 07        :     CPX   #$07
00ACE0  1  90 02              BCC   :+
00ACE2  1  A2 06              LDX   #$06              ; clamp to 5 digits (including empty sign)
00ACE4  1  8A           :     TXA
00ACE5  1  49 FF              EOR   #$FF
00ACE7  1  38                 SEC
00ACE8  1  69 06              ADC   #$06              ; negate and add 6
00ACEA  1  F0 09              BEQ   :++               ; no spaces
00ACEC  1  A8                 TAY
00ACED  1  A9 20        :     LDA   #' '
00ACEF  1  20 32 8E           JSR   LAB_PRNA
00ACF2  1  88                 DEY
00ACF3  1  D0 F8              BNE   :-
00ACF5  1  8A           :     TXA
00ACF6  1  A8                 TAY
00ACF7  1  A2 00              LDX   #$00
00ACF9  1  B5 F0        :     LDA   Decssp1,x
00ACFB  1  20 32 8E           JSR   LAB_PRNA
00ACFE  1  E8                 INX
00ACFF  1  88                 DEY
00AD00  1  D0 F7              BNE   :-
00AD02  1  A9 20              LDA   #' '
00AD04  1  20 32 8E           JSR   LAB_PRNA
00AD07  1  60                 RTS
00AD08  1               
00AD08  1               ; Get case bits at (OSptr),Y-1
00AD08  1               CAT_CASEBITS
00AD08  1  64 11              STZ   Itempl
00AD0A  1  64 12              STZ   Itemph
00AD0C  1  48                 PHA
00AD0D  1  B1 B4              LDA   (OSptr),y
00AD0F  1  10 07              BPL   :+                ; not case bits
00AD11  1  85 12              STA   Itemph
00AD13  1  88                 DEY
00AD14  1  B1 B4              LDA   (OSptr),y
00AD16  1  85 11              STA   Itempl
00AD18  1  68           :     PLA
00AD19  1  60                 RTS
00AD1A  1               
00AD1A  1               LAB_ADD_OSPTR
00AD1A  1  18                 CLC
00AD1B  1  65 B4              ADC   OSptr
00AD1D  1  85 B4              STA   OSptr
00AD1F  1  90 02              BCC   :+
00AD21  1  E6 B5              INC   OSptr+1
00AD23  1  60           :     RTS
00AD24  1               
00AD24  1               LAB_PRUNIT
00AD24  1  48                 PHA
00AD25  1  A9 2E              LDA   #'.'
00AD27  1  20 32 8E           JSR   LAB_PRNA
00AD2A  1  68                 PLA
00AD2B  1  48                 PHA
00AD2C  1  4A                 LSR
00AD2D  1  4A                 LSR
00AD2E  1  4A                 LSR
00AD2F  1  4A                 LSR
00AD30  1  29 07              AND   #$07
00AD32  1  09 30              ORA   #$30
00AD34  1  20 32 8E           JSR   LAB_PRNA
00AD37  1  68                 PLA
00AD38  1  2A                 ROL
00AD39  1  2A                 ROL
00AD3A  1  29 01              AND   #$01
00AD3C  1  1A                 INC   A
00AD3D  1  09 30              ORA   #$30
00AD3F  1  4C 32 8E           JMP   LAB_PRNA
00AD42  1               
00AD42  1               
00AD42  1               ; return carry clear if no buffer allocated
00AD42  1               ; otherwise, carry set and Y=Buffer number, AX=buffer addr
00AD42  1               ; this routine could use some TLC
00AD42  1               LAB_GETBUF
00AD42  1  5A                 phy
00AD43  1  DA                 phx
00AD44  1  48                 pha
00AD45  1  A0 00              ldy   #$00
00AD47  1               LAB_GETBUF_LP
00AD47  1  C8                 iny
00AD48  1  C0 09              cpy   #$09
00AD4A  1  B0 2C              bcs   LAB_GETBUF_FAIL
00AD4C  1  98                 tya
00AD4D  1  0A                 asl
00AD4E  1  AA                 tax
00AD4F  1  BD rr rr           lda   BUFFS,x
00AD52  1  10 F3              bpl   LAB_GETBUF_LP     ; buffer is in use
00AD54  1  1A                 inc   a
00AD55  1  F0 14              beq   LAB_GETBUF_GOT    ; a previously-freed, but allocated, buffer
00AD57  1  5A                 phy
00AD58  1  DA                 phx
00AD59  1  20 C9 AD           jsr   LAB_ALLOC_BUFFER
00AD5C  1  FA                 plx
00AD5D  1  7A                 ply
00AD5E  1  90 18              bcc   LAB_GETBUF_FAIL
00AD60  1  EE rr rr           inc   BUFFS
00AD63  1  98                 tya
00AD64  1  0A                 asl
00AD65  1  AA                 tax
00AD66  1  A5 86              lda   Ememh
00AD68  1  9D rr rr           sta   BUFFS+1,x
00AD6B  1               LAB_GETBUF_GOT
00AD6B  1  68                 pla
00AD6C  1  9D rr rr           sta   BUFFS,x
00AD6F  1  68                 pla                     ; discard saved x
00AD70  1  68                 pla                     ; discard saved y
00AD71  1               LAB_GETBUF_BUFADDR
00AD71  1  BD rr rr           lda   BUFFS+1,x
00AD74  1  A6 85              ldx   Ememl             ; AX = buffer address, y = buffer number
00AD76  1  38                 sec
00AD77  1  60                 rts
00AD78  1               LAB_GETBUF_FAIL
00AD78  1  18                 clc
00AD79  1  68                 pla
00AD7A  1  FA                 plx
00AD7B  1  7A                 ply
00AD7C  1  60                 rts
00AD7D  1               
00AD7D  1               ; enter with Y = buffer number
00AD7D  1               ; return with carry set and AX = buffer number
00AD7D  1               ; or carry clear if problem
00AD7D  1               LAB_BUFADR
00AD7D  1  98                 tya
00AD7E  1  0A                 asl
00AD7F  1  AA                 tax
00AD80  1  BD rr rr           lda   BUFFS,x
00AD83  1  10 EC              bpl   LAB_GETBUF_BUFADDR
00AD85  1  18                 clc
00AD86  1  60                 rts
00AD87  1               
00AD87  1               ; input y=buffer number
00AD87  1               ; return carry clear if no buffer freed
00AD87  1               ; otherwise, carry set
00AD87  1               LAB_FREEBUF
00AD87  1  5A                 phy
00AD88  1  DA                 phx
00AD89  1  48                 pha
00AD8A  1  98                 tya
00AD8B  1  0A                 asl
00AD8C  1  AA                 tax
00AD8D  1  BD rr rr           lda   BUFFS,x
00AD90  1  30 31              bmi   LAB_FREEBUF_FAIL  ; attempt to free already-free buffer
00AD92  1  A9 FF              lda   #$FF
00AD94  1  9D rr rr           sta   BUFFS,x           ; signal buffer freed
00AD97  1  A2 10              ldx   #$08*2            ; scan buffers to deallocate, from the top
00AD99  1  BD rr rr     :     lda   BUFFS,x
00AD9C  1  10 22              bpl   LAB_FREEBUF_SUCC  ; used buffer, stop scanning
00AD9E  1  1A                 inc   a
00AD9F  1  D0 1B              bne   :+                ; wasn't $FF, so must be dealloc
00ADA1  1  BD rr rr           lda   BUFFS+1,x
00ADA4  1  C5 86              cmp   Ememh
00ADA6  1  D0 1B              bne   LAB_FREEBUF_FAIL  ; Not at the addr we expect to deallocate
00ADA8  1  DA                 phx
00ADA9  1  20 07 AE           jsr   LAB_DEALLOC_BUFFER
00ADAC  1  FA                 plx
00ADAD  1  90 14              bcc   LAB_FREEBUF_FAIL
00ADAF  1  CE rr rr           dec   BUFFS             ; dec buffer count
00ADB2  1  A9 80              lda   #$80
00ADB4  1  9D rr rr           sta   BUFFS,x           ; signal buffer deallocated
00ADB7  1  A9 00              lda   #$00
00ADB9  1  9D rr rr           sta   BUFFS+1,x
00ADBC  1  CA           :     dex
00ADBD  1  CA                 dex
00ADBE  1  D0 D9              bne   :--
00ADC0  1               LAB_FREEBUF_SUCC
00ADC0  1  38                 sec
00ADC1  1  B0 02              bcs   :+
00ADC3  1               LAB_FREEBUF_FAIL
00ADC3  1  00                 brk                     ; TODO: remove when routine is proven
00ADC4  1  18                 clc
00ADC5  1  68           :     pla
00ADC6  1  FA                 plx
00ADC7  1  7A                 ply
00ADC8  1  60                 rts
00ADC9  1               
00ADC9  1               
00ADC9  1               ; Allocate a 1K buffer.
00ADC9  1               ; If success, return carry set and Emem reflecting location of buffer
00ADC9  1               ; Strings are moved and descriptors adjusted.
00ADC9  1               ; If fail, return carry clear and no changes.
00ADC9  1               ; to move, we start at the bottom and work our way up
00ADC9  1               LAB_ALLOC_BUFFER
00ADC9  1  20 F9 AD           jsr   ALLOC_PREP        ; Top of string storage now in X
00ADCC  1  38                 sec
00ADCD  1  E9 04              sbc   #$04
00ADCF  1  C5 80              cmp   Earryh            ; collides with array top?
00ADD1  1  F0 02              beq   LAB_ALLOC_FAIL    ; if same page as array top (note carry set)
00ADD3  1  B0 02              bcs   :+                ; okay if we are >, fall through if <
00ADD5  1               LAB_ALLOC_FAIL
00ADD5  1  18                 clc                     ; no room!
00ADD6  1  60                 rts
00ADD7  1  A8           :     tay                     ; move target now in y
00ADD8  1  20 E5 AE     :     jsr   LAB_CopyPage      ; do copy page x to page y, preserves x and y
00ADDB  1  E8                 inx                     ; move up a page
00ADDC  1  C8                 iny
00ADDD  1  E4 86              cpx   Ememh             ; Ememh = last usable page + 1
00ADDF  1  90 F7              bcc   :-
00ADE1  1  A5 86              lda   Ememh             ; fix general pointers
00ADE3  1  E9 04              sbc   #$04              ; carry is set when loop ends
00ADE5  1  85 86              sta   Ememh
00ADE7  1  A5 82              lda   Sstorh
00ADE9  1  E9 04              sbc   #$04              ; ditto
00ADEB  1  85 82              sta   Sstorh
00ADED  1  A9 80              lda   #$80
00ADEF  1  85 B3              sta   MoveDir           ; flag moving down
00ADF1  1  20 37 AE           jsr   LAB_SVAR_REBASE   ; rebase string variables
00ADF4  1  20 79 AE           jsr   LAB_SARR_REBASE   ; rebase string arrays
00ADF7  1  38                 sec
00ADF8  1  60                 rts
00ADF9  1               ALLOC_PREP
00ADF9  1  20 3B 97           jsr   LAB_GARB
00ADFC  1  A5 81              lda   Sstorl            ; calc and return page we are moving
00ADFE  1  38                 sec                     ; by subtracting 1 from start of string storage
00ADFF  1  E9 01              sbc   #$01              ; this avoids the case where Sstor is at Emem
00AE01  1  A5 82              lda   Sstorh
00AE03  1  E9 00              sbc   #$00
00AE05  1  AA                 tax
00AE06  1  60                 rts
00AE07  1               
00AE07  1               ; Deallocate a 1K buffer.
00AE07  1               ; If success, return carry clear and Emem reflecting location of next
00AE07  1               ; buffer or RAM_TOP
00AE07  1               ; to move, we start at the top and work our way down
00AE07  1               LAB_DEALLOC_BUFFER
00AE07  1  20 F9 AD           jsr   ALLOC_PREP        ; do some prelim work & get bottom string page
00AE0A  1  18                 clc
00AE0B  1  69 04              adc   #$04              ; destination 4 pages = 1K lower
00AE0D  1  CD rr rr           cmp   RAM_TOP+1         ; collides with RAM_TOP or higher
00AE10  1  90 02              bcc   :+                ; if <= RAM_TOP page
00AE12  1  38                 sec                     ; can't dealloc!
00AE13  1  60                 rts
00AE14  1  A8           :     tay                     ; dest page
00AE15  1  20 E5 AE     :     jsr   LAB_CopyPage      ; do copy page x to page y, preserves x and y
00AE18  1  CA                 dex                     ; move down a page
00AE19  1  88                 dey
00AE1A  1  E4 82              cpx   Sstorh            ; Sstorh = page at bottom of string memory
00AE1C  1  B0 F7              bcs   :-                ; continue copying why >= (want to include the page)
00AE1E  1  A5 86              lda   Ememh             ; fix general pointers
00AE20  1  18                 clc
00AE21  1  69 04              adc   #$04              ; if carry gets set here, something very wrong
00AE23  1  85 86              sta   Ememh
00AE25  1  A5 82              lda   Sstorh
00AE27  1  69 04              adc   #$04              ; ditto
00AE29  1  85 82              sta   Sstorh
00AE2B  1  A9 00              lda   #$00
00AE2D  1  85 B3              sta   MoveDir           ; flag moving down
00AE2F  1  20 37 AE           jsr   LAB_SVAR_REBASE   ; rebase string variables
00AE32  1  20 79 AE           jsr   LAB_SARR_REBASE   ; rebase string arrays
00AE35  1  38                 sec
00AE36  1  60                 rts
00AE37  1               
00AE37  1               LAB_SVAR_REBASE
00AE37  1  A5 7B              lda   Svarl             ; now need to fix up all string vars
00AE39  1  85 B4              sta   OSptr             ; so copy var start ptr to OS scratch ptr
00AE3B  1  A5 7C              lda   Svarh
00AE3D  1  85 B5              sta   OSptr+1
00AE3F  1               SVAR_REBASE_LP
00AE3F  1  A5 B5              lda   OSptr+1
00AE41  1  C5 7E              cmp   Sarryh
00AE43  1  90 07              bcc   :+                ; skip next compare if less than
00AE45  1  A5 B4              lda   OSptr
00AE47  1  C5 7D              cmp   Sarryl
00AE49  1  90 01              bcc   :+                ; less than, keep going
00AE4B  1  60                 rts                     ; otherwise done
00AE4C  1  A0 01        :     ldy   #$01
00AE4E  1  B1 B4              lda   (OSptr),y         ; first descriptor
00AE50  1  10 05              bpl   SVAR_REBASE_LPB   ; not string, go to next descriptor
00AE52  1  A0 04              ldy   #$04              ; offset of high byte of string address
00AE54  1  20 64 AE           jsr   LAB_REBASE_ADJ
00AE57  1               SVAR_REBASE_LPB               ; bottom of loop section
00AE57  1  A5 B4              lda   OSptr
00AE59  1  18                 clc
00AE5A  1  69 06              adc   #$06              ; descriptor size
00AE5C  1  90 02              bcc   :+
00AE5E  1  E6 B5              inc   OSptr+1
00AE60  1  85 B4        :     sta   OSptr
00AE62  1  80 DB              bra   SVAR_REBASE_LP
00AE64  1               
00AE64  1               ; Routine to adjust pointers for buffer moves
00AE64  1               LAB_REBASE_ADJ
00AE64  1  B1 B4              lda   (OSptr),y         ; get high byte
00AE66  1  C5 7C              cmp   Svarh             ; is it in program text?
00AE68  1  90 0E              bcc   :+++              ; Ooh probably, or null ptr.  Don't adjust.
00AE6A  1  24 B3              bit   MoveDir           ; we never move any page with program text
00AE6C  1  30 05              bmi   :+                ; so doing the adjustment is safe
00AE6E  1  18                 clc
00AE6F  1  69 04              adc   #$04              ; four pages forward
00AE71  1  90 03              bcc   :++
00AE73  1  38           :     sec
00AE74  1  E9 04              sbc   #$04              ; four pages back
00AE76  1  91 B4        :     sta   (OSptr),y
00AE78  1  60           :     rts
00AE79  1               
00AE79  1               LAB_SARR_REBASE
00AE79  1  A5 7D              lda   Sarryl            ; now need to fix up all string vars
00AE7B  1  85 B4              sta   OSptr             ; so copy var start ptr to OS scratch ptr
00AE7D  1  A5 7E              lda   Sarryh
00AE7F  1  85 B5              sta   OSptr+1
00AE81  1               SARR_REBASE_LP                ; enter with OSptr pointing at start of array
00AE81  1  A5 B5              lda   OSptr+1           ; compare against end of them
00AE83  1  C5 80              cmp   Earryh
00AE85  1  90 07              bcc   :+
00AE87  1  A5 B4              lda   OSptr
00AE89  1  C5 7F              cmp   Earryl
00AE8B  1  90 01              bcc   :+                ; less than, keep going
00AE8D  1  60                 rts                     ; otherwise done
00AE8E  1  A0 02        :     ldy   #$02              ; add size to OSptr and store in OSptr2
00AE90  1  B1 B4              lda   (OSptr),y         ; low byte of total size
00AE92  1  18                 clc
00AE93  1  65 B4              adc   OSptr
00AE95  1  85 B6              sta   OSptr2
00AE97  1  C8                 iny
00AE98  1  B1 B4              lda   (OSptr),y         ; high byte
00AE9A  1  65 B5              adc   OSptr+1
00AE9C  1  85 B7              sta   OSptr2+1          ; OSptr2 now points to next array
00AE9E  1  A0 01              ldy   #$01              ; check if string arry
00AEA0  1  B1 B4              lda   (OSptr),y         ; high bit set if this is a string array
00AEA2  1  10 37              bpl   SARR_REBASE_LPB   ; it isn't, go to next iteration
00AEA4  1  A0 04              ldy   #$04              ; start rebase, calculate start of elements
00AEA6  1  B1 B4              lda   (OSptr),y         ; get # of dimensions
00AEA8  1  0A                 asl                     ; *2 = total size of dimension list
00AEA9  1  90 03              bcc   :+                ; skip incr high byte if no carry
00AEAB  1  E6 B5              inc   OSptr+1
00AEAD  1  18                 clc
00AEAE  1  65 B4        :     adc   OSptr             ; add low byte of pointer
00AEB0  1  90 03              bcc   :+
00AEB2  1  E6 B5              inc   OSptr+1           ; inc high byte if carry
00AEB4  1  18                 clc
00AEB5  1  69 05        :     adc   #$05              ; add fixed portion of header
00AEB7  1  85 B4              sta   OSptr
00AEB9  1  90 02              bcc   :+
00AEBB  1  E6 B5              inc   OSptr+1           ; inc high byte if carry -- whew!
00AEBD  1  A0 02        :     ldy   #$02              ; stays constant in the inner loop
00AEBF  1               SARR_REBASE_ILP               ; inner loop for each element
00AEBF  1  A5 B5              lda   OSptr+1           ; check for end (in case size 0 array?)
00AEC1  1  C5 B7              cmp   OSptr2+1
00AEC3  1  90 06              bcc   :+
00AEC5  1  A5 B4              lda   OSptr
00AEC7  1  C5 B6              cmp   OSptr2
00AEC9  1  B0 10              bcs   SARR_REBASE_LPB   ; >=, hit end
00AECB  1  20 64 AE     :     jsr   LAB_REBASE_ADJ    ; note Y constant
00AECE  1  A5 B4              lda   OSptr
00AED0  1  18                 clc                     ; go to next element
00AED1  1  69 04              adc   #$04              ; size of element
00AED3  1  90 02              bcc   :+
00AED5  1  E6 B5              inc   OSptr+1
00AED7  1  85 B4        :     sta   OSptr
00AED9  1  80 E4              bra   SARR_REBASE_ILP
00AEDB  1               SARR_REBASE_LPB
00AEDB  1  A5 B7              lda   OSptr2+1
00AEDD  1  85 B5              sta   OSptr+1
00AEDF  1  A5 B6              lda   OSptr2
00AEE1  1  85 B4              sta   OSptr             ; OSptr now points to next array
00AEE3  1  80 9C              bra   SARR_REBASE_LP
00AEE5  1               
00AEE5  1               ; copy page in X to page in Y, preserve X and Y regs
00AEE5  1               LAB_CopyPage
00AEE5  1  48                 pha
00AEE6  1  84 B7              sty   OSptr2+1
00AEE8  1  5A                 phy
00AEE9  1  A0 00              ldy   #$00
00AEEB  1  84 B4              sty   OSptr
00AEED  1  84 B6              sty   OSptr2
00AEEF  1  86 B5              stx   OSptr+1
00AEF1  1  84 B6              sty   OSptr2
00AEF3  1  B1 B4        :     lda   (OSptr),y
00AEF5  1  91 B6              sta   (OSptr2),y
00AEF7  1  C8                 iny
00AEF8  1  D0 F9              bne   :-
00AEFA  1  7A                 ply
00AEFB  1  68                 pla
00AEFC  1  60                 rts
00AEFD  1               .endif
00AEFD  1               
00AEFD  1               ; system dependent i/o vectors
00AEFD  1               .ifdef APPLE2
00AEFD  1               ; RESET handling
00AEFD  1               LAB_RESET
00AEFD  1  A2 07              LDX   #7                ; force reinit of all slots
00AEFF  1  9E rr rr     :     STZ   SLOT_STATUS,X
00AF02  1  CA                 DEX
00AF03  1  10 FA              BPL   :-
00AF05  1  AD rr rr           LDA   IO_TEXT_SLOT      ; redirect I/O to last $8x-type device
00AF08  1  20 83 AF           JSR   DO_VEC_SETISLOT
00AF0B  1  AD rr rr           LDA   IO_TEXT_SLOT
00AF0E  1  20 BA AF           JSR   DO_VEC_SETOSLOT
00AF11  1                     ; JSR   DO_VEC_PINIT      ; reinit text I/O
00AF11  1  4C 95 85           JMP   LAB_1274          ; warm start
00AF14  1               
00AF14  1               ; Apple II I/O vectoring.  Supports Pascal 1.1 protocol cards
00AF14  1               
00AF14  1               ; non-blocking input.  TODO: do something with firmware error code
00AF14  1               V_INPT
00AF14  1  DA                 PHX
00AF15  1  5A                 PHY
00AF16  1  E6 4E              INC   ZP_RNDL           ; Apple II random seed
00AF18  1  D0 02              BNE   :+
00AF1A  1  E6 4F              INC   ZP_RNDH
00AF1C  1  20 36 B0     :     JSR   DO_VEC_IN_STATUS  ; get device status
00AF1F  1  A9 00              LDA   #$00              ; anticipate not ready
00AF21  1  90 0B              BCC   :+                ; cc = not ready
00AF23  1  20 44 B0           JSR   DO_VEC_IN         ; get waiting char
00AF26  1  E0 00              CPX   #$00              ; carry is set
00AF28  1  F0 04              BEQ   :+                ; if no error
00AF2A  1  8E rr rr           STX   ERRNO_PASCAL_IO   ; save error number
00AF2D  1  18                 CLC                     ; clear carry on error
00AF2E  1  7A           :     PLY
00AF2F  1  FA                 PLX
00AF30  1  60                 RTS
00AF31  1               
00AF31  1               ; Special workaround:
00AF31  1               ; For line input, this ensures cursor is present on 40-col A2 screen
00AF31  1               ; if input port is 0, otherwise uses firmware routines
00AF31  1               V_INPT2
00AF31  1  AD rr rr           LDA   IO_SLOT_IN        ; see if 'slot 0'
00AF34  1  D0 DE              BNE   V_INPT            ; if not do standard input routine
00AF36  1  5A                 PHY
00AF37  1  A4 24              LDY   ZP_CH             ; cursor horizontal
00AF39  1  B1 28              LDA   (ZP_BASL),Y       ; get character under cursor
00AF3B  1  20 1B FD           JSR   F8_KEYIN          ; blocking
00AF3E  1  29 7F              AND   #$7F              ; convert to low ASCII
00AF40  1  38                 SEC                     ; flag got character
00AF41  1  7A                 PLY
00AF42  1  60                 RTS
00AF43  1               
00AF43  1               ; Blocking input routine for Apple II KSW vector
00AF43  1               V_INPT_MON
00AF43  1  48                 PHA
00AF44  1  AD rr rr           LDA   IO_SLOT_IN        ; slot 0?
00AF47  1  D0 04              BNE   :+                ; nope, do V_INPT loop
00AF49  1  68                 PLA
00AF4A  1  4C 1B FD           JMP   F8_KEYIN          ; straight into F8 keyboard handler
00AF4D  1  68           :     PLA
00AF4E  1  20 14 AF     :     JSR   V_INPT            ; non-blocking input
00AF51  1  90 FB              BCC   :-                ; not ready, do again
00AF53  1  09 80              ORA   #$80              ; set high bit
00AF55  1  A4 24              LDY   ZP_CH             ; monitor promises to return this
00AF57  1  60                 RTS
00AF58  1               
00AF58  1               ; output routine
00AF58  1               V_OUTP
00AF58  1  48                 PHA
00AF59  1  DA                 PHX
00AF5A  1  5A                 PHY
00AF5B  1  A0 00              LDY   #$00              ; try 256 times
00AF5D  1  48           :     PHA
00AF5E  1  A9 00              LDA   #$00
00AF60  1  5A                 PHY
00AF61  1  20 09 B0           JSR   DO_VEC_OUT_STATUS ; get device status
00AF64  1  7A                 PLY
00AF65  1  68                 PLA                     ; anticipate success
00AF66  1  B0 03              BCS   DO_OUT            ; if so
00AF68  1  88                 DEY                     ; carry clear
00AF69  1                     ; TODO: implement small delay and if it doesn't succeed report error
00AF69  1  D0 F2              BNE   :-                ; re-try
00AF6B  1                     ; BCC   :+              ; carry is still clear, don't do it
00AF6B  1                     ; Line above commented, do the output anyway
00AF6B  1               DO_OUT:
00AF6B  1  20 17 B0           JSR   DO_VEC_OUT        ; write it
00AF6E  1  E0 01              CPX   #$01
00AF70  1  B0 03              BCS   :+
00AF72  1  8E rr rr           STX   ERRNO_PASCAL_IO
00AF75  1  C9 0C        :     CMP   #$0C              ; was form feed?
00AF77  1  D0 02              BNE   :+
00AF79  1  A9 0D              LDA   #$0D              ; lie and say it was a CR
00AF7B  1  7A           :     PLY
00AF7C  1  FA                 PLX
00AF7D  1  68                 PLA
00AF7E  1  60                 RTS
00AF7F  1               
00AF7F  1               ; Onput routine for Apple II KSW vector
00AF7F  1               V_OUTP_MON
00AF7F  1  29 7F              AND   #$7F              ; firmware always sends high bit set
00AF81  1  80 D5              BRA   V_OUTP
00AF83  1               
00AF83  1               ; blindly set input slot, expect basic to set A properly!
00AF83  1               ; slot in A
00AF83  1               DO_VEC_SETISLOT
00AF83  1  48                 pha                     ; save slot #
00AF84  1  0A                 asl
00AF85  1  0A                 asl
00AF86  1  0A                 asl
00AF87  1  0A                 asl                     ; $s0
00AF88  1  8D rr rr           sta   IO_SLOT_IN
00AF8B  1  4A                 lsr
00AF8C  1  AA                 tax                     ; will be index into slot table
00AF8D  1  BD rr rr           lda   SLOT_TAB,x        ; first word is PINIT
00AF90  1  8D rr rr           sta   IO_PINIT
00AF93  1  E8                 inx
00AF94  1  BD rr rr           lda   SLOT_TAB,x
00AF97  1  8D rr rr           sta   IO_PINIT+1
00AF9A  1  E8                 inx                     ; now on PREAD
00AF9B  1  BD rr rr           lda   SLOT_TAB,x
00AF9E  1  8D rr rr           sta   IO_IN_PREAD
00AFA1  1  E8                 inx
00AFA2  1  BD rr rr           lda   SLOT_TAB,x
00AFA5  1  8D rr rr           sta   IO_IN_PREAD+1
00AFA8  1  E8                 inx                     ; skip PWRITE
00AFA9  1  E8                 inx
00AFAA  1  E8                 inx                     ; in favor of PSTATUS
00AFAB  1  BD rr rr           lda   SLOT_TAB,x
00AFAE  1  8D rr rr           sta   IO_IN_PSTATUS
00AFB1  1  E8                 inx
00AFB2  1  BD rr rr           lda   SLOT_TAB,x
00AFB5  1  8D rr rr           sta   IO_IN_PSTATUS+1
00AFB8  1  80 35              bra   :+                ; yes, all the way into DO_VEC_SETOSLOT
00AFBA  1               ; blindly set output slot, expect basic to set A properly!
00AFBA  1               ; slot in A
00AFBA  1               DO_VEC_SETOSLOT
00AFBA  1  48                 pha                     ; save slot #
00AFBB  1  0A                 asl
00AFBC  1  0A                 asl
00AFBD  1  0A                 asl
00AFBE  1  0A                 asl                     ; $s0
00AFBF  1  8D rr rr           sta   IO_SLOT_OUT
00AFC2  1  4A                 lsr
00AFC3  1  AA                 tax                     ; will be index into slot table
00AFC4  1  BD rr rr           lda   SLOT_TAB,x        ; first word is PINIT
00AFC7  1  8D rr rr           sta   IO_PINIT
00AFCA  1  E8                 inx
00AFCB  1  BD rr rr           lda   SLOT_TAB,x
00AFCE  1  8D rr rr           sta   IO_PINIT+1
00AFD1  1  E8                 inx                     ; skip PREAD
00AFD2  1  E8                 inx
00AFD3  1  E8                 inx                     ; in favor of PWRITE
00AFD4  1  BD rr rr           lda   SLOT_TAB,x
00AFD7  1  8D rr rr           sta   IO_OUT_PWRITE
00AFDA  1  E8                 inx
00AFDB  1  BD rr rr           lda   SLOT_TAB,x
00AFDE  1  8D rr rr           sta   IO_OUT_PWRITE+1
00AFE1  1  E8                 inx                     ; now on PSTATUS
00AFE2  1  BD rr rr           lda   SLOT_TAB,x
00AFE5  1  8D rr rr           sta   IO_OUT_PSTATUS
00AFE8  1  E8                 inx
00AFE9  1  BD rr rr           lda   SLOT_TAB,x
00AFEC  1  8D rr rr           sta   IO_OUT_PSTATUS+1
00AFEF  1  FA           :     plx
00AFF0  1  3C rr rr           bit   SLOT_STATUS,x
00AFF3  1  10 01              bpl   :+
00AFF5  1  60                 rts
00AFF6  1  A9 80        :     lda   #$80
00AFF8  1  9D rr rr           sta   SLOT_STATUS,x
00AFFB  1                     ; fall-through
00AFFB  1               DO_VEC_PINIT
00AFFB  1  AD rr rr           lda   IO_PINIT+1
00AFFE  1  AA                 tax
00AFFF  1  0A                 asl
00B000  1  0A                 asl
00B001  1  0A                 asl
00B002  1  A8                 tay
00B003  1  2C FF CF           bit   $CFFF             ; SSC workaround
00B006  1  6C rr rr           jmp   (IO_PINIT)
00B009  1               DO_VEC_OUT_STATUS
00B009  1  AE rr rr           ldx   IO_OUT_PSTATUS+1  ; $Cn
00B00C  1  AC rr rr           ldy   IO_SLOT_OUT       ; $n0
00B00F  1  A9 00              lda   #$00
00B011  1  2C FF CF           bit   $CFFF             ; SSC workaround
00B014  1  6C rr rr           JMP   (IO_OUT_PSTATUS)
00B017  1               DO_VEC_OUT
00B017  1  C9 0D              cmp   #$0d              ; is CR
00B019  1  D0 0F              bne   :+
00B01B  1  A5 33              lda   ZP_PROMPT         ; check prompt character
00B01D  1  C9 45              cmp   #'E'              ; see if it's ours (we don't use it)
00B01F  1  08                 php                     ; and save that result
00B020  1  A9 0D              lda   #$0d              ; fix to intended
00B022  1  28                 plp                     ; and get prompt results back
00B023  1  F0 05              beq   :+                ; no translation if prompt is ours
00B025  1  20 2A B0           jsr   :+                ; otherwise output the CR
00B028  1  A9 0A              lda   #$0a              ; then a linefeeed
00B02A  1  AE rr rr     :     ldx   IO_OUT_PWRITE+1   ; $Cn
00B02D  1  AC rr rr           ldy   IO_SLOT_OUT       ; $n0
00B030  1  2C FF CF           bit   $CFFF             ; SSC workaround
00B033  1  6C rr rr           JMP   (IO_OUT_PWRITE)
00B036  1               DO_VEC_IN_STATUS
00B036  1  AE rr rr           ldx   IO_IN_PSTATUS+1   ; $Cn
00B039  1  AC rr rr           ldy   IO_SLOT_IN        ; $n0
00B03C  1  A9 01              lda   #$01              ; input status
00B03E  1  2C FF CF           bit   $CFFF             ; SSC workaround
00B041  1  6C rr rr           jmp   (IO_IN_PSTATUS)
00B044  1               DO_VEC_IN
00B044  1  AE rr rr           ldx   IO_IN_PREAD+1     ; $Cn
00B047  1  AC rr rr           ldy   IO_SLOT_IN        ; $n0
00B04A  1  2C FF CF           bit   $CFFF             ; SSC workaround
00B04D  1  6C rr rr           JMP   (IO_IN_PREAD)
00B050  1               
00B050  1               ; *************************************
00B050  1               ; Apple II 40-col screen and built-in keyboard
00B050  1               ; Pascal 1.1-ish I/O routines
00B050  1               ; *************************************
00B050  1               
00B050  1               A2_STDIO_PINIT
00B050  1  8D 00 C0           sta   STORE80OFF
00B053  1  8D 0C C0           sta   CLR80VID
00B056  1  20 2F FB           jsr   F8_INIT           ; init display
00B059  1  A9 rr              lda   #<IO_A2_INPT      ; setup firmware input vector
00B05B  1  85 38              sta   ZP_KSWL
00B05D  1  A9 rr              lda   #>IO_A2_INPT
00B05F  1  85 39              sta   ZP_KSWH
00B061  1  A9 rr              lda   #<IO_A2_OUTP      ; setup firmware input vector
00B063  1  85 36              sta   ZP_CSWL
00B065  1  A9 rr              lda   #>IO_A2_OUTP
00B067  1  85 37              sta   ZP_CSWH
00B069  1  20 84 FE           jsr   F8_SETNORM        ; set normal video
00B06C  1  8D 0F C0           sta   SETALTCHAR        ; mousetext on
00B06F  1  60                 rts
00B070  1               
00B070  1               A2_STDIO_PREAD
00B070  1  20 41 B1           jsr   A2_STDIO_PSTAT_IN ; it does the needful
00B073  1  90 03              bcc   :+
00B075  1  8D 10 C0           sta   KBD_STROBE        ; clear keyboard strobe
00B078  1  60           :     rts
00B079  1               
00B079  1               A2_STDIO_PWRITE
00B079  1  80 00              bra   A2_PW_NOGOTOXY    ; will modify
00B07B  1               A2_PW_NOGOTOXY
00B07B  1  AA                 tax                     ; save it
00B07C  1  C9 20              cmp   #' '
00B07E  1  90 2E              bcc   A2_PW_CTRL
00B080  1  24 32              bit   ZP_TXTMASK        ; check inverse
00B082  1  10 0A              bpl   A2_PW_INV
00B084  1               A2_PW_NOINV
00B084  1  49 80              eor   #$80              ; make apple II char
00B086  1  20 F0 FD           jsr   F8_COUT1          ; write to screen, preserves a
00B089  1  49 80              eor   #$80              ; back to EhBASIC char
00B08B  1               A2_PW_DN
00B08B  1  A2 00              ldx   #$00              ; pascal firmware error code
00B08D  1               A2_PW_NOP
00B08D  1  60                 rts
00B08E  1               A2_PW_INV
00B08E  1  A5 32              lda   ZP_TXTMASK        ; current char output mask
00B090  1  48                 pha
00B091  1  A9 FF              lda   #$ff
00B093  1  85 32              sta   ZP_TXTMASK        ; tell COUT1 not to mess with it
00B095  1  8A                 txa                     ; get our char back
00B096  1  2C rr rr           bit   SLOT_STATUS+0     ; check moustext flag
00B099  1  70 0A              bvs   :+                ; head straight over if so
00B09B  1  C9 60              cmp   #'`'              ; lower-case-ish?
00B09D  1  B0 06              bcs   :+                ; don't munge it
00B09F  1  C9 40              cmp   #'@'              ; digit-ish?
00B0A1  1  90 02              bcc   :+                ; don't munge those, either
00B0A3  1  E9 40              sbc   #$40              ; munge anything else (carry is pre-set)
00B0A5  1  20 F0 FD     :     jsr   F8_COUT1          ; preserves all registers
00B0A8  1  68                 pla                     ; old mask
00B0A9  1  85 32              sta   ZP_TXTMASK        ; put it back
00B0AB  1  8A                 txa                     ; get unmunged char back
00B0AC  1  80 DD              bra   A2_PW_DN          ; finish up
00B0AE  1               A2_PW_CTRL
00B0AE  1  C9 06              cmp   #$06              ; avoid having 12 bytes wasted on NOPs
00B0B0  1  90 D9              bcc   A2_PW_DN
00B0B2  1  48                 pha                     ; save A so we can get jump table offset
00B0B3  1  0A                 asl
00B0B4  1  AA                 tax                     ; and put in X
00B0B5  1  68                 pla                     ; get A and save again because some routines
00B0B6  1  48                 pha                     ; use the firmware
00B0B7  1  20 BD B0           jsr   A2_PW_DOCTRL      ; perform action
00B0BA  1  68                 pla                     ; get char back
00B0BB  1  80 CE              bra   A2_PW_DN
00B0BD  1               A2_PW_DOCTRL
00B0BD  1  7C CD B0           jmp   (A2_PW_CTRLTAB-(6*2),x)
00B0C0  1               A2_PW_GOTOXY
00B0C0  1  A9 4B              lda   #A2_PW_GOTOXYH-A2_PW_NOGOTOXY
00B0C2  1               A2_PW_SETGOTO
00B0C2  1  8D 7A B0           sta   A2_STDIO_PWRITE+1 ; tell routine to do horizontal position
00B0C5  1  60                 rts
00B0C6  1               A2_PW_GOTOXYH
00B0C6  1  38                 sec
00B0C7  1  E9 20              sbc   #32
00B0C9  1  85 24              sta   ZP_CH
00B0CB  1  A9 54              lda   #A2_PW_GOTOXYV-A2_PW_NOGOTOXY
00B0CD  1  80 F3              bra   A2_PW_SETGOTO
00B0CF  1               A2_PW_GOTOXYV
00B0CF  1  38                 sec
00B0D0  1  E9 20              sbc   #32
00B0D2  1  20 5B FB           jsr   F8_TABV
00B0D5  1  9C 7A B0           stz   A2_STDIO_PWRITE+1 ; tell routine to do normal action
00B0D8  1  60                 rts
00B0D9  1               A2_PW_CTRLTAB
00B0D9  1  8D B0              .addr A2_PW_NOP         ; $06 - cursor on, not supported
00B0DB  1  84 B0              .addr A2_PW_NOINV       ; $07 - bell
00B0DD  1  84 B0              .addr A2_PW_NOINV       ; $08 - backspace/left arrow
00B0DF  1  8D B0              .addr A2_PW_NOP         ; $09 - tab - TODO
00B0E1  1  84 B0              .addr A2_PW_NOINV       ; $0A - cursor down (line feed)
00B0E3  1  42 FC              .addr F8_CLREOP         ; $0B - clear to end of screen
00B0E5  1  58 FC              .addr F8_HOME           ; $0C - home
00B0E7  1  0D B1              .addr A2_PW_CR          ; $0D - CR
00B0E9  1  84 FE              .addr F8_SETNORM        ; $0E - normal
00B0EB  1  80 FE              .addr F8_SETINV         ; $0F - inverse
00B0ED  1  8D B0              .addr A2_PW_NOP         ; $10 - none
00B0EF  1  8D B0              .addr A2_PW_NOP         ; $11 - none
00B0F1  1  8D B0              .addr A2_PW_NOP         ; $12 - none
00B0F3  1  8D B0              .addr A2_PW_NOP         ; $13 - none
00B0F5  1  8D B0              .addr A2_PW_NOP         ; $14 - none
00B0F7  1  8D B0              .addr A2_PW_NOP         ; $15 - none
00B0F9  1  8D B0              .addr A2_PW_NOP         ; $16 - scroll down - clear top line - TODO
00B0FB  1  70 FC              .addr F8_SCROLL         ; $17 - scroll up
00B0FD  1  18 B1              .addr A2_PW_MTOFF       ; $18 - mousetext off
00B0FF  1  1E B1              .addr A2_PW_GOTO00      ; $19 - go to 0,0
00B101  1  25 B1              .addr A2_PW_CLRLN       ; $1A - clear entire line
00B103  1  12 B1              .addr A2_PW_MTON        ; $1B - mousetext on
00B105  1  31 B1              .addr A2_PW_ADVANCE     ; $1C - move right, wrap to 0
00B107  1  9C FC              .addr F8_CLREOL         ; $1D - Clear to end of line
00B109  1  C0 B0              .addr A2_PW_GOTOXY      ; $1E - Goto XY
00B10B  1  1A FC              .addr F8_UP             ; $1F - cursor up
00B10D  1               A2_PW_CR
00B10D  1  A5 20              lda   ZP_WNDLFT         ; left of window
00B10F  1  85 24              sta   ZP_CH             ; go there
00B111  1  60                 rts
00B112  1               A2_PW_MTON
00B112  1  A9 40              lda   #%01000000
00B114  1  0C rr rr           tsb   SLOT_STATUS+0
00B117  1  60                 rts
00B118  1               A2_PW_MTOFF
00B118  1  A9 40              lda   #%01000000
00B11A  1  1C rr rr           trb   SLOT_STATUS+0
00B11D  1  60                 rts
00B11E  1               A2_PW_GOTO00
00B11E  1  A9 00              lda   #$00
00B120  1  85 24              sta   ZP_CH
00B122  1  4C 5B FB           jmp   F8_TABV
00B125  1               A2_PW_CLRLN
00B125  1  A5 24              lda   ZP_CH
00B127  1  48                 pha
00B128  1  64 24              stz   ZP_CH
00B12A  1  20 9C FC           jsr   F8_CLREOL
00B12D  1  68                 pla
00B12E  1  85 24              sta   ZP_CH
00B130  1  60                 rts
00B131  1               A2_PW_ADVANCE
00B131  1  E6 24              inc   ZP_CH
00B133  1  A5 24              lda   ZP_CH
00B135  1  C5 21              cmp   ZP_WNDWDTH
00B137  1  90 02              bcc   :+
00B139  1  64 24              stz   ZP_CH
00B13B  1  60           :     rts
00B13C  1               
00B13C  1               
00B13C  1               
00B13C  1               A2_STDIO_PSTATUS
00B13C  1  09 00              ora   #$00              ; set flags
00B13E  1  38                 sec                     ; anticipate success
00B13F  1  F0 07              beq   :+                ; want output ready status, always ready!
00B141  1               A2_STDIO_PSTAT_IN
00B141  1  AD 00 C0           lda   $c000             ; keyboard vector
00B144  1  0A                 asl                     ; shift left, high bit -> c, b0 = 0
00B145  1  69 00              adc   #$00              ; c -> b0
00B147  1  4A                 lsr                     ; shift right, b0 -> c
00B148  1  A2 00        :     ldx   #$00              ; success!
00B14A  1  60                 rts
00B14B  1               
00B14B  1               ; RESET key handler
00B14B  1               V_RESET
00B14B  1  20 50 B0           JSR   A2_STDIO_PINIT
00B14E  1  4C 00 00           JMP   LAB_WARM
00B151  1               
00B151  1               ; *************************************
00B151  1               
00B151  1               GetPath
00B151  1  20 30 90           JSR   LAB_EVEX          ; eval expression
00B154  1  20 97 98           JSR   LAB_EVST          ; eval string
00B157  1  C9 80              CMP   #$80              ; max path=127 chars
00B159  1  B0 01              BCS   :+
00B15B  1  60                 RTS
00B15C  1  A9 1A        :     LDA   #$1A
00B15E  1  4C 38 85           JMP   LAB_XERR          ; string too long
00B161  1               
00B161  1               ; Copy string to pathbuf (normally $280)
00B161  1               ; expected: A=length, XY=pointer to string
00B161  1               CopyPath
00B161  1  48                 pha
00B162  1  8D 80 02           sta   PathBuf           ; save length in
00B165  1  A9 81              lda   #<(PathBuf+1)
00B167  1  85 B6              sta   OSptr2
00B169  1  A9 02              lda   #>(PathBuf+1)
00B16B  1  85 B7              sta   OSptr2+1
00B16D  1  68                 pla
00B16E  1               ; copy string of length A from XY to (OSptr2) and fix case
00B16E  1               Do_CopyPath
00B16E  1  86 B4              stx   OSptr
00B170  1  84 B5              sty   OSptr+1           ; save address on zpage
00B172  1  A0 00              ldy   #$00
00B174  1  91 B6              sta   (OSptr2),y
00B176  1  A8                 tay                     ; now copy string to path buffer
00B177  1  B1 B4        :     lda   (OSptr),y
00B179  1  C9 61              cmp   #'a'
00B17B  1  90 03              bcc   :+
00B17D  1  2D rr rr           and   P8_LCMASK         ; convert case if needed
00B180  1  91 B6        :     sta   (OSptr2),y
00B182  1  88                 dey
00B183  1  10 F2              bpl   :--
00B185  1  60                 rts
00B186  1               ; Copy string to reserve buffer
00B186  1               ; expected: A=length, XY=pointer to string
00B186  1               CopyPath2
00B186  1  48                 pha
00B187  1  AD rr rr           lda   RES_BUF
00B18A  1  85 B6              sta   OSptr2
00B18C  1  AD rr rr           lda   RES_BUF+1
00B18F  1  85 B7              sta   OSptr2+1
00B191  1  68                 pla
00B192  1  5A                 phy
00B193  1  A0 00              ldy   #$00
00B195  1  91 B6              sta   (OSptr2),y
00B197  1  7A                 ply
00B198  1  E6 B6              inc   OSptr2
00B19A  1  D0 02              bne   :+
00B19C  1  E6 B7              inc   OSptr2+1
00B19E  1  80 CE        :     bra   Do_CopyPath
00B1A0  1               
00B1A0  1               ; Current file format:
00B1A0  1               ; TYPE: $F8, aux $EBA0 (for program, $EBAx in general)
00B1A0  1               
00B1A0  1               ; Future file format:
00B1A0  1               ; will save with the above type/aux type, plus the below header
00B1A0  1               ; load will load any file that has the below header
00B1A0  1               ; $00: A0                       ; magic #1
00B1A0  1               ; $01: EB                       ; magic #2
00B1A0  1               ; $02: version saved under
00B1A0  1               ; $03: minimum version needed to run
00B1A0  1               ; $04-$05: start addr of program when it was saved
00B1A0  1               ; $06-$0F: reserved
00B1A0  1               ; $10+: Program data
00B1A0  1               
00B1A0  1               ; this entry is used by run <string>
00B1A0  1               V_LOAD_AND_RUN
00B1A0  1  A9 80              lda   #$80
00B1A2  1  8D rr rr           sta   AUTO_RUN
00B1A5  1               V_LOAD
00B1A5  1  A9 FF              lda   #$ff              ; do load
00B1A7  1  20 CB B1           jsr   LDSV              ; execute load/save
00B1AA  1               V_LOAD_S2                     ; jumped from loader code if startup file present
00B1AA  1  2C rr rr           bit   AUTO_RUN
00B1AD  1  30 07              bmi   :+                ; no message if we will auto-run
00B1AF  1  A9 05              lda   #<LAB_RMSG        ; Ready message
00B1B1  1  A0 BD              ldy   #>LAB_RMSG
00B1B3  1  20 18 8E           jsr   LAB_18C3          ; print it
00B1B6  1  4C 61 86     :     jmp   LAB_1319          ; re-link program, clear vars
00B1B9  1               V_LOAD_S1:                    ; called by loader if startup file present
00B1B9  1  8D rr rr           sta   START_FILE
00B1BC  1  A9 FF              lda   #$ff
00B1BE  1  48                 pha
00B1BF  1  AD rr rr           lda   START_FILE
00B1C2  1  D0 0B              bne   LDSV_S1           ; load it
00B1C4  1  00                 brk                     ; crash if something stinks, to avoid doing SAVE
00B1C5  1               V_SAVE
00B1C5  1  C9 9F              cmp   #TK_LIST
00B1C7  1  F0 6E              beq   SAVE_LIST
00B1C9  1  A9 00              lda   #$00
00B1CB  1               LDSV
00B1CB  1  48                 pha
00B1CC  1  20 51 B1           jsr   GetPath
00B1CF  1               LDSV_S1                       ; called from loader code if startup file present
00B1CF  1  20 61 B1           jsr   CopyPath
00B1D2  1                     ; TODO: open any and check for header
00B1D2  1  A9 F8              lda   #$f8
00B1D4  1  8D 37 B3           sta   PARM_Create+$4    ; type
00B1D7  1  A9 A0              lda   #$a0
00B1D9  1  8D 38 B3           sta   PARM_Create+$5    ; aux type low
00B1DC  1  A9 EB              lda   #$eb
00B1DE  1  8D 39 B3           sta   PARM_Create+$6    ; aux type high
00B1E1  1  AD rr rr           lda   RES_BUF
00B1E4  1  8D 42 B3           sta   PARM_Open+3
00B1E7  1  AD rr rr           lda   RES_BUF+1
00B1EA  1  8D 43 B3           sta   PARM_Open+4
00B1ED  1  68                 pla                     ; get operation, $00=save, which allows CREATE
00B1EE  1  48                 pha                     ; need it later
00B1EF  1  20 3A B2           jsr   LAB_OPENFILE      ; try opening the file
00B1F2  1                     ; TODO: validate header
00B1F2  1  A5 79              lda   Smeml             ; start read/write at start of memory
00B1F4  1  8D 47 B3           sta   PARM_ReadWrite+2
00B1F7  1  A5 7A              lda   Smemh
00B1F9  1  8D 48 B3           sta   PARM_ReadWrite+3
00B1FC  1  68                 pla                     ; look at load/save op one more time
00B1FD  1  F0 22              beq   LDSV_WRITE        ; $00 = save
00B1FF  1                     ; jsr   LAB_1463          ; execute "NEW"
00B1FF  1  A5 85              lda   Ememl             ; begin reading
00B201  1  38                 sec
00B202  1  E5 79              sbc   Smeml             ; try to transfer max # of bytes
00B204  1  8D 49 B3           sta   PARM_ReadWrite+4
00B207  1  A5 86              lda   Ememh
00B209  1  E5 7A              sbc   Smemh
00B20B  1  8D 4A B3           sta   PARM_ReadWrite+5
00B20E  1  20 CA B2           jsr   P8_Read
00B211  1  A5 79              lda   Smeml             ; now set Svarl/h accounting for actual prog size
00B213  1  6D 4B B3           adc   PARM_ReadWrite+6  ; carry is clear because no P8 error
00B216  1  85 7B              sta   Svarl
00B218  1  A5 7A              lda   Smemh
00B21A  1  6D 4C B3           adc   PARM_ReadWrite+7
00B21D  1  85 7C              sta   Svarh
00B21F  1  90 12              bcc   LDSV_CLOSE        ; always, because we can't ever wrap past $FFFF
00B221  1               LDSV_WRITE
00B221  1  A5 7B              lda   Svarl             ; begin writing
00B223  1  38                 sec
00B224  1  E5 79              sbc   Smeml             ; transfer from start of mem to start of vars
00B226  1  8D 49 B3           sta   PARM_ReadWrite+4
00B229  1  A5 7C              lda   Svarh
00B22B  1  E5 7A              sbc   Smemh
00B22D  1  8D 4A B3           sta   PARM_ReadWrite+5
00B230  1  20 D2 B2           jsr   P8_Write
00B233  1               LDSV_CLOSE
00B233  1  20 DA B2           jsr   P8_Close
00B236  1  60                 rts
00B237  1               SAVE_LIST
00B237  1  4C 32 85           jmp   LAB_XCER          ; for now
00B23A  1               
00B23A  1               ; open file
00B23A  1               ; on input:
00B23A  1               ;   path in path buffer
00B23A  1               ;   a = 0 if create allowed
00B23A  1               ;   PARM_Create type and aux type are set to desired values
00B23A  1               ;     Used for creating and for validating existing fules
00B23A  1               ;     If zero, not validated
00B23A  1               ;   PARM_Open buffer pointer is set for when open is called
00B23A  1               ; on return:
00B23A  1               ;   A=file ref number of open file
00B23A  1               ;   read/write and open/close parameter lists set for this file
00B23A  1               ; on error:
00B23A  1               ;   basic error handler is executed
00B23A  1               LAB_OPENFILE
00B23A  1  48                 pha                     ; save if we are allowed to create
00B23B  1  20 A8 B2           jsr   P8_Get_File_Info  ; and let P8 do its job
00B23E  1  68                 pla                     ; get create allowed back (z flag ajusted)
00B23F  1  90 1E              bcc   LAB_OPENEX        ; open existing file (no error getting info)
00B241  1  F0 04              beq   :+                ; go do create if a=$00
00B243  1  A9 46              lda   #$46              ; otherwise file not found was the error
00B245  1  80 5C              bra   P8_DoError
00B247  1  A9 01        :     lda   #$01              ; storage type $1 = regular file
00B249  1  8D 3A B3           sta   PARM_Create+$7
00B24C  1  20 B0 B2           jsr   P8_Get_Time       ; get time
00B24F  1  A2 03              ldx   #$03              ; copy date/time
00B251  1  BD 90 BF     :     lda   $bf90,x
00B254  1  9D 3B B3           sta   PARM_Create+$8,x
00B257  1  CA                 dex
00B258  1  10 F7              bpl   :-
00B25A  1  20 B7 B2           jsr   P8_Create
00B25D  1  90 27              bcc   LAB_DOOPEN        ; always (read code and convince yourself!)
00B25F  1               LAB_OPENEX
00B25F  1  AD 37 B3           lda   PARM_Create+$4    ; file type desired
00B262  1  F0 22              beq   LAB_DOOPEN        ; if zero, just go open file
00B264  1  CD 25 B3           cmp   PARM_File_Info+$4 ; file type found
00B267  1  F0 05              beq   :+                ; OK, maybe check aux type
00B269  1               LAB_FTMM
00B269  1  A2 32              ldx   #$32              ; file type mismatch
00B26B  1  4C 38 85           jmp   LAB_XERR
00B26E  1  AD 38 B3     :     lda   PARM_Create+$5    ; aux type low
00B271  1  0D 39 B3           ora   PARM_Create+$6    ; aux type high
00B274  1  F0 10              beq   LAB_DOOPEN        ; don't check aux type if no bits are set
00B276  1  AD 38 B3           lda   PARM_Create+$5
00B279  1  CD 26 B3           cmp   PARM_File_Info+$5
00B27C  1  D0 EB              bne   LAB_FTMM          ; if aux type low doesn't match
00B27E  1  AD 39 B3           lda   PARM_Create+$6
00B281  1  CD 27 B3           cmp   PARM_File_Info+$6
00B284  1  D0 E3              bne   LAB_FTMM          ; if aux type high doesn't match
00B286  1               LAB_DOOPEN                    ; buffer address already in PARM_Open
00B286  1  20 BF B2           jsr   P8_Open           ; finally we get to open the file
00B289  1  B0 18              bcs   P8_DoError        ; FNF fatal at this point
00B28B  1  AD 44 B3           lda   PARM_Open+5       ; ref num
00B28E  1  8D 46 B3           sta   PARM_ReadWrite+1  ; preemptively ready read/write
00B291  1  8D 4E B3           sta   PARM_Close+1      ; and close, for this file
00B294  1  60                 rts
00B295  1               
00B295  1               P8_CheckErrs
00B295  1  8D rr rr           sta   ERRNO_PRODOS
00B298  1  B0 01              bcs   P8_IsError
00B29A  1  60           :     rts
00B29B  1               P8_IsError
00B29B  1  C9 4C              cmp   #$4C              ; EOF
00B29D  1  B0 FB              bcs   :-                ; let caller decide how to handle EOF
00B29F  1  C9 46              cmp   #$46              ; File Not Found
00B2A1  1  B0 F7              bcs   :-                ; let caller decide how to handle FnF
00B2A3  1               P8_DoError
00B2A3  1  A2 30              ldx   #$30              ; ERR_P8
00B2A5  1  4C 38 85           jmp   LAB_XERR
00B2A8  1               
00B2A8  1               
00B2A8  1               P8_Get_File_Info
00B2A8  1  20 00 BF           jsr   P8_MLI
00B2AB  1  C4                 .byte $c4
00B2AC  1  21 B3              .addr PARM_File_Info
00B2AE  1  80 E5              bra   P8_CheckErrs
00B2B0  1               
00B2B0  1               P8_Get_Time
00B2B0  1  20 00 BF           jsr   P8_MLI
00B2B3  1  82                 .byte $82
00B2B4  1  00 00              .addr $0000             ; no parameter list
00B2B6  1  60                 rts                     ; can't error, either
00B2B7  1               
00B2B7  1               P8_Create
00B2B7  1  20 00 BF           jsr   P8_MLI
00B2BA  1  C0                 .byte $C0
00B2BB  1  33 B3              .addr PARM_Create
00B2BD  1  80 D6              bra   P8_CheckErrs
00B2BF  1               
00B2BF  1               P8_Open
00B2BF  1  9C 44 B3           stz   PARM_Open+5       ; zero file ref
00B2C2  1  20 00 BF           jsr   P8_MLI
00B2C5  1  C8                 .byte $C8
00B2C6  1  3F B3              .addr PARM_Open
00B2C8  1  80 CB              bra   P8_CheckErrs
00B2CA  1               
00B2CA  1               P8_Read
00B2CA  1  20 00 BF           jsr   P8_MLI
00B2CD  1  CA                 .byte $CA
00B2CE  1  45 B3              .addr PARM_ReadWrite
00B2D0  1  80 C3              bra   P8_CheckErrs
00B2D2  1               
00B2D2  1               P8_Write
00B2D2  1  20 00 BF           jsr   P8_MLI
00B2D5  1  CB                 .byte $CB
00B2D6  1  45 B3              .addr PARM_ReadWrite
00B2D8  1  80 BB              bra   P8_CheckErrs
00B2DA  1               
00B2DA  1               P8_Close
00B2DA  1  20 00 BF           jsr   P8_MLI
00B2DD  1  CC                 .byte $CC
00B2DE  1  4D B3              .addr PARM_Close
00B2E0  1  80 B3              bra   P8_CheckErrs
00B2E2  1               
00B2E2  1               P8_CloseAll
00B2E2  1  9C 4E B3           stz   PARM_Close+1
00B2E5  1  20 00 BF           jsr   P8_MLI
00B2E8  1  CC                 .byte $CC
00B2E9  1  4D B3              .addr PARM_Close
00B2EB  1  60                 rts
00B2EC  1               
00B2EC  1               P8_Get_Prefix
00B2EC  1  20 00 BF           jsr   P8_MLI
00B2EF  1  C7                 .byte $C7
00B2F0  1  4F B3              .addr PARM_Prefix
00B2F2  1  80 A1              bra   P8_CheckErrs
00B2F4  1               
00B2F4  1               P8_Set_Prefix
00B2F4  1  20 00 BF           jsr   P8_MLI
00B2F7  1  C6                 .byte $C6
00B2F8  1  4F B3              .addr PARM_Prefix
00B2FA  1  80 99              bra   P8_CheckErrs
00B2FC  1               
00B2FC  1               P8_Online
00B2FC  1  20 00 BF           jsr   P8_MLI
00B2FF  1  C5                 .byte $C5
00B300  1  52 B3              .addr PARM_Online
00B302  1  80 91              bra   P8_CheckErrs
00B304  1               
00B304  1               P8_Rename
00B304  1  AD rr rr           lda   RES_BUF
00B307  1  8D 59 B3           sta   PARM_Rename+3
00B30A  1  AD rr rr           lda   RES_BUF+1
00B30D  1  8D 5A B3           sta   PARM_Rename+4
00B310  1  20 00 BF           jsr   P8_MLI
00B313  1  C2                 .byte $C2
00B314  1  56 B3              .addr PARM_Rename
00B316  1               P8_CheckErrs2
00B316  1  4C 95 B2           jmp   P8_CheckErrs
00B319  1               
00B319  1               P8_Destroy
00B319  1  20 00 BF           jsr   P8_MLI
00B31C  1  C1                 .byte $C1
00B31D  1  5B B3              .addr PARM_Destroy
00B31F  1  80 F5              bra   P8_CheckErrs2
00B321  1               
00B321  1               PARM_File_Info
00B321  1  0A                 .byte $0a               ; Parm count
00B322  1  80 02              .addr PathBuf           ; pathname
00B324  1  00                 .byte $00               ; access
00B325  1  00                 .byte $00               ; file type
00B326  1  00 00              .word $0000             ; aux type
00B328  1  00                 .byte $00               ; storage type
00B329  1  00 00              .word $0000             ; blocks used
00B32B  1  00 00              .word $0000             ; mod date
00B32D  1  00 00              .word $0000             ; mod time
00B32F  1  00 00              .word $0000             ; create date
00B331  1  00 00              .word $0000             ; create time
00B333  1               
00B333  1               PARM_Create
00B333  1  07                 .byte $07               ; parm count
00B334  1  80 02              .addr PathBuf           ; pathname
00B336  1  C3                 .byte $c3               ; access
00B337  1  00                 .byte $00               ; type
00B338  1  00 00              .word $0000             ; aux type
00B33A  1  00                 .byte $00               ; storage type
00B33B  1  00 00              .word $0000             ; create date
00B33D  1  00 00              .word $0000             ; create time
00B33F  1               
00B33F  1               PARM_Open
00B33F  1  03                 .byte $03               ; parm count
00B340  1  80 02              .addr PathBuf           ; pathname
00B342  1  00 00              .addr $0000             ; I/O buffer address
00B344  1  00                 .byte $00               ; reference number
00B345  1               
00B345  1               PARM_ReadWrite
00B345  1  04                 .byte $04               ; parm count
00B346  1  00                 .byte $00               ; ref num
00B347  1  00 00              .addr $0000             ; data buffer
00B349  1  00 00              .word $0000             ; request count
00B34B  1  00 00              .word $0000             ; transfer count
00B34D  1               
00B34D  1               PARM_Close
00B34D  1  01                 .byte $01               ; Parm Count
00B34E  1  00                 .byte $00               ; Ref Num
00B34F  1               
00B34F  1               PARM_Prefix
00B34F  1  01                 .byte $01
00B350  1  80 02              .addr PathBuf
00B352  1               
00B352  1               PARM_Online
00B352  1  02                 .byte $02
00B353  1  00                 .byte $00               ; unit num
00B354  1  00 00              .addr $0000             ; data buffer addr
00B356  1               
00B356  1               PARM_Rename
00B356  1  02                 .byte $02
00B357  1  80 02              .addr PathBuf           ; old name
00B359  1  80 02              .addr PathBuf           ; new name (safe default)
00B35B  1               
00B35B  1               PARM_Destroy
00B35B  1  01                 .byte $01
00B35C  1  80 02              .addr PathBuf
00B35E  1               
00B35E  1               .else
00B35E  1               ; these are in RAM and are set by the monitor at start-up
00B35E  1               V_INPT
00B35E  1                     JMP   (VEC_IN)          ; non halting scan input device
00B35E  1               V_OUTP
00B35E  1                     JMP   (VEC_OUT)         ; send byte to output device
00B35E  1               V_LOAD
00B35E  1                     JMP   (VEC_LD)          ; load BASIC program
00B35E  1               V_SAVE
00B35E  1                     JMP   (VEC_SV)          ; save BASIC program
00B35E  1               .endif
00B35E  1               
00B35E  1               ; The rest are tables messages and code for RAM
00B35E  1               
00B35E  1               ; the rest of the code is tables and BASIC start-up code
00B35E  1               
00B35E  1               PG2_TABS
00B35E  1  00                 .byte $00               ; ctrl-c flag           -     $00 = enabled
00B35F  1  00                 .byte $00               ; ctrl-c byte           -     GET needs this
00B360  1  00                 .byte $00               ; ctrl-c byte timeout   -     GET needs this
00B361  1  0B A4              .word CTRLC             ; ctrl c check vector
00B363  1               .ifdef APPLE2
00B363  1                     ; nothing, I/O vectors initialized by loader
00B363  1               .else
00B363  1               ;     .word xxxx              ; non halting key input -     monitor to set this
00B363  1               ;     .word xxxx              ; output vector         -     monitor to set this
00B363  1               ;     .word xxxx              ; load vector           -     monitor to set this
00B363  1               ;     .word xxxx              ; save vector           -     monitor to set this
00B363  1               .endif
00B363  1               PG2_TABE
00B363  1               
00B363  1               ; character get subroutine for zero page
00B363  1               
00B363  1               ; For a 1.8432MHz 6502 including the JSR and RTS
00B363  1               ; fastest (>=":") =  29 cycles =  15.7uS
00B363  1               ; slowest (<":")  =  40 cycles =  21.7uS
00B363  1               ; space skip      = +21 cycles = +11.4uS
00B363  1               ; inc across page =  +4 cycles =  +2.2uS
00B363  1               
00B363  1               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00B363  1               ; block is copied to it's destination, any non zero page address will do at assembly
00B363  1               ; time, to assemble a three byte instruction.
00B363  1               
00B363  1               ; page 0 initialisation table from $BC
00B363  1               ; increment and scan memory
00B363  1               
00B363  1               LAB_2CEE
00B363  1  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
00B365  1  D0 02              BNE   LAB_2CF4          ; branch if no carry
00B367  1                                             ; else
00B367  1  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
00B369  1               
00B369  1               ; page 0 initialisation table from $C2
00B369  1               ; scan memory
00B369  1               
00B369  1               LAB_2CF4
00B369  1  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
00B36C  1  C9 B7              CMP   #TK_ELSE          ; compare with the token for ELSE
00B36E  1  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
00B370  1               
00B370  1  C9 3A              CMP   #':'              ; compare with ":"
00B372  1  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
00B374  1               
00B374  1  C9 20              CMP   #' '              ; compare with " "
00B376  1  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
00B378  1               
00B378  1  38                 SEC                     ; set carry for SBC
00B379  1  E9 30              SBC   #'0'              ; subtract "0"
00B37B  1  38                 SEC                     ; set carry for SBC
00B37C  1  E9 D0              SBC   #$D0              ; subtract -"0"
00B37E  1                                             ; clear carry if byte = "0"-"9"
00B37E  1               LAB_2D05
00B37E  1  60                 RTS
00B37F  1               
00B37F  1               ; page zero initialisation table $00-$12 inclusive
00B37F  1               
00B37F  1               StrTab
00B37F  1  4C                 .byte $4C               ; JMP opcode
00B380  1  00 84              .word LAB_COLD          ; initial warm start vector (cold start)
00B382  1               
00B382  1  00                 .byte $00               ; these bytes are not used by BASIC
00B383  1  00 00              .word $0000             ;
00B385  1  00 00              .word $0000             ;
00B387  1  00 00              .word $0000             ;
00B389  1               
00B389  1  4C                 .byte $4C               ; JMP opcode
00B38A  1  78 94              .word LAB_FCER          ; initial user function vector ("Function call" error)
00B38C  1  00                 .byte $00               ; default NULL count
00B38D  1  00                 .byte $00               ; clear terminal position
00B38E  1  00                 .byte $00               ; default terminal width byte
00B38F  1  F2                 .byte $F2               ; default limit for TAB = 14
00B390  1               .ifdef APPLE2
00B390  1               ; value to be pulled from global page
00B390  1               .else
00B390  1                     .word Ram_base          ; start of user RAM
00B390  1               .endif
00B390  1               EndTab
00B390  1               
00B390  1               .ifdef APPLE2
00B390  1               ; not needed
00B390  1               LAB_MSZM
00B390  1  0D 0A 4D 65        .byte $0D,$0A,"Memory size ",$00
00B394  1  6D 6F 72 79  
00B398  1  20 73 69 7A  
00B39F  1               .endif
00B39F  1               
00B39F  1               LAB_SMSG
00B39F  1               .ifdef APPLE2
00B39F  1  20 62 79 74        .byte " bytes free",$0D,$0A,$0A
00B3A3  1  65 73 20 66  
00B3A7  1  72 65 65 0D  
00B3AD  1                     ; remainder of sign-on moved to loader
00B3AD  1                     ; .byte "Enhanced BASIC 2.22p2",$0D
00B3AD  1                     ; .byte "for Apple ",$5d,$5b," by M.G.",$0D,$0D
00B3AD  1  00                 .byte $00
00B3AE  1               .else
00B3AE  1                     .byte " Bytes free",$0D,$0A,$0A
00B3AE  1                     .byte "Enhanced BASIC 2.22p2",$0A,$00
00B3AE  1               .endif
00B3AE  1               
00B3AE  1               ; numeric constants and series
00B3AE  1               
00B3AE  1                                             ; constants and series for LOG(n)
00B3AE  1               LAB_25A0
00B3AE  1  02                 .byte $02               ; counter
00B3AF  1  80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
00B3B3  1  80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
00B3B7  1               ;##   .byte $80,$76,$22,$F1   ; 0.96147
00B3B7  1  82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
00B3BB  1               ;##   .byte $82,$38,$AA,$45   ; 2.88539
00B3BB  1               
00B3BB  1               LAB_25AD
00B3BB  1  80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
00B3BF  1               LAB_25B1
00B3BF  1  81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
00B3C3  1               LAB_25B5
00B3C3  1  80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
00B3C7  1               LAB_25B9
00B3C7  1  80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
00B3CB  1               
00B3CB  1                                             ; numeric PRINT constants
00B3CB  1               LAB_2947
00B3CB  1  91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
00B3CF  1               LAB_294B
00B3CF  1  94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
00B3D3  1               LAB_294F
00B3D3  1  94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
00B3D7  1               
00B3D7  1                                             ; EXP(n) constants and series
00B3D7  1               LAB_2AFA
00B3D7  1  81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
00B3DB  1               LAB_2AFE
00B3DB  1  06                 .byte $06               ; counter
00B3DC  1  74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
00B3E0  1  77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
00B3E4  1  7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
00B3E8  1  7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
00B3EC  1  7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
00B3F0  1  80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
00B3F4  1  81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
00B3F8  1               
00B3F8  1               ;##   .byte $07               ; counter
00B3F8  1               ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
00B3F8  1               ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
00B3F8  1               ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
00B3F8  1               ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
00B3F8  1               ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
00B3F8  1               ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
00B3F8  1               ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
00B3F8  1               ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
00B3F8  1               
00B3F8  1                                             ; trigonometric constants and series
00B3F8  1               LAB_2C78
00B3F8  1  81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
00B3FC  1               LAB_2C84
00B3FC  1  04                 .byte $04               ; counter
00B3FD  1  86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
00B401  1               ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
00B401  1  87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
00B405  1               ;##   .byte $87,$99,$26,$64   ;-76.575
00B405  1  87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
00B409  1  86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
00B40D  1               ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
00B40D  1               LAB_2C7C
00B40D  1  83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
00B411  1               ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
00B411  1               
00B411  1               LAB_2CC9
00B411  1  08                 .byte $08               ; counter
00B412  1  78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
00B416  1  7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
00B41A  1  7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
00B41E  1  7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
00B422  1  7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
00B426  1  7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
00B42A  1  7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
00B42E  1  7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
00B432  1               
00B432  1               ;##   .byte $08               ; counter
00B432  1               ;##   .byte $78,$3B,$D7,$4A   ; 1/17
00B432  1               ;##   .byte $7B,$84,$6E,$02   ;-1/15
00B432  1               ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
00B432  1               ;##   .byte $7D,$9A,$31,$74   ;-1/11
00B432  1               ;##   .byte $7D,$5A,$3D,$84   ; 1/9
00B432  1               ;##   .byte $7E,$91,$7F,$C8   ;-1/7
00B432  1               ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
00B432  1               ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
00B432  1               
00B432  1               LAB_1D96    = *+1             ; $00,$00 used for undefined variables
00B432  1               LAB_259C
00B432  1  81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
00B436  1               LAB_2AFD
00B436  1  81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
00B43A  1               
00B43A  1                                             ; misc constants
00B43A  1               LAB_1DF7
00B43A  1  90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
00B43B  1               LAB_2A96
00B43B  1  80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
00B43F  1               LAB_2C80
00B43F  1  7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
00B443  1               LAB_26B5
00B443  1  84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
00B447  1               
00B447  1               ; This table is used in converting numbers to ASCII.
00B447  1               
00B447  1               LAB_2A9A
00B447  1               LAB_2A9B = LAB_2A9A+1
00B447  1               LAB_2A9C = LAB_2A9B+1
00B447  1  FE 79 60           .byte $FE,$79,$60       ; -100000
00B44A  1  00 27 10           .byte $00,$27,$10       ; 10000
00B44D  1  FF FC 18           .byte $FF,$FC,$18       ; -1000
00B450  1  00 00 64           .byte $00,$00,$64       ; 100
00B453  1  FF FF F6           .byte $FF,$FF,$F6       ; -10
00B456  1  00 00 01           .byte $00,$00,$01       ; 1
00B459  1               
00B459  1               .ifdef LOW_TOKENS
00B459  1               ; Note this table is for JMP (addr,x)
00B459  1               LAB_LTBL
00B459  1  36 85              .word LAB_OMER          ; reserved, print out of memory error
00B45B  1               .ifdef APPLE2
00B45B  1  E0 A5              .word LAB_SCREEN        ; SCREEN
00B45D  1  CF A5              .word LAB_CLS           ; CLS
00B45F  1  5B A6              .word LAB_TEXT          ; TEXT
00B461  1  40 A6              .word LAB_GR            ; GR
00B463  1  65 A6              .word LAB_HGR           ; HGR
00B465  1  7A A6              .word LAB_COLOR         ; COLOR=
00B467  1  C7 A6              .word LAB_PLOT          ; PLOT
00B469  1  D5 A6              .word LAB_HLIN          ; HLIN
00B46B  1  EB A6              .word LAB_VLIN          ; VLIN
00B46D  1  01 A7              .word LAB_HCOLOR        ; HCOLOR=
00B46F  1  20 A7              .word LAB_HPLOT         ; HPLOT
00B471  1  87 A7              .word LAB_BEEP          ; BEEP
00B473  1  AE AA              .word LAB_ONLINE        ; ONLINE
00B475  1  6A AA              .word LAB_RENAME        ; RENAME
00B477  1  39 AA              .word LAB_P8CALL        ; P8CALL
00B479  1  B5 A7              .word LAB_MTEXT         ; MTEXT
00B47B  1  23 A9              .word LAB_TRY           ; TRY
00B47D  1  16 A9              .word LAB_ERROR         ; ERROR
00B47F  1  A0 8B              .word LAB_POP           ; POP
00B481  1               ;      .word LAB_CHTYPE        ; CHTYPE
00B481  1               ;      .word LAB_LOCK          ; LOCK
00B481  1               ;      .word LAB_UNLOCK        ; UNLOCK
00B481  1               ;      .word LAB_SYS           ; SYS
00B481  1               .endif
00B481  1               .endif
00B481  1               
00B481  1               
00B481  1               LAB_CTBL
00B481  1  46 8A              .word LAB_END-1         ; END
00B483  1  6B 89              .word LAB_FOR-1         ; FOR
00B485  1  B3 8F              .word LAB_NEXT-1        ; NEXT
00B487  1  CC 8B              .word LAB_DATA-1        ; DATA
00B489  1  8B 8E              .word LAB_INPUT-1       ; INPUT
00B48B  1  AD 92              .word LAB_DIM-1         ; DIM
00B48D  1  B5 8E              .word LAB_READ-1        ; READ
00B48F  1  E9 8C              .word LAB_LET-1         ; LET
00B491  1  BB 8C              .word LAB_DEC-1         ; DEC             new command
00B493  1  13 8B              .word LAB_GOTO-1        ; GOTO
00B495  1  C7 8A              .word LAB_RUN-1         ; RUN
00B497  1  FA 8B              .word LAB_IF-1          ; IF
00B499  1  67 8A              .word LAB_RESTORE-1     ; RESTORE         modified command
00B49B  1  F6 8A              .word LAB_GOSUB-1       ; GOSUB
00B49D  1               .ifndef NO_INT
00B49D  1                     .word LAB_RETIRQ-1      ; RETIRQ          new command
00B49D  1                     .word LAB_RETNMI-1      ; RETNMI          new command
00B49D  1               .endif
00B49D  1  AE 8B              .word LAB_RETURN-1      ; RETURN
00B49F  1  61 8C              .word LAB_REM-1         ; REM
00B4A1  1  44 8A              .word LAB_STOP-1        ; STOP
00B4A3  1  6A 8C              .word LAB_ON-1          ; ON              modified command
00B4A5  1  A5 8A              .word LAB_NULL-1        ; NULL            modified command
00B4A7  1  BE 8C              .word LAB_INC-1         ; INC             new command
00B4A9  1  E3 9A              .word LAB_WAIT-1        ; WAIT
00B4AB  1  A4 B1              .word V_LOAD-1          ; LOAD
00B4AD  1  C4 B1              .word V_SAVE-1          ; SAVE
00B4AF  1  CE 95              .word LAB_DEF-1         ; DEF
00B4B1  1  68 9A              .word LAB_POKE-1        ; POKE
00B4B3  1  84 9A              .word LAB_DOKE-1        ; DOKE            new command
00B4B5  1  D1 9A              .word LAB_CALL-1        ; CALL            new command
00B4B7  1  DC 8A              .word LAB_DO-1          ; DO              new command
00B4B9  1  45 8B              .word LAB_LOOP-1        ; LOOP            new command
00B4BB  1  8A 8D              .word LAB_PRINT-1       ; PRINT
00B4BD  1  AB 8A              .word LAB_CONT-1        ; CONT
00B4BF  1  A3 88              .word LAB_LIST-1        ; LIST
00B4C1  1  A0 88              .word LAB_CLEAR-1       ; CLEAR
00B4C3  1  48 88              .word LAB_NEW-1         ; NEW
00B4C5  1  B7 A4              .word LAB_WDTH-1        ; WIDTH           new command
00B4C7  1  59 8D              .word LAB_GET-1         ; GET             new command
00B4C9  1  A9 9A              .word LAB_SWAP-1        ; SWAP            new command
00B4CB  1  DC A2              .word LAB_BITSET-1      ; BITSET          new command
00B4CD  1  F0 A2              .word LAB_BITCLR-1      ; BITCLR          new command
00B4CF  1               .ifndef NO_INT
00B4CF  1                     .word LAB_IRQ-1         ; IRQ             new command
00B4CF  1                     .word LAB_NMI-1         ; NMI             new command
00B4CF  1               .endif
00B4CF  1               .ifdef APPLE2
00B4CF  1  BB A5              .word LAB_HOME-1        ; HOME
00B4D1  1  C0 A5              .word LAB_BYE-1         ; BYE             back to ProDOS
00B4D3  1  AB A7              .word LAB_INVERSE-1     ; INVERSE
00B4D5  1  AE A7              .word LAB_NORMAL-1      ; NORMAL
00B4D7  1  F7 A7              .word LAB_PRNUM-1       ; PR#
00B4D9  1  1C A8              .word LAB_INNUM-1       ; IN#
00B4DB  1  7E AA              .word LAB_PREFIX-1      ; PREFIX
00B4DD  1  21 AB              .word LAB_CATALOG-1     ; CAT
00B4DF  1  31 85              .word LAB_XCER-1        ; OPEN
00B4E1  1  31 85              .word LAB_XCER-1        ; CLOSE
00B4E3  1  31 85              .word LAB_XCER-1        ; WRITE
00B4E5  1  31 85              .word LAB_XCER-1        ; SEEK
00B4E7  1  31 85              .word LAB_XCER-1        ; CREATE
00B4E9  1  5D AA              .word LAB_DELETE-1      ; DELETE
00B4EB  1               .endif
00B4EB  1               
00B4EB  1               ; function pre process routine table
00B4EB  1               
00B4EB  1               LAB_FTPL
00B4EB  1               LAB_FTPM    = LAB_FTPL+$01
00B4EB  1  B3 91              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
00B4ED  1  B3 91              .word LAB_PPFN-1        ; INT(n)          "
00B4EF  1  B3 91              .word LAB_PPFN-1        ; ABS(n)          "
00B4F1  1  37 90              .word LAB_EVEZ-1        ; USR(x)    process any expression
00B4F3  1  3A 91              .word LAB_1BF7-1        ; FRE(x)          "
00B4F5  1  3A 91              .word LAB_1BF7-1        ; POS(x)          "
00B4F7  1  B3 91              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
00B4F9  1  B3 91              .word LAB_PPFN-1        ; RND(n)          "
00B4FB  1  B3 91              .word LAB_PPFN-1        ; LOG(n)          "
00B4FD  1  B3 91              .word LAB_PPFN-1        ; EXP(n)          "
00B4FF  1  B3 91              .word LAB_PPFN-1        ; COS(n)          "
00B501  1  B3 91              .word LAB_PPFN-1        ; SIN(n)          "
00B503  1  B3 91              .word LAB_PPFN-1        ; TAN(n)          "
00B505  1  B3 91              .word LAB_PPFN-1        ; ATN(n)          "
00B507  1  B3 91              .word LAB_PPFN-1        ; PEEK(n)         "
00B509  1  B3 91              .word LAB_PPFN-1        ; DEEK(n)         "
00B50B  1  00 00              .word $0000             ; SADD()    none
00B50D  1  AD 91              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
00B50F  1  B3 91              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
00B511  1  AD 91              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
00B513  1  AD 91              .word LAB_PPFS-1        ; ASC($)          "
00B515  1  AD 91              .word LAB_PPFS-1        ; UCASE$($)       "
00B517  1  AD 91              .word LAB_PPFS-1        ; LCASE$($)       "
00B519  1  B3 91              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
00B51B  1  DA 91              .word LAB_BHSS-1        ; HEX$(n)         "
00B51D  1  DA 91              .word LAB_BHSS-1        ; BIN$(n)         "
00B51F  1  00 00              .word $0000             ; BITTST()  none
00B521  1  4E A4              .word LAB_MMPP-1        ; MAX()     process numeric expression
00B523  1  4E A4              .word LAB_MMPP-1        ; MIN()           "
00B525  1  B9 91              .word LAB_PPBI-1        ; PI        advance pointer
00B527  1  B9 91              .word LAB_PPBI-1        ; TWOPI           "
00B529  1  00 00              .word $0000             ; VARPTR()  none
00B52B  1  BE 91              .word LAB_LRMS-1        ; LEFT$()   process string expression
00B52D  1  BE 91              .word LAB_LRMS-1        ; RIGHT$()        "
00B52F  1  BE 91              .word LAB_LRMS-1        ; MID$()          "
00B531  1  00 00              .word $0000             ; USING$()
00B533  1  B3 91              .word LAB_PPFN-1        ; GLOBAL()
00B535  1  B3 91              .word LAB_PPFN-1        ; PDL()
00B537  1  B3 91              .word LAB_PPFN-1        ; BTN()
00B539  1  00 00              .word $0000             ; TELL()
00B53B  1  00 00              .word $0000             ; SCRN()
00B53D  1  B3 91              .word LAB_PPFN-1        ; ERRNO()
00B53F  1  00 00              .word $0000             ; P2B$()
00B541  1  00 00              .word $0000             ; B2P$()
00B543  1  00 00              .word $0000             ; HSCRN()
00B545  1               
00B545  1               ; action addresses for functions
00B545  1               
00B545  1               LAB_FTBL
00B545  1               LAB_FTBM    = LAB_FTBL+$01
00B545  1  51 9E              .word LAB_SGN-1         ; SGN()
00B547  1  DB 9E              .word LAB_INT-1         ; INT()
00B549  1  6E 9E              .word LAB_ABS-1         ; ABS()
00B54B  1  A7 A2              .word LAB_USR-1         ; USR()
00B54D  1  93 95              .word LAB_FRE-1         ; FRE()
00B54F  1  BE 95              .word LAB_POS-1         ; POS()
00B551  1  0D A5              .word LAB_SQR-1         ; SQR()
00B553  1  F7 A1              .word LAB_RND-1         ; RND()           modified function
00B555  1  55 9C              .word LAB_LOG-1         ; LOG()
00B557  1  59 A1              .word LAB_EXP-1         ; EXP()
00B559  1  2B A2              .word LAB_COS-1         ; COS()
00B55B  1  32 A2              .word LAB_SIN-1         ; SIN()
00B55D  1  7B A2              .word LAB_TAN-1         ; TAN()
00B55F  1  AD A2              .word LAB_ATN-1         ; ATN()
00B561  1  5D 9A              .word LAB_PEEK-1        ; PEEK()
00B563  1  71 9A              .word LAB_DEEK-1        ; DEEK()          new function
00B565  1  AF 99              .word LAB_SADD-1        ; SADD()          new function
00B567  1  C8 99              .word LAB_LENS-1        ; LEN()
00B569  1  80 96              .word LAB_STRS-1        ; STR$()
00B56B  1  F5 99              .word LAB_VAL-1         ; VAL()
00B56D  1  D3 99              .word LAB_ASC-1         ; ASC()
00B56F  1  8D 99              .word LAB_UCASE-1       ; UCASE$()        new function
00B571  1  6C 99              .word LAB_LCASE-1       ; LCASE$()        new function
00B573  1  DF 98              .word LAB_CHRS-1        ; CHR$()
00B575  1  7D A3              .word LAB_HEXS-1        ; HEX$()          new function
00B577  1  2E A3              .word LAB_BINS-1        ; BIN$()          new function
00B579  1  06 A3              .word LAB_BTST-1        ; BITTST()        new function
00B57B  1  54 A4              .word LAB_MAX-1         ; MAX()           new function
00B57D  1  64 A4              .word LAB_MIN-1         ; MIN()           new function
00B57F  1  AA A5              .word LAB_PI-1          ; PI              new function
00B581  1  B4 A5              .word LAB_TWOPI-1       ; TWOPI           new function
00B583  1  9A A5              .word LAB_VARPTR-1      ; VARPTR()        new function
00B585  1  F0 98              .word LAB_LEFT-1        ; LEFT$()
00B587  1  F9 98              .word LAB_RIGHT-1       ; RIGHT$()
00B589  1  28 99              .word LAB_MIDS-1        ; MID$()
00B58B  1  31 85              .word LAB_XCER-1        ; USING$()
00B58D  1  AD A9              .word LAB_GLOBAL-1      ; GLOBAL()
00B58F  1  64 A7              .word LAB_PDL-1         ; PDL()
00B591  1  6F A7              .word LAB_BTN-1         ; BTN()
00B593  1  31 85              .word LAB_XCER-1        ; TELL()
00B595  1  31 85              .word LAB_XCER-1        ; SCRN()
00B597  1  8E A9              .word LAB_ERRNO-1       ; ERRNO()
00B599  1  49 A8              .word LAB_P2BS-1        ; P2B$()
00B59B  1  AD A8              .word LAB_B2PS-1        ; B2P$()
00B59D  1  31 85              .word LAB_XCER-1        ; HSCRN()
00B59F  1               
00B59F  1               ; hierarchy and action addresses for operator
00B59F  1               
00B59F  1               LAB_OPPT
00B59F  1  79                 .byte $79               ; +
00B5A0  1  1B 9B              .word LAB_ADD-1
00B5A2  1  79                 .byte $79               ; -
00B5A3  1  00 9B              .word LAB_SUBTRACT-1
00B5A5  1  7B                 .byte $7B               ; *
00B5A6  1  96 9C              .word LAB_MULTIPLY-1
00B5A8  1  7B                 .byte $7B               ; /
00B5A9  1  5E 9D              .word LAB_DIVIDE-1
00B5AB  1  7F                 .byte $7F               ; ^
00B5AC  1  15 A1              .word LAB_POWER-1
00B5AE  1  50                 .byte $50               ; AND
00B5AF  1  23 92              .word LAB_AND-1
00B5B1  1  46                 .byte $46               ; EOR             new operator
00B5B2  1  09 92              .word LAB_EOR-1
00B5B4  1  46                 .byte $46               ; OR
00B5B5  1  16 92              .word LAB_OR-1
00B5B7  1  56                 .byte $56               ; >>              new operator
00B5B8  1  CF 92              .word LAB_RSHIFT-1
00B5BA  1  56                 .byte $56               ; <<              new operator
00B5BB  1  B7 92              .word LAB_LSHIFT-1
00B5BD  1  7D                 .byte $7D               ; >
00B5BE  1  4E A1              .word LAB_GTHAN-1
00B5C0  1  5A                 .byte $5A               ; =
00B5C1  1  65 91              .word LAB_EQUAL-1
00B5C3  1  64                 .byte $64               ; <
00B5C4  1  44 92              .word LAB_LTHAN-1
00B5C6  1               
00B5C6  1               ; keywords start with ..
00B5C6  1               ; this is the first character table and must be in alphabetic order
00B5C6  1               
00B5C6  1               TAB_1STC
00B5C6  1  2A                 .byte "*"
00B5C7  1  2B                 .byte "+"
00B5C8  1  2D                 .byte "-"
00B5C9  1  2F                 .byte "/"
00B5CA  1  3C                 .byte "<"
00B5CB  1  3D                 .byte "="
00B5CC  1  3E                 .byte ">"
00B5CD  1  3F                 .byte "?"
00B5CE  1  41                 .byte "A"
00B5CF  1  42                 .byte "B"
00B5D0  1  43                 .byte "C"
00B5D1  1  44                 .byte "D"
00B5D2  1  45                 .byte "E"
00B5D3  1  46                 .byte "F"
00B5D4  1  47                 .byte "G"
00B5D5  1  48                 .byte "H"
00B5D6  1  49                 .byte "I"
00B5D7  1  4C                 .byte "L"
00B5D8  1  4D                 .byte "M"
00B5D9  1  4E                 .byte "N"
00B5DA  1  4F                 .byte "O"
00B5DB  1  50                 .byte "P"
00B5DC  1  52                 .byte "R"
00B5DD  1  53                 .byte "S"
00B5DE  1  54                 .byte "T"
00B5DF  1  55                 .byte "U"
00B5E0  1  56                 .byte "V"
00B5E1  1  57                 .byte "W"
00B5E2  1  5E                 .byte "^"
00B5E3  1  00                 .byte $00               ; table terminator
00B5E4  1               
00B5E4  1               ; pointers to keyword tables
00B5E4  1               
00B5E4  1               TAB_CHRT
00B5E4  1  1E B6              .word TAB_STAR          ; table for "*"
00B5E6  1  20 B6              .word TAB_PLUS          ; table for "+"
00B5E8  1  22 B6              .word TAB_MNUS          ; table for "-"
00B5EA  1  24 B6              .word TAB_SLAS          ; table for "/"
00B5EC  1  26 B6              .word TAB_LESS          ; table for "<"
00B5EE  1  2A B6              .word TAB_EQUL          ; table for "="
00B5F0  1  2C B6              .word TAB_MORE          ; table for ">"
00B5F2  1  30 B6              .word TAB_QEST          ; table for "?"
00B5F4  1  32 B6              .word TAB_ASCA          ; table for "A"
00B5F6  1  44 B6              .word TAB_ASCB          ; table for "B"
00B5F8  1  6D B6              .word TAB_ASCC          ; table for "C"
00B5FA  1  9B B6              .word TAB_ASCD          ; table for "D"
00B5FC  1  BA B6              .word TAB_ASCE          ; table for "E"
00B5FE  1  D4 B6              .word TAB_ASCF          ; table for "F"
00B600  1  E8 B6              .word TAB_ASCG          ; table for "G"
00B602  1  FE B6              .word TAB_ASCH          ; table for "H"
00B604  1  21 B7              .word TAB_ASCI          ; table for "I"
00B606  1  39 B7              .word TAB_ASCL          ; table for "L"
00B608  1  5E B7              .word TAB_ASCM          ; table for "M"
00B60A  1  71 B7              .word TAB_ASCN          ; table for "N"
00B60C  1  86 B7              .word TAB_ASCO          ; table for "O"
00B60E  1  98 B7              .word TAB_ASCP          ; table for "P"
00B610  1  CC B7              .word TAB_ASCR          ; table for "R"
00B612  1  F5 B7              .word TAB_ASCS          ; table for "S"
00B614  1  2F B8              .word TAB_ASCT          ; table for "T"
00B616  1  4F B8              .word TAB_ASCU          ; table for "U"
00B618  1  67 B8              .word TAB_ASCV          ; table for "V"
00B61A  1  77 B8              .word TAB_ASCW          ; table for "W"
00B61C  1  8B B8              .word TAB_POWR          ; table for "^"
00B61E  1               
00B61E  1               ; tables for each start character, note if a longer keyword with the same start
00B61E  1               ; letters as a shorter one exists then it must come first, else the list is in
00B61E  1               ; alphabetical order as follows ..
00B61E  1               
00B61E  1               ; [keyword,token
00B61E  1               ; [keyword,token]]
00B61E  1               ; end marker (#$00)
00B61E  1               
00B61E  1               TAB_STAR
00B61E  1  C4 00              .byte TK_MUL,$00        ; *
00B620  1               TAB_PLUS
00B620  1  C2 00              .byte TK_PLUS,$00       ; +
00B622  1               TAB_MNUS
00B622  1  C3 00              .byte TK_MINUS,$00      ; -
00B624  1               TAB_SLAS
00B624  1  C5 00              .byte TK_DIV,$00        ; /
00B626  1               TAB_LESS
00B626  1               LBB_LSHIFT
00B626  1  3C CB              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
00B628  1  CE                 .byte TK_LT             ; <
00B629  1  00                 .byte $00
00B62A  1               TAB_EQUL
00B62A  1  CD 00              .byte TK_EQUAL,$00      ; =
00B62C  1               TAB_MORE
00B62C  1               LBB_RSHIFT
00B62C  1  3E CA              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
00B62E  1  CC                 .byte TK_GT             ; >
00B62F  1  00                 .byte $00
00B630  1               TAB_QEST
00B630  1  9D 00              .byte TK_PRINT,$00      ; ?
00B632  1               TAB_ASCA
00B632  1               LBB_ABS
00B632  1  42 53 28 D1        .byte "BS(",TK_ABS      ; ABS(
00B636  1               LBB_AND
00B636  1  4E 44 C7           .byte "ND",TK_AND       ; AND
00B639  1               LBB_ASC
00B639  1  53 43 28 E3        .byte "SC(",TK_ASC      ; ASC(
00B63D  1               LBB_ATN
00B63D  1  54 4E 28 DC        .byte "TN(",TK_ATN      ; ATN(
00B641  1               .ifdef APPLE2
00B641  1               LBB_AT
00B641  1  54 C1              .byte "T",TK_AT         ; AT
00B643  1               .endif
00B643  1  00                 .byte $00
00B644  1               TAB_ASCB
00B644  1               .ifdef APPLE2
00B644  1               LBB_B2PS
00B644  1  32 50 24 28        .byte "2P$(",TK_B2PS    ; B2P$(
00B648  1  FA           
00B649  1               LBB_BEEP
00B649  1  45 45 50 0C        .byte "EEP",TK_BEEP     ; BEEP
00B64D  1               .endif
00B64D  1               LBB_BINS
00B64D  1  49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
00B651  1  E8           
00B652  1               LBB_BITCLR
00B652  1  49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
00B656  1  52 A6        
00B658  1               LBB_BITSET
00B658  1  49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
00B65C  1  54 A5        
00B65E  1               LBB_BITTST
00B65E  1  49 54 54 53        .byte "ITTST(",TK_BITTST
00B662  1  54 28 E9     
00B665  1                                             ; BITTST(
00B665  1               .ifdef APPLE2
00B665  1               LBB_BTN
00B665  1  54 4E 28 F5        .byte "TN(",TK_BTN      ; BTN(
00B669  1               LBB_BYE
00B669  1  59 45 A8           .byte "YE",TK_BYE       ; BYE
00B66C  1               .endif
00B66C  1  00                 .byte $00
00B66D  1               TAB_ASCC
00B66D  1               .ifdef LOW_TOKENS
00B66D  1               .ifdef APPLE2
00B66D  1               LBB_CLS
00B66D  1  4C 53 02           .byte "LS",TK_CLS       ; CLS
00B670  1               .endif
00B670  1               .endif
00B670  1               LBB_CALL
00B670  1  41 4C 4C 9A        .byte "ALL",TK_CALL     ; CALL
00B674  1               .ifdef APPLE2
00B674  1               LBB_CAT
00B674  1  41 54 AE           .byte "AT",TK_CAT       ; CAT
00B677  1               .endif
00B677  1               LBB_CHRS
00B677  1  48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
00B67B  1  E6           
00B67C  1               LBB_CLEAR
00B67C  1  4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
00B680  1  A0           
00B681  1               .ifdef APPLE2
00B681  1               LBB_CLOSE
00B681  1  4C 4F 53 45        .byte "LOSE",TK_CLOSE   ; CLOSE
00B685  1  B0           
00B686  1               LBB_COLOR
00B686  1  4F 4C 4F 52        .byte "OLOR=",TK_COLOR  ; COLOR=
00B68A  1  3D 06        
00B68C  1               .endif
00B68C  1               LBB_CONT
00B68C  1  4F 4E 54 9E        .byte "ONT",TK_CONT     ; CONT
00B690  1               LBB_COS
00B690  1  4F 53 28 D9        .byte "OS(",TK_COS      ; COS(
00B694  1               .ifdef APPLE2
00B694  1               LBB_CREATE
00B694  1  52 45 41 54        .byte "REATE",TK_CREATE ; CREATE
00B698  1  45 B3        
00B69A  1               .endif
00B69A  1  00                 .byte $00
00B69B  1               TAB_ASCD
00B69B  1               LBB_DATA
00B69B  1  41 54 41 83        .byte "ATA",TK_DATA     ; DATA
00B69F  1               LBB_DEC
00B69F  1  45 43 88           .byte "EC",TK_DEC       ; DEC
00B6A2  1               LBB_DEEK
00B6A2  1  45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
00B6A6  1  DE           
00B6A7  1               .ifdef APPLE2
00B6A7  1               LBB_DELETE
00B6A7  1  45 4C 45 54        .byte "ELETE",TK_DELETE ; DELETE
00B6AB  1  45 B4        
00B6AD  1               .endif
00B6AD  1               LBB_DEF
00B6AD  1  45 46 97           .byte "EF",TK_DEF       ; DEF
00B6B0  1               LBB_DIM
00B6B0  1  49 4D 85           .byte "IM",TK_DIM       ; DIM
00B6B3  1               LBB_DOKE
00B6B3  1  4F 4B 45 99        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
00B6B7  1               LBB_DO
00B6B7  1  4F 9B              .byte "O",TK_DO         ; DO
00B6B9  1  00                 .byte $00
00B6BA  1               TAB_ASCE
00B6BA  1               LBB_ELSE
00B6BA  1  4C 53 45 B7        .byte "LSE",TK_ELSE     ; ELSE
00B6BE  1               LBB_END
00B6BE  1  4E 44 80           .byte "ND",TK_END       ; END
00B6C1  1               LBB_EOR
00B6C1  1  4F 52 C8           .byte "OR",TK_EOR       ; EOR
00B6C4  1               .ifdef APPLE2
00B6C4  1               LBB_ERRNO
00B6C4  1  52 52 4E 4F        .byte "RRNO(",TK_ERRNO  ; ERRNO(
00B6C8  1  28 F8        
00B6CA  1               LBB_ERROR
00B6CA  1  52 52 4F 52        .byte "RROR",TK_ERROR   ; ERROR
00B6CE  1  12           
00B6CF  1               .endif
00B6CF  1               LBB_EXP
00B6CF  1  58 50 28 D8        .byte "XP(",TK_EXP      ; EXP(
00B6D3  1  00                 .byte $00
00B6D4  1               TAB_ASCF
00B6D4  1               .ifdef APPLE2
00B6D4  1               LBB_FLASH ; *alias*
00B6D4  1  4C 41 53 48        .byte "LASH",TK_INVERSE ; FLASH - alias of INVERSE
00B6D8  1  A9           
00B6D9  1               LBB_FLUSH
00B6D9  1  4C 55 53 48        .byte "LUSH",TK_FLUSH   ; FLUSH
00B6DD  1  B5           
00B6DE  1               .endif
00B6DE  1               LBB_FN
00B6DE  1  4E B9              .byte "N",TK_FN         ; FN
00B6E0  1               LBB_FOR
00B6E0  1  4F 52 81           .byte "OR",TK_FOR       ; FOR
00B6E3  1               LBB_FRE
00B6E3  1  52 45 28 D3        .byte "RE(",TK_FRE      ; FRE(
00B6E7  1  00                 .byte $00
00B6E8  1               TAB_ASCG
00B6E8  1               LBB_GET
00B6E8  1  45 54 A3           .byte "ET",TK_GET       ; GET
00B6EB  1               .ifdef APPLE2
00B6EB  1               LBB_GLOBAL
00B6EB  1  4C 4F 42 41        .byte "LOBAL(",TK_GLOBAL ; GLOBAL
00B6EF  1  4C 28 F3     
00B6F2  1               .endif
00B6F2  1               LBB_GOSUB
00B6F2  1  4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
00B6F6  1  8D           
00B6F7  1               LBB_GOTO
00B6F7  1  4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
00B6FB  1               .ifdef APPLE2
00B6FB  1               LBB_GR
00B6FB  1  52 04              .byte "R",TK_GR         ; GR
00B6FD  1               .endif
00B6FD  1  00                 .byte $00
00B6FE  1               TAB_ASCH
00B6FE  1               LBB_HEXS
00B6FE  1  45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
00B702  1  E7           
00B703  1               .ifdef APPLE2
00B703  1               LBB_HCOLOR
00B703  1  43 4F 4C 4F        .byte "COLOR=",TK_HCOLOR ; HCOLOR
00B707  1  52 3D 0A     
00B70A  1               LBB_HGR
00B70A  1  47 52 05           .byte "GR",TK_HGR       ; HGR
00B70D  1               LBB_HLIN
00B70D  1  4C 49 4E 08        .byte "LIN",TK_HLIN     ; HLIN
00B711  1               LBB_HOME
00B711  1  4F 4D 45 A7        .byte "OME",TK_HOME     ; HOME
00B715  1               LBB_HPLOT
00B715  1  50 4C 4F 54        .byte "PLOT",TK_HPLOT   ; HPLOT
00B719  1  0B           
00B71A  1               LBB_HSCRN
00B71A  1  53 43 52 4E        .byte "SCRN(",TK_HSCRN  ; HSCRN(
00B71E  1  28 FB        
00B720  1               .endif
00B720  1  00                 .byte $00
00B721  1               TAB_ASCI
00B721  1               LBB_IF
00B721  1  46 8B              .byte "F",TK_IF         ; IF
00B723  1               LBB_INC
00B723  1  4E 43 93           .byte "NC",TK_INC       ; INC
00B726  1               LBB_INPUT
00B726  1  4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
00B72A  1  84           
00B72B  1               LBB_INT
00B72B  1  4E 54 28 D0        .byte "NT(",TK_INT      ; INT(
00B72F  1               .ifdef APPLE2
00B72F  1               LBB_INVERSE
00B72F  1  4E 56 45 52        .byte "NVERSE",TK_INVERSE ; INVERSE
00B733  1  53 45 A9     
00B736  1               LBB_IN
00B736  1  4E 23 AC           .byte "N#",TK_IN        ; IN#
00B739  1               .endif
00B739  1               .ifndef NO_INT
00B739  1               LBB_IRQ
00B739  1                     .byte "RQ",TK_IRQ       ; IRQ
00B739  1                     .byte $00
00B739  1               .endif
00B739  1               TAB_ASCL
00B739  1               LBB_LCASES
00B739  1  43 41 53 45        .byte "CASE$(",TK_LCASES
00B73D  1  24 28 E5     
00B740  1                                             ; LCASE$(
00B740  1               LBB_LEFTS
00B740  1  45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
00B744  1  28 EF        
00B746  1               LBB_LEN
00B746  1  45 4E 28 E0        .byte "EN(",TK_LEN      ; LEN(
00B74A  1               LBB_LET
00B74A  1  45 54 87           .byte "ET",TK_LET       ; LET
00B74D  1               LBB_LIST
00B74D  1  49 53 54 9F        .byte "IST",TK_LIST     ; LIST
00B751  1               LBB_LOAD
00B751  1  4F 41 44 95        .byte "OAD",TK_LOAD     ; LOAD
00B755  1               LBB_LOG
00B755  1  4F 47 28 D7        .byte "OG(",TK_LOG      ; LOG(
00B759  1               LBB_LOOP
00B759  1  4F 4F 50 9C        .byte "OOP",TK_LOOP     ; LOOP
00B75D  1  00                 .byte $00
00B75E  1               TAB_ASCM
00B75E  1               LBB_MAX
00B75E  1  41 58 28 EA        .byte "AX(",TK_MAX      ; MAX(
00B762  1               LBB_MIDS
00B762  1  49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
00B766  1  F1           
00B767  1               LBB_MIN
00B767  1  49 4E 28 EB        .byte "IN(",TK_MIN      ; MIN(
00B76B  1               .ifdef APPLE2
00B76B  1               LBB_MTEXT
00B76B  1  54 45 58 54        .byte "TEXT",TK_MTEXT   ; MTEXT
00B76F  1  10           
00B770  1               .endif
00B770  1  00                 .byte $00
00B771  1               TAB_ASCN
00B771  1               LBB_NEW
00B771  1  45 57 A1           .byte "EW",TK_NEW       ; NEW
00B774  1               LBB_NEXT
00B774  1  45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
00B778  1               .ifndef NO_INT
00B778  1               LBB_NMI
00B778  1                     .byte "MI",TK_NMI       ; NMI
00B778  1               .endif
00B778  1               LBB_NOT
00B778  1  4F 54 BC           .byte "OT",TK_NOT       ; NOT
00B77B  1               .ifdef APPLE2
00B77B  1               LBB_NORMAL
00B77B  1  4F 52 4D 41        .byte "ORMAL",TK_NORMAL ; NORMAL
00B77F  1  4C AA        
00B781  1               .endif
00B781  1               LBB_NULL
00B781  1  55 4C 4C 92        .byte "ULL",TK_NULL     ; NULL
00B785  1  00                 .byte $00
00B786  1               TAB_ASCO
00B786  1               LBB_OFF
00B786  1  46 46 C0           .byte "FF",TK_OFF       ; OFF
00B789  1               .ifdef APPLE2
00B789  1               LBB_ONLINE
00B789  1  4E 4C 49 4E        .byte "NLINE",TK_ONLINE ; ONLINE
00B78D  1  45 0D        
00B78F  1               .endif
00B78F  1               LBB_ON
00B78F  1  4E 91              .byte "N",TK_ON         ; ON
00B791  1               .ifdef APPLE2
00B791  1               LBB_OPEN
00B791  1  50 45 4E AF        .byte "PEN",TK_OPEN     ; OPEN
00B795  1               .endif
00B795  1               LBB_OR
00B795  1  52 C9              .byte "R",TK_OR         ; OR
00B797  1  00                 .byte $00
00B798  1               TAB_ASCP
00B798  1               .ifdef APPLE2
00B798  1               LBB_P2BS
00B798  1  32 42 24 28        .byte "2B$(",TK_P2BS    ; P2B$(
00B79C  1  F9           
00B79D  1               LBB_P8CALL
00B79D  1  38 43 41 4C        .byte "8CALL",TK_P8CALL ; P8CALL
00B7A1  1  4C 0F        
00B7A3  1               LBB_PDL
00B7A3  1  44 4C 28 F4        .byte "DL(",TK_PDL      ; PDL(
00B7A7  1               .endif
00B7A7  1               LBB_PEEK
00B7A7  1  45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
00B7AB  1  DD           
00B7AC  1               LBB_PI
00B7AC  1  49 EC              .byte "I",TK_PI         ; PI
00B7AE  1               .ifdef APPLE2
00B7AE  1               LBB_PLOT
00B7AE  1  4C 4F 54 07        .byte "LOT",TK_PLOT     ; PLOT
00B7B2  1               .endif
00B7B2  1               LBB_POKE
00B7B2  1  4F 4B 45 98        .byte "OKE",TK_POKE     ; POKE
00B7B6  1               LBB_POS
00B7B6  1  4F 53 28 D4        .byte "OS(",TK_POS      ; POS(
00B7BA  1               .ifdef APPLE2
00B7BA  1               LBB_POP
00B7BA  1  4F 50 13           .byte "OP",TK_POP       ; POP (not in canonical order)
00B7BD  1               LBB_PREFIX
00B7BD  1  52 45 46 49        .byte "REFIX",TK_PREFIX ; PREFIX
00B7C1  1  58 AD        
00B7C3  1               .endif
00B7C3  1               LBB_PRINT
00B7C3  1  52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
00B7C7  1  9D           
00B7C8  1               .ifdef APPLE2
00B7C8  1               LBB_PR
00B7C8  1  52 23 AB           .byte "R#",TK_PR        ; PR#
00B7CB  1               .endif
00B7CB  1  00                 .byte $00
00B7CC  1               TAB_ASCR
00B7CC  1               LBB_READ
00B7CC  1  45 41 44 86        .byte "EAD",TK_READ     ; READ
00B7D0  1               LBB_REM
00B7D0  1  45 4D 8F           .byte "EM",TK_REM       ; REM
00B7D3  1               .ifdef APPLE2
00B7D3  1               LBB_RENAME
00B7D3  1  45 4E 41 4D        .byte "ENAME",TK_RENAME
00B7D7  1  45 0E        
00B7D9  1               .endif
00B7D9  1               LBB_RESTORE
00B7D9  1  45 53 54 4F        .byte "ESTORE",TK_RESTORE
00B7DD  1  52 45 8C     
00B7E0  1                                             ; RESTORE
00B7E0  1               .ifndef NO_INT
00B7E0  1               LBB_RETIRQ
00B7E0  1                     .byte "ETIRQ",TK_RETIRQ ; RETIRQ
00B7E0  1               LBB_RETNMI
00B7E0  1                     .byte "ETNMI",TK_RETNMI ; RETNMI
00B7E0  1               .endif
00B7E0  1               LBB_RETURN
00B7E0  1  45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
00B7E4  1  4E 8E        
00B7E6  1               LBB_RIGHTS
00B7E6  1  49 47 48 54        .byte "IGHT$(",TK_RIGHTS
00B7EA  1  24 28 F0     
00B7ED  1                                             ; RIGHT$(
00B7ED  1               LBB_RND
00B7ED  1  4E 44 28 D6        .byte "ND(",TK_RND      ; RND(
00B7F1  1               LBB_RUN
00B7F1  1  55 4E 8A           .byte "UN",TK_RUN       ; RUN
00B7F4  1  00                 .byte $00
00B7F5  1               TAB_ASCS
00B7F5  1               .ifdef LOW_TOKENS
00B7F5  1               .ifdef APPLE2
00B7F5  1               LBB_SCREEN
00B7F5  1  43 52 45 45        .byte "CREEN",TK_SCREEN ; SCREEN
00B7F9  1  4E 01        
00B7FB  1               .endif
00B7FB  1               .endif
00B7FB  1               LBB_SADD
00B7FB  1  41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
00B7FF  1  DF           
00B800  1               LBB_SAVE
00B800  1  41 56 45 96        .byte "AVE",TK_SAVE     ; SAVE
00B804  1               .ifdef APPLE2
00B804  1               LBB_SCRN
00B804  1  43 52 4E 28        .byte "CRN(",TK_SCRN    ; SCRN(
00B808  1  F7           
00B809  1               LBB_SEEK
00B809  1  45 45 4B B2        .byte "EEK",TK_SEEK     ; SEEK
00B80D  1               .endif
00B80D  1               LBB_SGN
00B80D  1  47 4E 28 CF        .byte "GN(",TK_SGN      ; SGN(
00B811  1               LBB_SIN
00B811  1  49 4E 28 DA        .byte "IN(",TK_SIN      ; SIN(
00B815  1               LBB_SPC
00B815  1  50 43 28 BA        .byte "PC(",TK_SPC      ; SPC(
00B819  1               LBB_SQR
00B819  1  51 52 28 D5        .byte "QR(",TK_SQR      ; SQR(
00B81D  1               LBB_STEP
00B81D  1  54 45 50 BD        .byte "TEP",TK_STEP     ; STEP
00B821  1               LBB_STOP
00B821  1  54 4F 50 90        .byte "TOP",TK_STOP     ; STOP
00B825  1               LBB_STRS
00B825  1  54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
00B829  1  E1           
00B82A  1               LBB_SWAP
00B82A  1  57 41 50 A4        .byte "WAP",TK_SWAP     ; SWAP
00B82E  1  00                 .byte $00
00B82F  1               TAB_ASCT
00B82F  1               LBB_TAB
00B82F  1  41 42 28 B6        .byte "AB(",TK_TAB      ; TAB(
00B833  1               LBB_TAN
00B833  1  41 4E 28 DB        .byte "AN(",TK_TAN      ; TAN(
00B837  1               .ifdef APPLE2
00B837  1               LBB_TELL
00B837  1  45 4C 4C 28        .byte "ELL(",TK_TELL    ; TELL(
00B83B  1  F6           
00B83C  1               LBB_TEXT
00B83C  1  45 58 54 03        .byte "EXT",TK_TEXT     ; TEXT
00B840  1               .endif
00B840  1               LBB_THEN
00B840  1  48 45 4E BB        .byte "HEN",TK_THEN     ; THEN
00B844  1               LBB_TO
00B844  1  4F B8              .byte "O",TK_TO         ; TO
00B846  1               .ifdef APPLE2
00B846  1               LBB_TRY
00B846  1  52 59 11           .byte "RY",TK_TRY       ; TRY
00B849  1               .endif
00B849  1               LBB_TWOPI
00B849  1  57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
00B84D  1  ED           
00B84E  1  00                 .byte $00
00B84F  1               TAB_ASCU
00B84F  1               LBB_UCASES
00B84F  1  43 41 53 45        .byte "CASE$(",TK_UCASES
00B853  1  24 28 E4     
00B856  1                                             ; UCASE$(
00B856  1               LBB_UNTIL
00B856  1  4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
00B85A  1  BE           
00B85B  1               .ifdef APPLE2
00B85B  1               LBB_USING
00B85B  1  53 49 4E 47        .byte "SING$(",TK_USINGS ; USING
00B85F  1  24 28 F2     
00B862  1               .endif
00B862  1               LBB_USR
00B862  1  53 52 28 D2        .byte "SR(",TK_USR      ; USR(
00B866  1  00                 .byte $00
00B867  1               TAB_ASCV
00B867  1               LBB_VAL
00B867  1  41 4C 28 E2        .byte "AL(",TK_VAL      ; VAL(
00B86B  1               LBB_VPTR
00B86B  1  41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
00B86F  1  52 28 EE     
00B872  1               .ifdef APPLE2
00B872  1               LBB_VLIN
00B872  1  4C 49 4E 09        .byte "LIN",TK_VLIN     ; VLIN
00B876  1               .endif
00B876  1  00                 .byte $00
00B877  1               TAB_ASCW
00B877  1               LBB_WAIT
00B877  1  41 49 54 94        .byte "AIT",TK_WAIT     ; WAIT
00B87B  1               LBB_WHILE
00B87B  1  48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
00B87F  1  BF           
00B880  1               LBB_WIDTH
00B880  1  49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
00B884  1  A2           
00B885  1               .ifdef APPLE2
00B885  1               LBB_WRITE
00B885  1  52 49 54 45        .byte "RITE",TK_WRITE   ; WRITE
00B889  1  B1           
00B88A  1               .endif
00B88A  1  00                 .byte $00
00B88B  1               TAB_POWR
00B88B  1  C6 00              .byte TK_POWER,$00      ; ^
00B88D  1               
00B88D  1               ; new decode table for LIST
00B88D  1               ; Table is ..
00B88D  1               ; byte - keyword length, keyword first character
00B88D  1               ; word - pointer to rest of keyword from dictionary
00B88D  1               
00B88D  1               ; note if length is 1 then the pointer is ignored
00B88D  1               
00B88D  1               .ifdef LOW_TOKENS
00B88D  1               LAB_KEYL
00B88D  1  01 40              .byte 1,'@'             ; Should never happen
00B88F  1  00 00              .word $0000
00B891  1               .ifdef APPLE2
00B891  1  06 53              .byte 6,'S'
00B893  1  F5 B7              .word LBB_SCREEN        ; SCREEN
00B895  1  03 43              .byte 3,'C'
00B897  1  6D B6              .word LBB_CLS           ; CLS
00B899  1  04 54              .byte 4,'T'
00B89B  1  3C B8              .word LBB_TEXT          ; TEXT
00B89D  1  02 47              .byte 2,'G'
00B89F  1  FB B6              .word LBB_GR            ; GR
00B8A1  1  03 48              .byte 3,'H'
00B8A3  1  0A B7              .word LBB_HGR           ; HGR
00B8A5  1  06 43              .byte 6,'C'
00B8A7  1  86 B6              .word LBB_COLOR         ; COLOR=
00B8A9  1  04 50              .byte 4,'P'
00B8AB  1  AE B7              .word LBB_PLOT          ; PLOT
00B8AD  1  04 48              .byte 4,'H'
00B8AF  1  0D B7              .word LBB_HLIN          ; HLIN
00B8B1  1  04 56              .byte 4,'V'
00B8B3  1  72 B8              .word LBB_VLIN          ; VLIN
00B8B5  1  07 48              .byte 7,'H'
00B8B7  1  03 B7              .word LBB_HCOLOR        ; HCOLOR=
00B8B9  1  05 48              .byte 5,'H'
00B8BB  1  15 B7              .word LBB_HPLOT         ; HPLOT
00B8BD  1  04 42              .byte 4,'B'
00B8BF  1  49 B6              .word LBB_BEEP          ; BEEP
00B8C1  1  06 4F              .byte 6,'O'
00B8C3  1  89 B7              .word LBB_ONLINE        ; ONLINE
00B8C5  1  06 52              .byte 6,'R'
00B8C7  1  D3 B7              .word LBB_RENAME        ; RENAME
00B8C9  1  06 50              .byte 6,'P'
00B8CB  1  9D B7              .word LBB_P8CALL        ; P8CALL
00B8CD  1  05 4D              .byte 5,'M'
00B8CF  1  6B B7              .word LBB_MTEXT         ; MTEXT
00B8D1  1  03 54              .byte 3,'T'
00B8D3  1  46 B8              .word LBB_TRY           ; TRY
00B8D5  1  05 45              .byte 5,'E'
00B8D7  1  CA B6              .word LBB_ERROR         ; ERROR
00B8D9  1  03 50              .byte 3,'P'
00B8DB  1  BA B7              .word LBB_POP           ; POP
00B8DD  1               .endif
00B8DD  1               .endif
00B8DD  1               
00B8DD  1               
00B8DD  1               LAB_KEYT
00B8DD  1  03 45              .byte 3,'E'
00B8DF  1  BE B6              .word LBB_END           ; END
00B8E1  1  03 46              .byte 3,'F'
00B8E3  1  E0 B6              .word LBB_FOR           ; FOR
00B8E5  1  04 4E              .byte 4,'N'
00B8E7  1  74 B7              .word LBB_NEXT          ; NEXT
00B8E9  1  04 44              .byte 4,'D'
00B8EB  1  9B B6              .word LBB_DATA          ; DATA
00B8ED  1  05 49              .byte 5,'I'
00B8EF  1  26 B7              .word LBB_INPUT         ; INPUT
00B8F1  1  03 44              .byte 3,'D'
00B8F3  1  B0 B6              .word LBB_DIM           ; DIM
00B8F5  1  04 52              .byte 4,'R'
00B8F7  1  CC B7              .word LBB_READ          ; READ
00B8F9  1  03 4C              .byte 3,'L'
00B8FB  1  4A B7              .word LBB_LET           ; LET
00B8FD  1  03 44              .byte 3,'D'
00B8FF  1  9F B6              .word LBB_DEC           ; DEC
00B901  1  04 47              .byte 4,'G'
00B903  1  F7 B6              .word LBB_GOTO          ; GOTO
00B905  1  03 52              .byte 3,'R'
00B907  1  F1 B7              .word LBB_RUN           ; RUN
00B909  1  02 49              .byte 2,'I'
00B90B  1  21 B7              .word LBB_IF            ; IF
00B90D  1  07 52              .byte 7,'R'
00B90F  1  D9 B7              .word LBB_RESTORE       ; RESTORE
00B911  1  05 47              .byte 5,'G'
00B913  1  F2 B6              .word LBB_GOSUB         ; GOSUB
00B915  1  06 52              .byte 6,'R'
00B917  1               .ifndef NO_INT
00B917  1                     .word LBB_RETIRQ        ; RETIRQ
00B917  1                     .byte 6,'R'
00B917  1                     .word LBB_RETNMI        ; RETNMI
00B917  1                     .byte 6,'R'
00B917  1               .endif
00B917  1  E0 B7              .word LBB_RETURN        ; RETURN
00B919  1  03 52              .byte 3,'R'
00B91B  1  D0 B7              .word LBB_REM           ; REM
00B91D  1  04 53              .byte 4,'S'
00B91F  1  21 B8              .word LBB_STOP          ; STOP
00B921  1  02 4F              .byte 2,'O'
00B923  1  8F B7              .word LBB_ON            ; ON
00B925  1  04 4E              .byte 4,'N'
00B927  1  81 B7              .word LBB_NULL          ; NULL
00B929  1  03 49              .byte 3,'I'
00B92B  1  23 B7              .word LBB_INC           ; INC
00B92D  1  04 57              .byte 4,'W'
00B92F  1  77 B8              .word LBB_WAIT          ; WAIT
00B931  1  04 4C              .byte 4,'L'
00B933  1  51 B7              .word LBB_LOAD          ; LOAD
00B935  1  04 53              .byte 4,'S'
00B937  1  00 B8              .word LBB_SAVE          ; SAVE
00B939  1  03 44              .byte 3,'D'
00B93B  1  AD B6              .word LBB_DEF           ; DEF
00B93D  1  04 50              .byte 4,'P'
00B93F  1  B2 B7              .word LBB_POKE          ; POKE
00B941  1  04 44              .byte 4,'D'
00B943  1  B3 B6              .word LBB_DOKE          ; DOKE
00B945  1  04 43              .byte 4,'C'
00B947  1  70 B6              .word LBB_CALL          ; CALL
00B949  1  02 44              .byte 2,'D'
00B94B  1  B7 B6              .word LBB_DO            ; DO
00B94D  1  04 4C              .byte 4,'L'
00B94F  1  59 B7              .word LBB_LOOP          ; LOOP
00B951  1  05 50              .byte 5,'P'
00B953  1  C3 B7              .word LBB_PRINT         ; PRINT
00B955  1  04 43              .byte 4,'C'
00B957  1  8C B6              .word LBB_CONT          ; CONT
00B959  1  04 4C              .byte 4,'L'
00B95B  1  4D B7              .word LBB_LIST          ; LIST
00B95D  1  05 43              .byte 5,'C'
00B95F  1  7C B6              .word LBB_CLEAR         ; CLEAR
00B961  1  03 4E              .byte 3,'N'
00B963  1  71 B7              .word LBB_NEW           ; NEW
00B965  1  05 57              .byte 5,'W'
00B967  1  80 B8              .word LBB_WIDTH         ; WIDTH
00B969  1  03 47              .byte 3,'G'
00B96B  1  E8 B6              .word LBB_GET           ; GET
00B96D  1  04 53              .byte 4,'S'
00B96F  1  2A B8              .word LBB_SWAP          ; SWAP
00B971  1  06 42              .byte 6,'B'
00B973  1  58 B6              .word LBB_BITSET        ; BITSET
00B975  1  06 42              .byte 6,'B'
00B977  1  52 B6              .word LBB_BITCLR        ; BITCLR
00B979  1               .ifndef NO_INT
00B979  1                     .byte 3,'I'
00B979  1                     .word LBB_IRQ           ; IRQ
00B979  1                     .byte 3,'N'
00B979  1                     .word LBB_NMI           ; NMI
00B979  1               .endif
00B979  1               .ifdef APPLE2
00B979  1  04 48              .byte 4,'H'
00B97B  1  11 B7              .word LBB_HOME          ; HOME
00B97D  1  03 42              .byte 3,'B'
00B97F  1  69 B6              .word LBB_BYE           ; BYE
00B981  1  07 49              .byte 7,'I'
00B983  1  2F B7              .word LBB_INVERSE       ; INVERSE
00B985  1  06 4E              .byte 6,'N'
00B987  1  7B B7              .word LBB_NORMAL        ; NORMAL
00B989  1  03 50              .byte 3,'P'
00B98B  1  C8 B7              .word LBB_PR            ; PR#
00B98D  1  03 49              .byte 3,'I'
00B98F  1  36 B7              .word LBB_IN            ; IN#
00B991  1  06 50              .byte 6,'P'
00B993  1  BD B7              .word LBB_PREFIX        ; PREFIX
00B995  1  03 43              .byte 3,'C'
00B997  1  74 B6              .word LBB_CAT           ; CAT
00B999  1  04 4F              .byte 4,'O'
00B99B  1  91 B7              .word LBB_OPEN          ; OPEN
00B99D  1  05 43              .byte 5,'C'
00B99F  1  81 B6              .word LBB_CLOSE         ; CLOSE
00B9A1  1  05 57              .byte 5,'W'
00B9A3  1  85 B8              .word LBB_WRITE         ; WRITE
00B9A5  1  04 53              .byte 4,'S'
00B9A7  1  09 B8              .word LBB_SEEK          ; SEEK
00B9A9  1  06 43              .byte 6,'C'
00B9AB  1  94 B6              .word LBB_CREATE        ; CREATE
00B9AD  1  06 44              .byte 6,'D'
00B9AF  1  A7 B6              .word LBB_DELETE        ; DELETE
00B9B1  1  05 46              .byte 5,'F'
00B9B3  1  D9 B6              .word LBB_FLUSH         ; FLUSH
00B9B5  1               .endif
00B9B5  1               
00B9B5  1               ; secondary commands (can't start a statement)
00B9B5  1               
00B9B5  1  04 54              .byte 4,'T'
00B9B7  1  2F B8              .word LBB_TAB           ; TAB
00B9B9  1  04 45              .byte 4,'E'
00B9BB  1  BA B6              .word LBB_ELSE          ; ELSE
00B9BD  1  02 54              .byte 2,'T'
00B9BF  1  44 B8              .word LBB_TO            ; TO
00B9C1  1  02 46              .byte 2,'F'
00B9C3  1  DE B6              .word LBB_FN            ; FN
00B9C5  1  04 53              .byte 4,'S'
00B9C7  1  15 B8              .word LBB_SPC           ; SPC
00B9C9  1  04 54              .byte 4,'T'
00B9CB  1  40 B8              .word LBB_THEN          ; THEN
00B9CD  1  03 4E              .byte 3,'N'
00B9CF  1  78 B7              .word LBB_NOT           ; NOT
00B9D1  1  04 53              .byte 4,'S'
00B9D3  1  1D B8              .word LBB_STEP          ; STEP
00B9D5  1  05 55              .byte 5,'U'
00B9D7  1  56 B8              .word LBB_UNTIL         ; UNTIL
00B9D9  1  05 57              .byte 5,'W'
00B9DB  1  7B B8              .word LBB_WHILE         ; WHILE
00B9DD  1  03 4F              .byte 3,'O'
00B9DF  1  86 B7              .word LBB_OFF           ; OFF
00B9E1  1  02 41              .byte 2,'A'
00B9E3  1  41 B6              .word LBB_AT            ; AT
00B9E5  1               
00B9E5  1               ; opperators
00B9E5  1               
00B9E5  1  01 2B              .byte 1,'+'
00B9E7  1  00 00              .word $0000             ; +
00B9E9  1  01 2D              .byte 1,'-'
00B9EB  1  00 00              .word $0000             ; -
00B9ED  1  01 2A              .byte 1,'*'
00B9EF  1  00 00              .word $0000             ; *
00B9F1  1  01 2F              .byte 1,'/'
00B9F3  1  00 00              .word $0000             ; /
00B9F5  1  01 5E              .byte 1,'^'
00B9F7  1  00 00              .word $0000             ; ^
00B9F9  1  03 41              .byte 3,'A'
00B9FB  1  36 B6              .word LBB_AND           ; AND
00B9FD  1  03 45              .byte 3,'E'
00B9FF  1  C1 B6              .word LBB_EOR           ; EOR
00BA01  1  02 4F              .byte 2,'O'
00BA03  1  95 B7              .word LBB_OR            ; OR
00BA05  1  02 3E              .byte 2,'>'
00BA07  1  2C B6              .word LBB_RSHIFT        ; >>
00BA09  1  02 3C              .byte 2,'<'
00BA0B  1  26 B6              .word LBB_LSHIFT        ; <<
00BA0D  1  01 3E              .byte 1,'>'
00BA0F  1  00 00              .word $0000             ; >
00BA11  1  01 3D              .byte 1,'='
00BA13  1  00 00              .word $0000             ; =
00BA15  1  01 3C              .byte 1,'<'
00BA17  1  00 00              .word $0000             ; <
00BA19  1               
00BA19  1               ; functions
00BA19  1               
00BA19  1  04 53              .byte 4,'S'             ;
00BA1B  1  0D B8              .word LBB_SGN           ; SGN
00BA1D  1  04 49              .byte 4,'I'             ;
00BA1F  1  2B B7              .word LBB_INT           ; INT
00BA21  1  04 41              .byte 4,'A'             ;
00BA23  1  32 B6              .word LBB_ABS           ; ABS
00BA25  1  04 55              .byte 4,'U'             ;
00BA27  1  62 B8              .word LBB_USR           ; USR
00BA29  1  04 46              .byte 4,'F'             ;
00BA2B  1  E3 B6              .word LBB_FRE           ; FRE
00BA2D  1  04 50              .byte 4,'P'             ;
00BA2F  1  B6 B7              .word LBB_POS           ; POS
00BA31  1  04 53              .byte 4,'S'             ;
00BA33  1  19 B8              .word LBB_SQR           ; SQR
00BA35  1  04 52              .byte 4,'R'             ;
00BA37  1  ED B7              .word LBB_RND           ; RND
00BA39  1  04 4C              .byte 4,'L'             ;
00BA3B  1  55 B7              .word LBB_LOG           ; LOG
00BA3D  1  04 45              .byte 4,'E'             ;
00BA3F  1  CF B6              .word LBB_EXP           ; EXP
00BA41  1  04 43              .byte 4,'C'             ;
00BA43  1  90 B6              .word LBB_COS           ; COS
00BA45  1  04 53              .byte 4,'S'             ;
00BA47  1  11 B8              .word LBB_SIN           ; SIN
00BA49  1  04 54              .byte 4,'T'             ;
00BA4B  1  33 B8              .word LBB_TAN           ; TAN
00BA4D  1  04 41              .byte 4,'A'             ;
00BA4F  1  3D B6              .word LBB_ATN           ; ATN
00BA51  1  05 50              .byte 5,'P'             ;
00BA53  1  A7 B7              .word LBB_PEEK          ; PEEK
00BA55  1  05 44              .byte 5,'D'             ;
00BA57  1  A2 B6              .word LBB_DEEK          ; DEEK
00BA59  1  05 53              .byte 5,'S'             ;
00BA5B  1  FB B7              .word LBB_SADD          ; SADD
00BA5D  1  04 4C              .byte 4,'L'             ;
00BA5F  1  46 B7              .word LBB_LEN           ; LEN
00BA61  1  05 53              .byte 5,'S'             ;
00BA63  1  25 B8              .word LBB_STRS          ; STR$
00BA65  1  04 56              .byte 4,'V'             ;
00BA67  1  67 B8              .word LBB_VAL           ; VAL
00BA69  1  04 41              .byte 4,'A'             ;
00BA6B  1  39 B6              .word LBB_ASC           ; ASC
00BA6D  1  07 55              .byte 7,'U'             ;
00BA6F  1  4F B8              .word LBB_UCASES        ; UCASE$
00BA71  1  07 4C              .byte 7,'L'             ;
00BA73  1  39 B7              .word LBB_LCASES        ; LCASE$
00BA75  1  05 43              .byte 5,'C'             ;
00BA77  1  77 B6              .word LBB_CHRS          ; CHR$
00BA79  1  05 48              .byte 5,'H'             ;
00BA7B  1  FE B6              .word LBB_HEXS          ; HEX$
00BA7D  1  05 42              .byte 5,'B'             ;
00BA7F  1  4D B6              .word LBB_BINS          ; BIN$
00BA81  1  07 42              .byte 7,'B'             ;
00BA83  1  5E B6              .word LBB_BITTST        ; BITTST
00BA85  1  04 4D              .byte 4,'M'             ;
00BA87  1  5E B7              .word LBB_MAX           ; MAX
00BA89  1  04 4D              .byte 4,'M'             ;
00BA8B  1  67 B7              .word LBB_MIN           ; MIN
00BA8D  1  02 50              .byte 2,'P'             ;
00BA8F  1  AC B7              .word LBB_PI            ; PI
00BA91  1  05 54              .byte 5,'T'             ;
00BA93  1  49 B8              .word LBB_TWOPI         ; TWOPI
00BA95  1  07 56              .byte 7,'V'             ;
00BA97  1  6B B8              .word LBB_VPTR          ; VARPTR
00BA99  1  06 4C              .byte 6,'L'             ;
00BA9B  1  40 B7              .word LBB_LEFTS         ; LEFT$
00BA9D  1  07 52              .byte 7,'R'             ;
00BA9F  1  E6 B7              .word LBB_RIGHTS        ; RIGHT$
00BAA1  1  05 4D              .byte 5,'M'             ;
00BAA3  1  62 B7              .word LBB_MIDS          ; MID$
00BAA5  1               .ifdef APPLE2
00BAA5  1  07 55              .byte 7,'U'
00BAA7  1  5B B8              .word LBB_USING         ; USING$
00BAA9  1  07 47              .byte 7,'G'
00BAAB  1  EB B6              .word LBB_GLOBAL        ; GLOBAL
00BAAD  1  04 50              .byte 4,'P'
00BAAF  1  A3 B7              .word LBB_PDL           ; PDL
00BAB1  1  04 42              .byte 4,'B'
00BAB3  1  65 B6              .word LBB_BTN           ; BTN
00BAB5  1  05 54              .byte 5,'T'
00BAB7  1  37 B8              .word LBB_TELL          ; TELL
00BAB9  1  05 53              .byte 5,'S'
00BABB  1  04 B8              .word LBB_SCRN          ; SCRN
00BABD  1  06 45              .byte 6,'E'
00BABF  1  C4 B6              .word LBB_ERRNO         ; ERRNO
00BAC1  1  05 50              .byte 5,'P'
00BAC3  1  98 B7              .word LBB_P2BS          ; P2B$(
00BAC5  1  05 42              .byte 5,'B'
00BAC7  1  44 B6              .word LBB_B2PS          ; B2B$(
00BAC9  1  06 48              .byte 6,'H'
00BACB  1  1A B7              .word LBB_HSCRN         ; HSCRN
00BACD  1               .endif
00BACD  1               
00BACD  1               ; BASIC messages, mostly error messages
00BACD  1               
00BACD  1               LAB_BAER
00BACD  1  A5 BB              .word ERR_NF            ;$00 NEXT without FOR
00BACF  1  B7 BB              .word ERR_SN            ;$02 syntax
00BAD1  1  BE BB              .word ERR_RG            ;$04 RETURN without GOSUB
00BAD3  1  CF BB              .word ERR_OD            ;$06 out of data
00BAD5  1  DB BB              .word ERR_FC            ;$08 function call
00BAD7  1  E9 BB              .word ERR_OV            ;$0A overflow
00BAD9  1  F2 BB              .word ERR_OM            ;$0C out of memory
00BADB  1  00 BC              .word ERR_US            ;$0E undefined statement
00BADD  1  12 BC              .word ERR_BS            ;$10 array bounds
00BADF  1  1F BC              .word ERR_DD            ;$12 double dimension array
00BAE1  1  26 BC              .word ERR_D0            ;$14 divide by 0
00BAE3  1  35 BC              .word ERR_ID            ;$16 illegal direct
00BAE5  1  49 BC              .word ERR_TM            ;$18 type mismatch
00BAE7  1  57 BC              .word ERR_LS            ;$1A long string
00BAE9  1  67 BC              .word ERR_ST            ;$1C string too complex
00BAEB  1  7A BC              .word ERR_CN            ;$1E continue error
00BAED  1  89 BC              .word ERR_UF            ;$20 undefined function
00BAEF  1  9A BC              .word ERR_LD            ;$22 LOOP without DO
00BAF1  1               .ifdef APPLE2
00BAF1  1  AA BC              .word ERR_XC            ;$24 undefined variable
00BAF3  1  AA BC              .word ERR_XC            ;$26 undimensioned array
00BAF5  1  AA BC              .word ERR_XC            ;$28 unimplemented
00BAF7  1  BB BC              .word ERR_IA            ;$2A illegal argument
00BAF9  1  CC BC              .word ERR_IO            ;$2C i/o error
00BAFB  1  D0 BC              .word ERR_ND            ;$2E no device connected
00BAFD  1  E4 BC              .word ERR_P8            ;$30 prodos
00BAFF  1  44 BC              .word ERR_FT            ;$32 file type mismatch
00BB01  1               LAST_ERR = * - LAB_BAER
00BB01  1               
00BB01  1               LAB_P8ER                      ; ProDOS error table
00BB01  1  27                 .byte $27               ; I/O error
00BB02  1  CC BC              .addr ERR_IO            ; re-use
00BB04  1  2B                 .byte $2B               ; Write protected
00BB05  1  23 BB              .addr P8E_WP
00BB07  1  2E                 .byte $2E               ; disk switched
00BB08  1  33 BB              .addr P8E_DS
00BB0A  1  40                 .byte $40               ; Bad path
00BB0B  1  B2 BB              .addr P8E_BP            ; in main error table to reuse syntax error
00BB0D  1  44                 .byte $44               ; path not found
00BB0E  1  41 BB              .addr P8E_FX
00BB10  1  45                 .byte $45               ; volume not found
00BB11  1  55 BB              .addr P8E_VX
00BB13  1  46                 .byte $46               ; file not found
00BB14  1  41 BB              .addr P8E_FX
00BB16  1  47                 .byte $47               ; duplicate file name
00BB17  1  66 BB              .addr P8E_DF
00BB19  1  4B                 .byte $4B               ; wrong storage type
00BB1A  1  7A BB              .addr P8E_ST
00BB1C  1  4E                 .byte $4E               ; access error
00BB1D  1  8D BB              .addr P8E_AE
00BB1F  1  50                 .byte $50               ; file is open
00BB20  1  9B BB              .addr P8E_FO
00BB22  1  00                 .byte $00               ; end of table
00BB23  1               
00BB23  1  77 72 69 74  P8E_WP      .byte "write protected",$00
00BB27  1  65 20 70 72  
00BB2B  1  6F 74 65 63  
00BB33  1  64 69 73 6B  P8E_DS      .byte "disk switched",$00
00BB37  1  20 73 77 69  
00BB3B  1  74 63 68 65  
00BB41  1  66 69 6C 65  P8E_FX      .byte "file/path not found",$00
00BB45  1  2F 70 61 74  
00BB49  1  68 20 6E 6F  
00BB55  1  76 6F 6C 75  P8E_VX      .byte "volume not found",$00
00BB59  1  6D 65 20 6E  
00BB5D  1  6F 74 20 66  
00BB66  1  64 75 70 6C  P8E_DF      .byte "duplicate file name",$00
00BB6A  1  69 63 61 74  
00BB6E  1  65 20 66 69  
00BB7A  1  77 72 6F 6E  P8E_ST      .byte "wrong storage type",$00
00BB7E  1  67 20 73 74  
00BB82  1  6F 72 61 67  
00BB8D  1  6E 6F 20 70  P8E_AE      .byte "no permission",$00
00BB91  1  65 72 6D 69  
00BB95  1  73 73 69 6F  
00BB9B  1  66 69 6C 65  P8E_FO      .byte "file open",$00
00BB9F  1  20 6F 70 65  
00BBA3  1  6E 00        
00BBA5  1               
00BBA5  1               .else
00BBA5  1               ; I may implement these two errors to force definition of variables and
00BBA5  1               ; dimensioning of arrays before use.
00BBA5  1               
00BBA5  1               ;     .word ERR_UV            ;$24 undefined variable
00BBA5  1               
00BBA5  1               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00BBA5  1               
00BBA5  1               ;     .word ERR_UA            ;$26 undimensioned array
00BBA5  1               .endif
00BBA5  1               
00BBA5  1               .ifdef APPLE2
00BBA5  1               ; made some of these smaller, added a few
00BBA5  1               ; TODO: consider packing/compression
00BBA5  1  4E 45 58 54  ERR_NF      .byte "NEXT w/o FOR",$00
00BBA9  1  20 77 2F 6F  
00BBAD  1  20 46 4F 52  
00BBB2  1  50 61 74 68  P8E_BP      .byte "Path "
00BBB6  1  20           
00BBB7  1  53 79 6E 74  ERR_SN      .byte "Syntax",$00
00BBBB  1  61 78 00     
00BBBE  1  52 45 54 55  ERR_RG      .byte "RETURN w/o GOSUB",$00
00BBC2  1  52 4E 20 77  
00BBC6  1  2F 6F 20 47  
00BBCF  1  4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
00BBD3  1  6F 66 20 44  
00BBD7  1  41 54 41 00  
00BBDB  1  46 75 6E 63  ERR_FC      .byte "Function call",$00
00BBDF  1  74 69 6F 6E  
00BBE3  1  20 63 61 6C  
00BBE9  1  4F 76 65 72  ERR_OV      .byte "Overflow",$00
00BBED  1  66 6C 6F 77  
00BBF1  1  00           
00BBF2  1  4F 75 74 20  ERR_OM      .byte "Out of memory",$00
00BBF6  1  6F 66 20 6D  
00BBFA  1  65 6D 6F 72  
00BC00  1  55 6E 64 65  ERR_US      .byte "Undef'd statement",$00
00BC04  1  66 27 64 20  
00BC08  1  73 74 61 74  
00BC12  1  41 72 72 61  ERR_BS      .byte "Array bounds",$00
00BC16  1  79 20 62 6F  
00BC1A  1  75 6E 64 73  
00BC1F  1  52 65 2D 44  ERR_DD      .byte "Re-DIM",$00
00BC23  1  49 4D 00     
00BC26  1  44 69 76 69  ERR_D0      .byte "Divide by zero",$00
00BC2A  1  64 65 20 62  
00BC2E  1  79 20 7A 65  
00BC35  1  49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
00BC39  1  67 61 6C 20  
00BC3D  1  64 69 72 65  
00BC44  1  46 69 6C 65  ERR_FT      .byte "File " ; roll into next message
00BC48  1  20           
00BC49  1  54 79 70 65  ERR_TM      .byte "Type mismatch",$00
00BC4D  1  20 6D 69 73  
00BC51  1  6D 61 74 63  
00BC57  1  53 74 72 69  ERR_LS      .byte "String too long",$00
00BC5B  1  6E 67 20 74  
00BC5F  1  6F 6F 20 6C  
00BC67  1  53 74 72 69  ERR_ST      .byte "String too complex",$00
00BC6B  1  6E 67 20 74  
00BC6F  1  6F 6F 20 63  
00BC7A  1  43 61 6E 27  ERR_CN      .byte "Can't continue",$00
00BC7E  1  74 20 63 6F  
00BC82  1  6E 74 69 6E  
00BC89  1  55 6E 64 65  ERR_UF      .byte "Undef'd function",$00
00BC8D  1  66 27 64 20  
00BC91  1  66 75 6E 63  
00BC9A  1  4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
00BC9E  1  20 77 69 74  
00BCA2  1  68 6F 75 74  
00BCAA  1  55 6E 69 6D  ERR_XC      .byte "Unimpl'd feature",$00
00BCAE  1  70 6C 27 64  
00BCB2  1  20 66 65 61  
00BCBB  1  49 6C 6C 65  ERR_IA      .byte "Illegal argument",$00
00BCBF  1  67 61 6C 20  
00BCC3  1  61 72 67 75  
00BCCC  1  49 2F 4F 00  ERR_IO      .byte "I/O",$00
00BCD0  1  4E 6F 20 64  ERR_ND      .byte "No device connected",$00
00BCD4  1  65 76 69 63  
00BCD8  1  65 20 63 6F  
00BCE4  1  50 72 6F 44  ERR_P8      .byte "ProDOS ",$00
00BCE8  1  4F 53 20 00  
00BCEC  1               .else
00BCEC  1               ERR_NF      .byte "NEXT without FOR",$00
00BCEC  1               ERR_SN      .byte "Syntax",$00
00BCEC  1               ERR_RG      .byte "RETURN without GOSUB",$00
00BCEC  1               ERR_OD      .byte "Out of DATA",$00
00BCEC  1               ERR_FC      .byte "Function call",$00
00BCEC  1               ERR_OV      .byte "Overflow",$00
00BCEC  1               ERR_OM      .byte "Out of memory",$00
00BCEC  1               ERR_US      .byte "Undefined statement",$00
00BCEC  1               ERR_BS      .byte "Array bounds",$00
00BCEC  1               ERR_DD      .byte "Double dimension",$00
00BCEC  1               ERR_D0      .byte "Divide by zero",$00
00BCEC  1               ERR_ID      .byte "Illegal direct",$00
00BCEC  1               ERR_TM      .byte "Type mismatch",$00
00BCEC  1               ERR_LS      .byte "String too long",$00
00BCEC  1               ERR_ST      .byte "String too complex",$00
00BCEC  1               ERR_CN      .byte "Can't continue",$00
00BCEC  1               ERR_UF      .byte "Undefined function",$00
00BCEC  1               ERR_LD      .byte "LOOP without DO",$00
00BCEC  1               
00BCEC  1               ;ERR_UV     .byte "Undefined variable",$00
00BCEC  1               
00BCEC  1               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00BCEC  1               
00BCEC  1               ;ERR_UA     .byte "Undimensioned array",$00
00BCEC  1               .endif
00BCEC  1               
00BCEC  1  0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
00BCF0  1  65 61 6B 00  
00BCF4  1  20 45 72 72  LAB_EMSG    .byte " Error",$00
00BCF8  1  6F 72 00     
00BCFB  1  20 69 6E 20  LAB_LMSG    .byte " in line ",$00
00BCFF  1  6C 69 6E 65  
00BD03  1  20 00        
00BD05  1  0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
00BD09  1  61 64 79 0D  
00BD0D  1  0A 00        
00BD0F  1  20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
00BD13  1  72 61 20 69  
00BD17  1  67 6E 6F 72  
00BD20  1  20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
00BD24  1  6F 20 66 72  
00BD28  1  6F 6D 20 73  
00BD33  1               
00BD33  1               .ifdef APPLE2
00BD33  1               FTYPES                    ; file type table
00BD33  1  01 62 61 64        .byte $01,"bad"     ; bad blocks
00BD37  1  04 74 78 74        .byte $04,"txt"     ; text file
00BD3B  1  06 62 69 6E        .byte $06,"bin"     ; binary
00BD3F  1  07 73 63 72        .byte $07,"scr"     ; screen
00BD43  1  0B 77 70 66        .byte $0B,"wpf"     ; word processor
00BD47  1  0C 73 6F 73        .byte $0C,"sos"     ; SOS system file
00BD4B  1  0F 64 69 72        .byte $0F,"dir"     ; directory
00BD4F  1  19 61 64 62        .byte $19,"adb"     ; appleworks DB
00BD53  1  1A 61 77 70        .byte $1A,"awp"     ; appleworks WP
00BD57  1  1B 61 73 70        .byte $1B,"asp"     ; appleworks SS (note not "ASS")
00BD5B  1  2C 70 38 63        .byte $2C,"p8c"     ; general command file
00BD5F  1  E2 61 74 6B        .byte $E2,"atk"     ; Appletalk file
00BD63  1  F0 63 6D 64        .byte $F0,"cmd"     ; P8 BASIC command file
00BD67  1  F8 65 62 61        .byte $F8,"eba"     ; User 8/EhBASIC
00BD6B  1  FC 62 61 73        .byte $FC,"bas"     ; Applesoft
00BD6F  1  FD 76 61 72        .byte $FD,"var"     ; Applesoft vars
00BD73  1  FE 72 65 6C        .byte $FE,"rel"     ; Relocatable code
00BD77  1  FF 73 79 73        .byte $FF,"sys"     ; P8 system file
00BD7B  1  00                 .byte $00           ; end of list
00BD7C  1               
00BD7C  1               LAB_FOLDER
00BD7C  1  1B 0F 58 59        .byte $1B,$0F,"XY",$0E,$18,' ',$00
00BD80  1  0E 18 20 00  
00BD84  1               LAB_VOLUME
00BD84  1  1B 0F 41 0E        .byte $1B,$0F,'A',$0E,$18," /",$00
00BD88  1  18 20 2F 00  
00BD8C  1               .endif
00BD8C  1               AA_end_basic
00BD8C  1               
